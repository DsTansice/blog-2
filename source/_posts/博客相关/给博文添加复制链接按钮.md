---
title: 给博文添加复制链接按钮
top_img: false
cover: 'https://image.kmar.top/bg/b39.jpg!/fw/550'
abbrlink: e1e77a4d
date: 2022-02-14 14:58:53
updated: 2022-04-28 15:55:50
categories:
  - 随心记
tags:
  - Hexo
  - 魔改
  - 教程
  - Butterfly
description: 现在的分享按钮实在是有些鸡肋，点分享还需要手机扫码，甚至手机点还需要扫码分享，所以干脆弄个按钮点击复制链接好了。
---
  
## 注意

&emsp;&emsp;该博文是基于`Butterfly`主题修改的，不跟我一个主题的不要照搬我添加元素的方法。

&emsp;&emsp;本人没有学过前端知识，所以有一些名词可能会用错或者有这个名词但是我不知道，还请各位谅解。

## 缘由

&emsp;&emsp;想要做这个魔改的原因一方面是QQ的分享太过反人类，另一方面是我发现有些浏览器（比如我正在用的）在使用PWA浏览网页时打不开地址栏，这时候想要复制链接简直是难之又难。所以一直想要加一个复制链接的按钮，但是又不会加{% inlineimage https://image.kmar.top/icon/bili/wul.png %}。正巧，前段时间看到了群友写的一篇教程，我就在他的基础上修改了一些内容，就有了这篇博文。

## 魔改步骤

### 添加按钮

&emsp;&emsp;打开`themes/[butterfly]/layout/includes/rightside.pug`，修改如下：

```diff
  when 'chat'
    if chat_btn
      button#chat_btn(type="button" title=_p("rightside.chat_btn"))
        i.fas.fa-sms
  when 'comment'
    if commentsJsLoad
      a#to_comment(href="#post-comment" title=_p("rightside.scroll_to_comment"))
        i.fas.fa-comments
+ when 'share'
+   button#share-link(type="button" title='分享链接')
+     i.fa.fa-share-alt
```

```diff
  #rightside
    - const { enable, hide, show } = theme.rightside_item_order
    - const hideArray = enable ? hide && hide.split(',') : ['readmode','translate','darkmode','hideAside']
-   - const showArray = enable ? show && show.split(',') : ['toc','chat','comment']
+   - const showArray = enable ? show && show.split(',') : ['toc','chat','comment', 'share']
```

### 添加JS

&emsp;&emsp;新建：`[butterfly]\source\js\custom\share.js`，复制以下内容：

{% p center, JS在`878`行开始是我写的内容，前面都是`clipboard`的源码 %}

```javascript
/*!
 * clipboard.js v2.0.10
 * https://clipboardjs.com/
 *
 * Licensed MIT © Zeno Rocha
 */
(function webpackUniversalModuleDefinition(root, factory) {
    if(typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if(typeof define === 'function' && define.amd)
        define([], factory);
    else if(typeof exports === 'object')
        exports["ClipboardJS"] = factory();
    else
        root["ClipboardJS"] = factory();
})(this, function() {
    return /******/ (function() { // webpackBootstrap
        /******/ 	var __webpack_modules__ = ({

            /***/ 686:
            /***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                "use strict";

// EXPORTS
                __webpack_require__.d(__webpack_exports__, {
                    "default": function() { return /* binding */ clipboard; }
                });

// EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js
                var tiny_emitter = __webpack_require__(279);
                var tiny_emitter_default = /*#__PURE__*/__webpack_require__.n(tiny_emitter);
// EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js
                var listen = __webpack_require__(370);
                var listen_default = /*#__PURE__*/__webpack_require__.n(listen);
// EXTERNAL MODULE: ./node_modules/select/src/select.js
                var src_select = __webpack_require__(817);
                var select_default = /*#__PURE__*/__webpack_require__.n(src_select);
                ;// CONCATENATED MODULE: ./src/common/command.js
                /**
                 * Executes a given operation type.
                 * @param {String} type
                 * @return {Boolean}
                 */
                function command(type) {
                    try {
                        return document.execCommand(type);
                    } catch (err) {
                        return false;
                    }
                }
                ;// CONCATENATED MODULE: ./src/actions/cut.js


                /**
                 * Cut action wrapper.
                 * @param {String|HTMLElement} target
                 * @return {String}
                 */

                var ClipboardActionCut = function ClipboardActionCut(target) {
                    var selectedText = select_default()(target);
                    command('cut');
                    return selectedText;
                };

                /* harmony default export */ var actions_cut = (ClipboardActionCut);
                ;// CONCATENATED MODULE: ./src/common/create-fake-element.js
                /**
                 * Creates a fake textarea element with a value.
                 * @param {String} value
                 * @return {HTMLElement}
                 */
                function createFakeElement(value) {
                    var isRTL = document.documentElement.getAttribute('dir') === 'rtl';
                    var fakeElement = document.createElement('textarea'); // Prevent zooming on iOS

                    fakeElement.style.fontSize = '12pt'; // Reset box model

                    fakeElement.style.border = '0';
                    fakeElement.style.padding = '0';
                    fakeElement.style.margin = '0'; // Move element out of screen horizontally

                    fakeElement.style.position = 'absolute';
                    fakeElement.style[isRTL ? 'right' : 'left'] = '-9999px'; // Move element to the same position vertically

                    var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                    fakeElement.style.top = "".concat(yPosition, "px");
                    fakeElement.setAttribute('readonly', '');
                    fakeElement.value = value;
                    return fakeElement;
                }
                ;// CONCATENATED MODULE: ./src/actions/copy.js



                /**
                 * Copy action wrapper.
                 * @param {String|HTMLElement} target
                 * @param {Object} options
                 * @return {String}
                 */

                var ClipboardActionCopy = function ClipboardActionCopy(target) {
                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                        container: document.body
                    };
                    var selectedText = '';

                    if (typeof target === 'string') {
                        var fakeElement = createFakeElement(target);
                        options.container.appendChild(fakeElement);
                        selectedText = select_default()(fakeElement);
                        command('copy');
                        fakeElement.remove();
                    } else {
                        selectedText = select_default()(target);
                        command('copy');
                    }

                    return selectedText;
                };

                /* harmony default export */ var actions_copy = (ClipboardActionCopy);
                ;// CONCATENATED MODULE: ./src/actions/default.js
                function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }



                /**
                 * Inner function which performs selection from either `text` or `target`
                 * properties and then executes copy or cut operations.
                 * @param {Object} options
                 */

                var ClipboardActionDefault = function ClipboardActionDefault() {
                    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                    // Defines base properties passed from constructor.
                    var _options$action = options.action,
                        action = _options$action === void 0 ? 'copy' : _options$action,
                        container = options.container,
                        target = options.target,
                        text = options.text; // Sets the `action` to be performed which can be either 'copy' or 'cut'.

                    if (action !== 'copy' && action !== 'cut') {
                        throw new Error('Invalid "action" value, use either "copy" or "cut"');
                    } // Sets the `target` property using an element that will be have its content copied.


                    if (target !== undefined) {
                        if (target && _typeof(target) === 'object' && target.nodeType === 1) {
                            if (action === 'copy' && target.hasAttribute('disabled')) {
                                throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                            }

                            if (action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {
                                throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
                            }
                        } else {
                            throw new Error('Invalid "target" value, use a valid Element');
                        }
                    } // Define selection strategy based on `text` property.


                    if (text) {
                        return actions_copy(text, {
                            container: container
                        });
                    } // Defines which selection strategy based on `target` property.


                    if (target) {
                        return action === 'cut' ? actions_cut(target) : actions_copy(target, {
                            container: container
                        });
                    }
                };

                /* harmony default export */ var actions_default = (ClipboardActionDefault);
                ;// CONCATENATED MODULE: ./src/clipboard.js
                function clipboard_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { clipboard_typeof = function _typeof(obj) { return typeof obj; }; } else { clipboard_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return clipboard_typeof(obj); }

                function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

                function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

                function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

                function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

                function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

                function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

                function _possibleConstructorReturn(self, call) { if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

                function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

                function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

                function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }






                /**
                 * Helper function to retrieve attribute value.
                 * @param {String} suffix
                 * @param {Element} element
                 */

                function getAttributeValue(suffix, element) {
                    var attribute = "data-clipboard-".concat(suffix);

                    if (!element.hasAttribute(attribute)) {
                        return;
                    }

                    return element.getAttribute(attribute);
                }
                /**
                 * Base class which takes one or more elements, adds event listeners to them,
                 * and instantiates a new `ClipboardAction` on each click.
                 */


                var Clipboard = /*#__PURE__*/function (_Emitter) {
                    _inherits(Clipboard, _Emitter);

                    var _super = _createSuper(Clipboard);

                    /**
                     * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
                     * @param {Object} options
                     */
                    function Clipboard(trigger, options) {
                        var _this;

                        _classCallCheck(this, Clipboard);

                        _this = _super.call(this);

                        _this.resolveOptions(options);

                        _this.listenClick(trigger);

                        return _this;
                    }
                    /**
                     * Defines if attributes would be resolved using internal setter functions
                     * or custom functions that were passed in the constructor.
                     * @param {Object} options
                     */


                    _createClass(Clipboard, [{
                        key: "resolveOptions",
                        value: function resolveOptions() {
                            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                            this.action = typeof options.action === 'function' ? options.action : this.defaultAction;
                            this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;
                            this.text = typeof options.text === 'function' ? options.text : this.defaultText;
                            this.container = clipboard_typeof(options.container) === 'object' ? options.container : document.body;
                        }
                        /**
                         * Adds a click event listener to the passed trigger.
                         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
                         */

                    }, {
                        key: "listenClick",
                        value: function listenClick(trigger) {
                            var _this2 = this;

                            this.listener = listen_default()(trigger, 'click', function (e) {
                                return _this2.onClick(e);
                            });
                        }
                        /**
                         * Defines a new `ClipboardAction` on each click event.
                         * @param {Event} e
                         */

                    }, {
                        key: "onClick",
                        value: function onClick(e) {
                            var trigger = e.delegateTarget || e.currentTarget;
                            var action = this.action(trigger) || 'copy';
                            var text = actions_default({
                                action: action,
                                container: this.container,
                                target: this.target(trigger),
                                text: this.text(trigger)
                            }); // Fires an event based on the copy operation result.

                            this.emit(text ? 'success' : 'error', {
                                action: action,
                                text: text,
                                trigger: trigger,
                                clearSelection: function clearSelection() {
                                    if (trigger) {
                                        trigger.focus();
                                    }

                                    document.activeElement.blur();
                                    window.getSelection().removeAllRanges();
                                }
                            });
                        }
                        /**
                         * Default `action` lookup function.
                         * @param {Element} trigger
                         */

                    }, {
                        key: "defaultAction",
                        value: function defaultAction(trigger) {
                            return getAttributeValue('action', trigger);
                        }
                        /**
                         * Default `target` lookup function.
                         * @param {Element} trigger
                         */

                    }, {
                        key: "defaultTarget",
                        value: function defaultTarget(trigger) {
                            var selector = getAttributeValue('target', trigger);

                            if (selector) {
                                return document.querySelector(selector);
                            }
                        }
                        /**
                         * Allow fire programmatically a copy action
                         * @param {String|HTMLElement} target
                         * @param {Object} options
                         * @returns Text copied.
                         */

                    }, {
                        key: "defaultText",

                        /**
                         * Default `text` lookup function.
                         * @param {Element} trigger
                         */
                        value: function defaultText(trigger) {
                            return getAttributeValue('text', trigger);
                        }
                        /**
                         * Destroy lifecycle.
                         */

                    }, {
                        key: "destroy",
                        value: function destroy() {
                            this.listener.destroy();
                        }
                    }], [{
                        key: "copy",
                        value: function copy(target) {
                            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                                container: document.body
                            };
                            return actions_copy(target, options);
                        }
                        /**
                         * Allow fire programmatically a cut action
                         * @param {String|HTMLElement} target
                         * @returns Text cutted.
                         */

                    }, {
                        key: "cut",
                        value: function cut(target) {
                            return actions_cut(target);
                        }
                        /**
                         * Returns the support of the given action, or all actions if no action is
                         * given.
                         * @param {String} [action]
                         */

                    }, {
                        key: "isSupported",
                        value: function isSupported() {
                            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];
                            var actions = typeof action === 'string' ? [action] : action;
                            var support = !!document.queryCommandSupported;
                            actions.forEach(function (action) {
                                support = support && !!document.queryCommandSupported(action);
                            });
                            return support;
                        }
                    }]);

                    return Clipboard;
                }((tiny_emitter_default()));

                /* harmony default export */ var clipboard = (Clipboard);

                /***/ }),

            /***/ 828:
            /***/ (function(module) {

                var DOCUMENT_NODE_TYPE = 9;

                /**
                 * A polyfill for Element.matches()
                 */
                if (typeof Element !== 'undefined' && !Element.prototype.matches) {
                    var proto = Element.prototype;

                    proto.matches = proto.matchesSelector ||
                        proto.mozMatchesSelector ||
                        proto.msMatchesSelector ||
                        proto.oMatchesSelector ||
                        proto.webkitMatchesSelector;
                }

                /**
                 * Finds the closest parent that matches a selector.
                 *
                 * @param {Element} element
                 * @param {String} selector
                 * @return {Function}
                 */
                function closest (element, selector) {
                    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
                        if (typeof element.matches === 'function' &&
                            element.matches(selector)) {
                            return element;
                        }
                        element = element.parentNode;
                    }
                }

                module.exports = closest;


                /***/ }),

            /***/ 438:
            /***/ (function(module, __unused_webpack_exports, __webpack_require__) {

                var closest = __webpack_require__(828);

                /**
                 * Delegates event to a selector.
                 *
                 * @param {Element} element
                 * @param {String} selector
                 * @param {String} type
                 * @param {Function} callback
                 * @param {Boolean} useCapture
                 * @return {Object}
                 */
                function _delegate(element, selector, type, callback, useCapture) {
                    var listenerFn = listener.apply(this, arguments);

                    element.addEventListener(type, listenerFn, useCapture);

                    return {
                        destroy: function() {
                            element.removeEventListener(type, listenerFn, useCapture);
                        }
                    }
                }

                /**
                 * Delegates event to a selector.
                 *
                 * @param {Element|String|Array} [elements]
                 * @param {String} selector
                 * @param {String} type
                 * @param {Function} callback
                 * @param {Boolean} useCapture
                 * @return {Object}
                 */
                function delegate(elements, selector, type, callback, useCapture) {
                    // Handle the regular Element usage
                    if (typeof elements.addEventListener === 'function') {
                        return _delegate.apply(null, arguments);
                    }

                    // Handle Element-less usage, it defaults to global delegation
                    if (typeof type === 'function') {
                        // Use `document` as the first parameter, then apply arguments
                        // This is a short way to .unshift `arguments` without running into deoptimizations
                        return _delegate.bind(null, document).apply(null, arguments);
                    }

                    // Handle Selector-based usage
                    if (typeof elements === 'string') {
                        elements = document.querySelectorAll(elements);
                    }

                    // Handle Array-like based usage
                    return Array.prototype.map.call(elements, function (element) {
                        return _delegate(element, selector, type, callback, useCapture);
                    });
                }

                /**
                 * Finds closest match and invokes callback.
                 *
                 * @param {Element} element
                 * @param {String} selector
                 * @param {String} type
                 * @param {Function} callback
                 * @return {Function}
                 */
                function listener(element, selector, type, callback) {
                    return function(e) {
                        e.delegateTarget = closest(e.target, selector);

                        if (e.delegateTarget) {
                            callback.call(element, e);
                        }
                    }
                }

                module.exports = delegate;


                /***/ }),

            /***/ 879:
            /***/ (function(__unused_webpack_module, exports) {

                /**
                 * Check if argument is a HTML element.
                 *
                 * @param {Object} value
                 * @return {Boolean}
                 */
                exports.node = function(value) {
                    return value !== undefined
                        && value instanceof HTMLElement
                        && value.nodeType === 1;
                };

                /**
                 * Check if argument is a list of HTML elements.
                 *
                 * @param {Object} value
                 * @return {Boolean}
                 */
                exports.nodeList = function(value) {
                    var type = Object.prototype.toString.call(value);

                    return value !== undefined
                        && (type === '[object NodeList]' || type === '[object HTMLCollection]')
                        && ('length' in value)
                        && (value.length === 0 || exports.node(value[0]));
                };

                /**
                 * Check if argument is a string.
                 *
                 * @param {Object} value
                 * @return {Boolean}
                 */
                exports.string = function(value) {
                    return typeof value === 'string'
                        || value instanceof String;
                };

                /**
                 * Check if argument is a function.
                 *
                 * @param {Object} value
                 * @return {Boolean}
                 */
                exports.fn = function(value) {
                    var type = Object.prototype.toString.call(value);

                    return type === '[object Function]';
                };


                /***/ }),

            /***/ 370:
            /***/ (function(module, __unused_webpack_exports, __webpack_require__) {

                var is = __webpack_require__(879);
                var delegate = __webpack_require__(438);

                /**
                 * Validates all params and calls the right
                 * listener function based on its target type.
                 *
                 * @param {String|HTMLElement|HTMLCollection|NodeList} target
                 * @param {String} type
                 * @param {Function} callback
                 * @return {Object}
                 */
                function listen(target, type, callback) {
                    if (!target && !type && !callback) {
                        throw new Error('Missing required arguments');
                    }

                    if (!is.string(type)) {
                        throw new TypeError('Second argument must be a String');
                    }

                    if (!is.fn(callback)) {
                        throw new TypeError('Third argument must be a Function');
                    }

                    if (is.node(target)) {
                        return listenNode(target, type, callback);
                    }
                    else if (is.nodeList(target)) {
                        return listenNodeList(target, type, callback);
                    }
                    else if (is.string(target)) {
                        return listenSelector(target, type, callback);
                    }
                    else {
                        throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');
                    }
                }

                /**
                 * Adds an event listener to a HTML element
                 * and returns a remove listener function.
                 *
                 * @param {HTMLElement} node
                 * @param {String} type
                 * @param {Function} callback
                 * @return {Object}
                 */
                function listenNode(node, type, callback) {
                    node.addEventListener(type, callback);

                    return {
                        destroy: function() {
                            node.removeEventListener(type, callback);
                        }
                    }
                }

                /**
                 * Add an event listener to a list of HTML elements
                 * and returns a remove listener function.
                 *
                 * @param {NodeList|HTMLCollection} nodeList
                 * @param {String} type
                 * @param {Function} callback
                 * @return {Object}
                 */
                function listenNodeList(nodeList, type, callback) {
                    Array.prototype.forEach.call(nodeList, function(node) {
                        node.addEventListener(type, callback);
                    });

                    return {
                        destroy: function() {
                            Array.prototype.forEach.call(nodeList, function(node) {
                                node.removeEventListener(type, callback);
                            });
                        }
                    }
                }

                /**
                 * Add an event listener to a selector
                 * and returns a remove listener function.
                 *
                 * @param {String} selector
                 * @param {String} type
                 * @param {Function} callback
                 * @return {Object}
                 */
                function listenSelector(selector, type, callback) {
                    return delegate(document.body, selector, type, callback);
                }

                module.exports = listen;


                /***/ }),

            /***/ 817:
            /***/ (function(module) {

                function select(element) {
                    var selectedText;

                    if (element.nodeName === 'SELECT') {
                        element.focus();

                        selectedText = element.value;
                    }
                    else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
                        var isReadOnly = element.hasAttribute('readonly');

                        if (!isReadOnly) {
                            element.setAttribute('readonly', '');
                        }

                        element.select();
                        element.setSelectionRange(0, element.value.length);

                        if (!isReadOnly) {
                            element.removeAttribute('readonly');
                        }

                        selectedText = element.value;
                    }
                    else {
                        if (element.hasAttribute('contenteditable')) {
                            element.focus();
                        }

                        var selection = window.getSelection();
                        var range = document.createRange();

                        range.selectNodeContents(element);
                        selection.removeAllRanges();
                        selection.addRange(range);

                        selectedText = selection.toString();
                    }

                    return selectedText;
                }

                module.exports = select;


                /***/ }),

            /***/ 279:
            /***/ (function(module) {

                function E () {
                    // Keep this empty so it's easier to inherit from
                    // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
                }

                E.prototype = {
                    on: function (name, callback, ctx) {
                        var e = this.e || (this.e = {});

                        (e[name] || (e[name] = [])).push({
                            fn: callback,
                            ctx: ctx
                        });

                        return this;
                    },

                    once: function (name, callback, ctx) {
                        var self = this;
                        function listener () {
                            self.off(name, listener);
                            callback.apply(ctx, arguments);
                        };

                        listener._ = callback
                        return this.on(name, listener, ctx);
                    },

                    emit: function (name) {
                        var data = [].slice.call(arguments, 1);
                        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
                        var i = 0;
                        var len = evtArr.length;

                        for (i; i < len; i++) {
                            evtArr[i].fn.apply(evtArr[i].ctx, data);
                        }

                        return this;
                    },

                    off: function (name, callback) {
                        var e = this.e || (this.e = {});
                        var evts = e[name];
                        var liveEvents = [];

                        if (evts && callback) {
                            for (var i = 0, len = evts.length; i < len; i++) {
                                if (evts[i].fn !== callback && evts[i].fn._ !== callback)
                                    liveEvents.push(evts[i]);
                            }
                        }

                        // Remove event from queue to prevent memory leak
                        // Suggested by https://github.com/lazd
                        // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

                        (liveEvents.length)
                            ? e[name] = liveEvents
                            : delete e[name];

                        return this;
                    }
                };

                module.exports = E;
                module.exports.TinyEmitter = E;


                /***/ })

            /******/ 	});
        /************************************************************************/
        /******/ 	// The module cache
        /******/ 	var __webpack_module_cache__ = {};
        /******/
        /******/ 	// The require function
        /******/ 	function __webpack_require__(moduleId) {
            /******/ 		// Check if module is in cache
            /******/ 		if(__webpack_module_cache__[moduleId]) {
                /******/ 			return __webpack_module_cache__[moduleId].exports;
                /******/ 		}
            /******/ 		// Create a new module (and put it into the cache)
            /******/ 		var module = __webpack_module_cache__[moduleId] = {
                /******/ 			// no module.id needed
                /******/ 			// no module.loaded needed
                /******/ 			exports: {}
                /******/ 		};
            /******/
            /******/ 		// Execute the module function
            /******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
            /******/
            /******/ 		// Return the exports of the module
            /******/ 		return module.exports;
            /******/ 	}
        /******/
        /************************************************************************/
        /******/ 	/* webpack/runtime/compat get default export */
        /******/ 	!function() {
            /******/ 		// getDefaultExport function for compatibility with non-harmony modules
            /******/ 		__webpack_require__.n = function(module) {
                /******/ 			var getter = module && module.__esModule ?
                    /******/ 				function() { return module['default']; } :
                    /******/ 				function() { return module; };
                /******/ 			__webpack_require__.d(getter, { a: getter });
                /******/ 			return getter;
                /******/ 		};
            /******/ 	}();
        /******/
        /******/ 	/* webpack/runtime/define property getters */
        /******/ 	!function() {
            /******/ 		// define getter functions for harmony exports
            /******/ 		__webpack_require__.d = function(exports, definition) {
                /******/ 			for(var key in definition) {
                    /******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                        /******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
                        /******/ 				}
                    /******/ 			}
                /******/ 		};
            /******/ 	}();
        /******/
        /******/ 	/* webpack/runtime/hasOwnProperty shorthand */
        /******/ 	!function() {
            /******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
            /******/ 	}();
        /******/
        /************************************************************************/
        /******/ 	// module exports must be returned from runtime so entry inlining is disabled
        /******/ 	// startup
        /******/ 	// Load entry module and return exports
        /******/ 	return __webpack_require__(686);
        /******/ })()
        .default;
});

// ---------- 自定义内容 ---------- //

/* 获取本页链接地址（不包含参数） */
function getNowURL() {
    return location.protocol + '//' + location.host + location.pathname
}

const clipboard = new ClipboardJS('button#share-link', {
    text: function () {
        return document.title + '：' + getNowURL()
    },
});
clipboard.on('success', function () {
    if (GLOBAL_CONFIG.Snackbar) {
        btf.snackbarShow(GLOBAL_CONFIG.copy.success)
    } else {
        console.log("复制成功")
    }
});
clipboard.on('error', function () {
    if (GLOBAL_CONFIG.Snackbar) {
        btf.snackbarShow(GLOBAL_CONFIG.copy.error)
    } else {
        console.error("复制失败")
    }
});
```

&emsp;&emsp;然后在配置文件中引入JS：

```diff
  inject:
    bottom:
+     - <script async src="/js/custom/share.js"></script>
```

---

## 原理介绍

### 向剪切板添加数据

&emsp;&emsp;想要向剪切板添加数据有多种办法，我们这里不再多说，只说一下今天的主角：`clipboard`。

&emsp;&emsp;第一步肯定是引入`clipboard`的JS啦，`clipboard`官方已经给出了[几个常用的CDN](https://github.com/zenorocha/clipboard.js/wiki/CDN-Providers)。

&emsp;&emsp;然后，我们需要给`clipboard`绑定一个页面元素，用来让`clipboard`添加鼠标点击的监视。是的，我们不需要手动添加鼠标监视然后调用`clipboard`的方法，我们只需要把这些事情统统交给`clipboard`就可以了。

&emsp;&emsp;现在我们创建一个按钮：

```html
<div class="名称" title="鼠标悬浮描述">
    <i class="fas fa-link"></i>
</div>
```

&emsp;&emsp;然后通过JS调用`clipboard`，构造函数的第一个参数就是要监视的元素的名称：

```javascript
new ClipboardJS('这里写按钮的类名', {
    text: function () {
        return "这里写要复制的内容"
    }
});
```

&emsp;&emsp;调用`clipboard`方法有很多，我们只说明这一种方法，具体用法自行查看[官方文档](https://clipboardjs.com/)。

### 弹窗提醒

&emsp;&emsp;现在我们想要在复制成功/失败的时候弹窗提醒用户，这时候就用到了`clipboard`提供的两个事件：

```javascript
clipboard.on('success', function () {
    /* 复制成功时触发 */
});
clipboard.on('error', function () {
    /* 复制失败时触发 */
});
```

&emsp;&emsp;对于`butterfly`主题，我们可以使用`btf.snackbarShow("text")`来弹出提示框。

## Ajax适配

&emsp;&emsp;如果你是完全按照我的方法走的，就没有与`ajax`的兼容问题，但是如果你用其它方法引入JS并且你开启了`ajax`，那么请务必注意与`ajax`的兼容问题。

## 参考

{% link 一个更实用的分享按钮 by Gahotx, https://gahotx.cn/posts/df00fa42.html, https://pub.gahotx.cn/photo/cat.jpg %}
---
title: 浮点数的二进制表示
top_img: false
categories:
  - 通用
tags:
  - 教程
  - 进制
cover: 'https://image.kmar.top/bg/b13.jpg!/fw/700'
description: 简单描述IEEE754标准的浮点数的二进制表示方式
abbrlink: 6f78f1ee
date: 2021-10-20 21:42:32
updated: 2022-4-28 23:32:20
---

{% p blue center, 注意：阅读本文前请务必了解基本的二进制知识，详情可见：<a href="https://kmar.top/posts/2e876344/">《二进制运算从入门到入坟》</a> %}

{% p center, <b>如果没有明确指出，本文均使用<code>double</code>作为例子</b> %}

## IEEE754

&emsp;&emsp;`IEEE 754`是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。这个标准确定了以下内容：

<ul>
    <li>标准化正浮点数和负浮点数</li>
    <li>如何表示正负非规范化浮点数</li>
    <li>如何表示0</li>
    <li>如何表示无穷数（Infiniti）</li>
    <li>四种数值舍入规则</li>
</ul>

&emsp;&emsp;同时`IEEE 754`还定义了四种浮点数格式：

<ul>
    <li>32位单精度(float)</li>
    <li>64位双精度(double)</li>
    <li>(>= 43)位单扩展精度</li>
    <li>(>= 79)位双扩展精度（一般用80位）</li>
</ul>

&emsp;&emsp;因为后两种格式并不常用，所以这里只说前两种`float`和`double`。

## 小数的二进制表示

&emsp;&emsp;我们先来了解小数的二进制表示。现在我们将一个十进制小数：`5.8125`转换为二进制：

&emsp;&emsp;第一步：先将整数部分转换为二进制`101`

&emsp;&emsp;第二步：将小数部分转换为二进制，方法为将小数部分乘以2取整，直至变为1

```
0.8125 * 2 = 1.6250 ------ 取 1
0.6250 * 2 = 1.2500 ------ 取 1
0.2500 * 2 = 0.5000 ------ 取 0
0.5000 * 2 = 1.0000 ------ 取 1
------------------------------
最终结果为：1101
```

&emsp;&emsp;第三步：得出答案`101.1101`

## 二进制科学计数法

&emsp;&emsp;我们在小学时期就接触过“科学计数法”，即`1.x * 10^b`。这种方式就是十进制的科学计数法，为了了解浮点数的二进制表示方法，我们必须先知道二进制的科学计数法。

&emsp;&emsp;比如我们要用科学计数法表示`105`，十进制的表示方式为`1.05 * 10^2`。想用二进制表示的话需要先将`105`转换为二进制`1101001`，这时我们可以知道其科学计数法的表示为`1.101001 * 2^6`。（注：这里没有把指数换成二进制）

&emsp;&emsp;正如十进制的科学计数法中要求整数位在区间`(0, 10)`内一样，二进制的科学计数法要求整数位在`(0, 2)`内，也就是说只能为`1`。

## 浮点数内存分配

|      总长度      | S-符号位(bit) | E-偏移指数位(bit) | M-尾数位(bit) |
|:-------------:|:----------:|:------------:|:----------:|
| 32bit(float)  |     1      |      8       |     23     |
| 64bit(double) |     1      |      11      |     52     |

&emsp;&emsp;存储形式见下图：

![浮点数内存结构示意图](https://image.kmar.top/posts/fdsdejzbs-0.jpg)

### 符号位

&emsp;&emsp;符号位很简单，`0`表示正数，`1`表示负数。

### 指数位

&emsp;&emsp;我们用`e`来表示指数，比如<code>8.1357 * 10<sup>9</sup></code>，这里`e = 9`。

&emsp;&emsp;指数位并没有直接存储指数`e`，而是存储了偏移后的指数`E`。

#### 关系式

&emsp;&emsp;我们假定`b`表示偏移量，则有如下关系式：`E = e + b`。

#### 偏移量表

|  长度(bit)   |  偏移量b(十进制\[二进制\])  |
|:----------:|:------------------:|
| 32(float)  |   127\[1111111\]   |
| 64(double) | 1023\[1111111111\] |

&emsp;&emsp;观察可以发现，偏移量的二进制表达式所有位均为`1`，位数为`指数位长度 - 1`，通过这个规律我们便可以求得偏移量的具体值。

#### 为什么存储偏移量

&emsp;&emsp;存储`E`而不直接存储指数原本的值`e`是为了简化运算。

&emsp;&emsp;可以很明显的发现，一个浮点数需要两个符号位，一个用来标明整个数字的正负，另一个用来标明指数的正负。

&emsp;&emsp;但是如果指数位上也存储一个符号位的话在进行浮点运算的时候就会变得非常复杂，所以为了简便起见，我们选择将所有指数加上一个特定的值，使所有指数都偏移成正数，这样就不用再区分正负了。

#### 两个特殊值

&emsp;&emsp;`double`的指数位有11位，可以表示`[0, 2047]`的数字，但是标准排除了最小值和最大值两个数字，所以指数表示的范围最终为`[1, 2046]`，被排除的两个数字用来表示特殊的数据，后面会详细描述。

### 尾数位

&emsp;&emsp;尾数位存储的内容是二进制科学计数法前方的数字，假如我们要存储`5.8125`：

&emsp;&emsp;我们首先要将`5.8125`转化为二进制，即`101.1101`，然后将小数点左移，变成`1.011101 * 2^2`。

&emsp;&emsp;所以，尾数位要存储的数字便是：`1.011101`。

&emsp;&emsp;我们可以注意到，尾数的整数部分一定为`1`，那么整数部分我们完全可以不进行存储，只存储小数部分即可（这里就是只存了`011101`），所以虽然`double`的尾数为只有52位，实际上却存储了53位的数据。

&emsp;&emsp;如果尾数长度小于最大尾数长度，则在尾数后面补`0`。

### 示例

&emsp;&emsp;`5.8125`的`float`二进制表示为：`0_10000001_01110100000000000000000`。

+ 首位为符号位，表示这是一个正数
+ 后面跟着的八位`10000001`转换为十进制是`129`，减去`127`等于`2`，也就是`e = 2`
+ 最后面剩余位表示的是`.011101`，整数位补`1`就是`1.011101`，再把小数点向右移动`e`位就是`101.1101`
+ `101.1101`转换为十进制就是`5.8125`

## 零的表示方法

&emsp;&emsp;看了上面的内容，细心的读者可能会发现一个问题，这种表示方式如何表示`0`？因为尾数永远是`1.*`，所以常规表示方式永远也不可能表示出`0`这个数，最多尽量接近`0`。这时候上文提到的两个特殊值中的一个便派上了用场。当指数位和尾数位全部为`0`时表示该数为`0`，即`0`的二进制表达式为（float）`0_00000000_00000000000000000000000`（符号位可以为`1`）。

## 非规约数

&emsp;&emsp;如果浮点数的指数部分的编码值是`0`，分数部分非零，那么这个浮点数将被称为**非规约形式的浮点数**。一般是某个数字**相当**接近零时才会使用非规约型式来表示。

&emsp;&emsp;`IEEE 754`标准规定：**非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1**。例如，最小的规约形式的单精度浮点数的指数部分编码值为`1`，指数的实际值为`-126`；而非规约的单精度浮点数的指数域编码值为`0`，对应的指数实际值也是`-126`而不是`-127`。

&emsp;&emsp;实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有规约浮点数的绝对值；即非规约浮点数比任何规约浮点数更接近`0`。因为规约浮点数的尾数大于等于`1`且小于`2`，而非规约浮点数的尾数小于`1`且大于`0`。

## 无穷大的表示方法

&emsp;&emsp;现在还有一个特殊值没有用到，即指数为`2047`的情况。规范规定，当指数位全部为`1`并且尾数位全部为`0`时表示该数是一个无穷数，根据符号位的不同分为正无穷和负无穷。

## NaN

&emsp;&emsp;`NaN`的全拼是“Not a Number”，顾名思义，其表示这不是一个有效的数字。指数位全为`1`但尾数位不全为`0`的数字均为`NaN`，可以看出`NaN`有许多表达式。在一个`NaN`与其它数字（包括`NaN`）判断是否相等时一定返回`false`，同时因为`NaN`内部是有值的，只是其不能正确地表示数字，所以其并不是一个空值，也不能使用空值来判断其是否为`NaN`。

&emsp;&emsp;为此，在`math.h`中定义了一个函数`isnan(x)`，该函数用于判断数字是否为NaN。还有一个于其对应的函数`isnormal(x)`，该函数用于判断数字是否为一个正常的数字，当数字为`0`、无穷数、NaN时会返回`false`，否则返回`true`。

---

## 参考资料

+ [IEEE 754 - Standard binary floating point arithmetic](http://www.softelectro.ru/ieee754_en.html)
+ [CSDN - 理解浮点数的二进制表示](https://blog.csdn.net/S_o_l_o_n/article/details/106438708)
+ [百度百科](https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin)
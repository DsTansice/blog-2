---
title: 浮点数的二进制表示
date: 2021-10-20 21:42:32
top_img: false
categories:
  - 通用
tags:
  - 教程
  - 进制
cover: https://image.emptydreams.xyz/bg/b13.jpg!/fxfn2/550x500
description: 简单描述IEEE754标准的浮点数的二进制表示方式
---

**注意：阅读本文前请务必了解基本的二进制知识，详情可见：[二进制运算从入门到入坟](https://blog.emptydreams.xyz/binary/)。**

**&emsp;&emsp;&emsp;如果没有明确指出，本文均使用`double`作为例子**

# IEEE754

&emsp;&emsp;`IEEE 754`是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。这个标准确定了以下内容：

<ul>
    <li>标准化正浮点数和负浮点数</li>
    <li>如何表示正负非规范化浮点数</li>
    <li>如何表示0</li>
    <li>如何表示无穷数（Infiniti）</li>
    <li>四种数值舍入规则</li>
</ul>

&emsp;&emsp;同时`IEEE 754`还定义了四种浮点数格式：

<ul>
    <li>32位单精度(float)</li>
    <li>64位双精度(double)</li>
    <li>(>= 43)位单扩展精度</li>
    <li>(>= 79)位双扩展精度（一般用80位）</li>
</ul>

&emsp;&emsp;因为后两种格式并不常用，所以这里只说前两种`float`和`double`。

# 小数的二进制表示

&emsp;&emsp;我们先来了解小数的二进制表示。现在我们将一个十进制小数：`5.8125`转换为二进制：

&emsp;&emsp;第一步：先将整数部分转换为二进制`101`

&emsp;&emsp;第二步：将小数部分转换为二进制，方法为将小数部分乘以2取整，直至变为1

```
0.8125 * 2 = 1.6250 ------ 取 1
0.6250 * 2 = 1.2500 ------ 取 1
0.2500 * 2 = 0.5000 ------ 取 0
0.5000 * 2 = 1.0000 ------ 取 1
最终结果为：1101
```

&emsp;&emsp;第三步：得出答案`101.1101`

# 二进制科学计数法

&emsp;&emsp;我们在小学时期就接触过“科学计数法”，即1.x * 10^b。这种方式就是十进制的科学计数法，为了了解浮点数的二进制表示方法，我们必须先知道二进制的科学计数法。

&emsp;&emsp;比如我们要用科学计数法表示`105`，十进制的表示方式为`1.05 * 10^2`。想用二进制表示的话需要先将`105`转换为二进制`1101001`，这时我们可以知道其科学计数法的表示为`1.101001 * 2^6`。（注：这里没有把指数换成二进制）

# 浮点数内存分配

|    总长度     | S-符号位(bit) | E-偏移指数位(bit) | M-尾数位(bit) |
| :-----------: | :-----------: | :---------------: | :-----------: |
| 32bit(folat)  |       1       |         8         |      23       |
| 64bit(double) |       1       |        11         |      52       |

&emsp;&emsp;存储形式见下图：

![浮点数内存结构示意图](https://image.emptydreams.xyz/float/ieee754_1.jpg)

## 符号位

&emsp;&emsp;符号位很简单，`0`表示正数，`1`表示负数。

## 指数位

&emsp;&emsp;指数位并没有直接存储指数`e`，而是存储了偏移后的指数`E`。

### 关系式

&emsp;&emsp;我们假定`b`表示偏移量，则有如下关系式：`E = e + b`。

### 偏移量表

| 长度(bit)  | 偏移量b(十进制 - 二进制) |
| :--------: | :----------------------: |
| 32(float)  |      127 - 1111111       |
| 64(double) |    1023 - 1111111111     |

### 如何求得偏移量

&emsp;&emsp;观察可以发现，偏移量的二进制表达式所有位均为`1`，位数为`指数位长度 - 1`，通过这个规律我们便可以求得偏移量的具体值。

### 为什么存储偏移量

&emsp;&emsp;我们很简单就能发现，如果使用补码表示指数，在比较浮点数大小的时候会变得很复杂，举个栗子：

```
假设数据共4bit
比较 -8 和 7
-8 的补码为 1000 | 7 的补码为 0111
如果直接通过比较就会得到 1000 > 0111
这显然是不合理的
```

&emsp;&emsp;所以这里把负数全部转换为正数进行存储，在运算的时候比较浮点数大小也变得更加简单。

### 两个特殊值

&emsp;&emsp;`double`的指数位有11位，可以表示`[0, 2047]`的数字，但是标准排除了最小值和最大值两个数字，所以指数表示的范围最终为`[1, 2046]`，被排除的两个数字用来表示特殊的数据，后面会详细描述。

## 尾数位

&emsp;&emsp;尾数位存储的内容是二进制科学计数法前方的数字，假如我们要存储`5.8125`，那么尾数就是`1.101001`。我们可以注意到，尾数的整数部分一定为`1`，所以整数部分不再存储，只存储小数部分即可，所以虽然`double`的尾数为只有52位，实际上却存储了53位的数据。

&emsp;&emsp;如果尾数长度不足最大尾数，则在尾数后面补`0`。

## 示例

&emsp;&emsp;`5.8125`的`double`二进制表示为：`0_10000000_10100100000000000000000`。

# 零的表示方法

&emsp;&emsp;看了上面的内容，细心的读者可能会发现一个问题，这种表示方式如何表示`0`？因为尾数永远是`1.*`，所以常规表示方式永远也不可能表示出`0`这个数，最多尽量接近`0`。这时候上文提到的两个特殊值中的一个便派上了用场。当指数位和尾数位全部为`0`时表示该数为`0`，即`0`的二进制表达式为（float）`0_00000000_00000000000000000000000`（符号位可以为`1`）。

# 非规约数

&emsp;&emsp;如果浮点数的指数部分的编码值是`0`，分数部分非零，那么这个浮点数将被称为**非规约形式的浮点数**。一般是某个数字**相当**接近零时才会使用非规约型式来表示。 `IEEE 754`标准规定：**非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1**。例如，最小的规约形式的单精度浮点数的指数部分编码值为`1`，指数的实际值为`-126`；而非规约的单精度浮点数的指数域编码值为`0`，对应的指数实际值也是`-126`而不是`-127`。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近`0`。规约浮点数的尾数大于等于`1`且小于`2`，而非规约浮点数的尾数小于`1`且大于`0`。

# 无穷大的表示方法

&emsp;&emsp;现在还有一个特殊值没有用到，即指数为`2047`的情况。规范规定，当指数位全部为`1`并且尾数位全部为`0`时表示该数是一个无穷数，根据符号位的不同分为正无穷和负无穷。

# NaN

&emsp;&emsp;`NaN`的全拼是“Not a Number”，顾名思义，其表示这不是一个有效的数字。指数位全为`1`但尾数位不全为`0`的数字均为`NaN`，可以看出`NaN`有许多表达式。在一个`NaN`与其它数字（包括`NaN`）判断是否相等时一定返回`false`，同时因为`NaN`内部是有值的，只是其不能正确的表示数字，所以其并不是一个空值，也不能使用空值来判断其是否为`NaN`。

&emsp;&emsp;为此，在`math.h`中定义了一个函数`isnan(x)`，该函数用于判断数字是否为NaN。还有一个于其对应的函数`isnormal(x)`，该函数用于判断数字是否为一个正常的数字，当数字为`0`、无穷数、NaN时会返回`false`，否则返回`true`。

---

# 参考资料

>[IEEE 754 - Standard binary floating point arithmetic](http://www.softelectro.ru/ieee754_en.html)
>
>[CSDN - 理解浮点数的二进制表示](https://blog.csdn.net/S_o_l_o_n/article/details/106438708)
>
>[百度百科]([IEEE 754_百度百科 (baidu.com)](https://baike.baidu.com/item/IEEE 754/3869922?fr=aladdin))

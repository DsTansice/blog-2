---
title: 二进制运算从入门到入坟
date: 2021-09-16 17:36:23
categories:
  - 通用
tags:
  - 教程
cover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b7.jpeg
description: 被二进制秀的团团转？来这里寻找二进制的本质。
---

# 什么是二进制

&emsp;&emsp;在了解二进制前我们要了解“进制”这个概念。进制是进位计数制的一个概念，“N进制”即代表遇到`N`就向前进一位。我们日常中使用的数字通常是十进制数，即逢十进一。通过这个概念以此类推，我们便能得到二进制、三进制……直到N进制。所以说不同进制之间的区别便是一位数上的最大值不同，是对同一个数字的不同表示方式，并且进制并不只有2、8、10、16四种，只是这四种比较常用而已。

&emsp;&emsp;而二进制便是现代计算机中普遍应用的一种进制，原因便是二进制每一位上只有两个数：0或1，这使得二进制数在物理层面上更容易表达以及运算，也为电路中的逻辑运算提供了便利。

# 进制的转换

&emsp;&emsp;初中的时候我们便学习过二进制与十进制的互换。

&emsp;&emsp;十进制转换为二进制的方法称为除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。

&emsp;&emsp;如图所示，十进制的`500`转换为二进制后就变为了`111110100(2)`。十进制转换为其他进制将除数`2`换成其他进制的值即可。

![十进制转二进制图解](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/binary/10t2.jpg)

&emsp;&emsp;二进制转换为十进制则是二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。

&emsp;&emsp;比如：

```
111110100(2) -> 500(10)
数字：     1       1       1       1       1       0       1       0       0
下标：     8       7       6       5       4       3       2       1       0
计算：   2^8*1 + 2^7*1 + 2^6*1 + 2^5*1 + 2^4*1 + 2^3*0 + 2^2*1 + 2^1*0 + 2^0*0
      =  256  +  128  +   64  +   32  +   16  +   0   +   4   +   0   +   0
      =  500
```

&emsp;&emsp;其他进制转换为十进制的方法与二进制转十进制类似，只不过将`2^n*m`中的`2`换成对应的进制值就可以了。

# 不同进制在代码中的表示方法

<ul>
    <li>二进制：0b*****（例如：0b11001001 -> 201(10)）</li>
    <li>八进制：0******（例如：0757 -> 495(10)）</li>
    <li>十进制：*******（例如：551）</li>
    <li>十六进制：0x***（例如：0xaf58 -> 44888(10)）</li>
</ul>

# 数字运算

&emsp;&emsp;所有进制的运算依然符合小学所学的十进制运算方法，直接套用即可。

# 数字的二进制表示

## 表示规则

&emsp;&emsp;每一个二进制数被称为一位，这个数字有几个二进制数就占用几位。同时二进制数的最左端为最高位，最右端为最低位，即从右往左数，第一个数下标最小（0）。

&emsp;&emsp;二进制中正负数是怎么区分的呢？重点就在最高位上，当最高位为0时表示这是一个正数，当最高位为1时表示这是一个负数。当然也有例外，就是`unsigned ?`型的数据，这种数据不把最高位当作正负号的判定，而是将其也用来存储数字，这样做将数据的表示范围扩大了2倍，但同时也丧失了表示负数的能力。

## 原码

&emsp;&emsp;顾名思义，原码就是数字原本的码值，任何数的原码就是其本身。

## 反码

&emsp;&emsp;反码比原码复杂一点，正数的反码是它本身，而负数的反码则是将除最高位的数外其它所有数反转，即0变成1，1变成0。比如：`0b10111`的反码便是`0b11000`

## 补码

&emsp;&emsp;补码是在反码的基础上得来的，这里正数依旧延续传统，其补码仍是其本身。

### 负数的补码

&emsp;&emsp;负数的补码有很多种求法，这里列出两种：

&emsp;&emsp;1.尾数的第一个‘1’及其右边的‘0’保持不变，左边的各位按位取反，符号位不变。例如：`0b111010`变成反码就是从右往左数第一个1以及其右边的0和符号位保持不变，其它位单独求反，就变成了`0b100110`。

&emsp;&emsp;2.将负数的反码+1。例如：`0b111010`的反码是`0b100101`，加一就变成了`0b100110`。

&emsp;&emsp;为什么这里要列出两个方法呢？因为第二个方法在网上广为流传，甚至被误认为其就是补码的定义，其实这只不过是补码凑巧等于反码+1而非因为反码+1是补码。如果你有兴趣了解这方面的知识，可以阅读《计算机组成原理》，其中更为详细且严谨的方式解释补码。

# 位运算

## 和（二元）

&emsp;&emsp;和运算规则中，同为`1`返回`1`，否则返回`0`。例如`0b1101 & 0b1010 = 0b1000。`

## 或（二元）

&emsp;&emsp;或运算规则中，同为`0`返回`0`，否则返回`1`。例如`0b1101 | 0b1010 = 0b1111。`

## 非（一元）

&emsp;&emsp;非运算规则中，`0`变`1`，`1`变`0`。例如：`~0b1010 = 0b0101。`

&emsp;&emsp;这里注意，布尔类型和数字类型的非运算符号不一样，布尔类型是`!`，数字类型是`~`。

## 异或（二元）

&emsp;&emsp;异或运算规则中，同为`0`返回`1`，否则返回`0`，简而言之就是不进位的加法。例如：`0b1010 ^ 0b1101 = 00111`。

## 左移（二元）

&emsp;&emsp;左移运算是将二进制数所有位向左移动指定位数，空位补`0`。例如：`0b1111 << 2 = 0b[11]1100`（括号中的数是被裁掉的数）。

## 右移（二元）

&emsp;&emsp;右移运算是将二进制数所有位向右移动指定位数，正数空位补`0`，负数空位补`1`。例如：`0b01001 >> 2 = 0b00010[01]`、`0b10011 >> 2 = 0b11100[11]`（括号中的数是被裁掉的数）。

## 无符号右移（二元）

&emsp;**&emsp;无符号右移在C中并不存在，在C中对无符号数进行右移便是无符号右移！**

&emsp;&emsp;无符号右移是将二进制数所有位向右移动指定位数，与右移不同，无符号右移空位永远补`0`。例如：`0b10011 >>> 2 = 0b00100[11]`（括号中的数是被裁掉的数）。








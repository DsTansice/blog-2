{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/midesign.svg","path":"midesign.svg","modified":0,"renderable":0},{"_id":"source/logo/android-chrome-144x144.png","path":"logo/android-chrome-144x144.png","modified":0,"renderable":0},{"_id":"source/logo/android-chrome-192x192.png","path":"logo/android-chrome-192x192.png","modified":0,"renderable":0},{"_id":"source/logo/android-chrome-256x256.png","path":"logo/android-chrome-256x256.png","modified":0,"renderable":0},{"_id":"source/logo/android-chrome-36x36.png","path":"logo/android-chrome-36x36.png","modified":0,"renderable":0},{"_id":"source/logo/android-chrome-384x384.png","path":"logo/android-chrome-384x384.png","modified":0,"renderable":0},{"_id":"source/logo/android-chrome-48x48.png","path":"logo/android-chrome-48x48.png","modified":0,"renderable":0},{"_id":"source/logo/android-chrome-512x512.png","path":"logo/android-chrome-512x512.png","modified":0,"renderable":0},{"_id":"source/logo/android-chrome-72x72.png","path":"logo/android-chrome-72x72.png","modified":0,"renderable":0},{"_id":"source/logo/android-chrome-96x96.png","path":"logo/android-chrome-96x96.png","modified":0,"renderable":0},{"_id":"source/logo/apple-touch-icon.png","path":"logo/apple-touch-icon.png","modified":0,"renderable":0},{"_id":"source/logo/browserconfig.xml","path":"logo/browserconfig.xml","modified":0,"renderable":0},{"_id":"source/logo/favicon-16x16.png","path":"logo/favicon-16x16.png","modified":0,"renderable":0},{"_id":"source/logo/favicon-32x32.png","path":"logo/favicon-32x32.png","modified":0,"renderable":0},{"_id":"source/logo/favicon.ico","path":"logo/favicon.ico","modified":0,"renderable":0},{"_id":"source/logo/mstile-150x150.png","path":"logo/mstile-150x150.png","modified":0,"renderable":0},{"_id":"source/logo/safari-pinned-tab.svg","path":"logo/safari-pinned-tab.svg","modified":0,"renderable":0},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/image/bg.jpg","path":"image/bg.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/manifest.json","hash":"0a4fa428934b9a1b54221b3cc91f2d469c01344a","modified":1632710984017},{"_id":"source/_data/link.yml","hash":"b87fe6cbd81ed549cb7ce7db37a007f5966ab350","modified":1634022353900},{"_id":"source/admin/config.yml","hash":"5e1a62dbfc845513b68324b2bcaf3add2a4e6898","modified":1632575909580},{"_id":"source/admin/index.html","hash":"57ae92c9c405f0afce3ff51f9dbd16678575dde8","modified":1632575909581},{"_id":"source/_posts/LocalInnerClass.md","hash":"580891220032025e3276f64ae1614ef0950642ba","modified":1632748681547},{"_id":"source/_posts/ReviewOfDevelopmentGuide.md","hash":"ee7ad57582062109853c834215ea96708ea29acd","modified":1632748690413},{"_id":"source/_posts/binary.md","hash":"f347459cc5fb706d7bc6639fb48d5aa67bb1b358","modified":1634738934578},{"_id":"source/_posts/bugfix.md","hash":"ef2b5f7d54cd835deedfaf9cc6a1c3c3673f4f8b","modified":1632748712888},{"_id":"source/_posts/c_standard.md","hash":"05870537eab376f7992fd6b894b0611d6f1301d4","modified":1634040949524},{"_id":"source/_posts/dlog.md","hash":"af8cc6216608b57735566e27a64ccd15b0d20c93","modified":1632749854678},{"_id":"source/_posts/operation.md","hash":"b7fb6539928377124f8ceaa08f9d01ff59108d14","modified":1632748683706},{"_id":"source/_posts/py.md","hash":"6139e3c767ca7dc343779d3d954d4000591eeafc","modified":1632749822797},{"_id":"source/_posts/zzzzzz_create.bat","hash":"36efaf2c6e54afea0e76466263e1d4b46055ba73","modified":1632575909580},{"_id":"source/_posts/zzzzzz_creater.jar","hash":"fc96116a2a71373009443b4b41c86955466c344a","modified":1632575909580},{"_id":"source/link/index.md","hash":"c1263a4a8f23e81b49e24a058e36617c8030a18b","modified":1632575909581},{"_id":"source/categories/index.md","hash":"f8d0db1b505fc90d19c078ba6c05b70779a4044b","modified":1632575909581},{"_id":"source/logo/android-chrome-144x144.png","hash":"96da3eb44f070a67db36b60562fe561891679617","modified":1632658222000},{"_id":"source/logo/android-chrome-192x192.png","hash":"63776fd93c6eb9834ede9ad7f1d635ca51e33e94","modified":1632658222000},{"_id":"source/logo/android-chrome-256x256.png","hash":"c9a628ff4729a84fa2dc191f8e0c424c2ad53cdf","modified":1632658222000},{"_id":"source/logo/android-chrome-36x36.png","hash":"03946771e7405f33b3fd2981e2ec92538bd1f4ef","modified":1632658222000},{"_id":"source/logo/android-chrome-48x48.png","hash":"bc7b92b90988d43cdb32e8a02777e62b53b6f4ba","modified":1632658223000},{"_id":"source/logo/android-chrome-72x72.png","hash":"2701ee1bc7a40dd31b88bf9e4267fb8da9f8d5ac","modified":1632658223000},{"_id":"source/logo/android-chrome-96x96.png","hash":"9166a08f0cbbde60e762f65dae4cb929e065ed0a","modified":1632658223000},{"_id":"source/logo/apple-touch-icon.png","hash":"6a0f186b74746b09b1dd84b233f4cfdc3ea9bb8d","modified":1632658224000},{"_id":"source/logo/browserconfig.xml","hash":"f06c18d45fdfcd04ac1130aa5b83190c56fdf888","modified":1632658224000},{"_id":"source/logo/favicon-16x16.png","hash":"d4a7e040821dbb13b665f769c6ba2d9b61d84990","modified":1632658224000},{"_id":"source/logo/favicon-32x32.png","hash":"34b854864e41dc8f5d81b7b1fef05bb2a3d96feb","modified":1632658224000},{"_id":"source/logo/favicon.ico","hash":"6bcd7497a51d967b8e8058fc8a0a23432f8b6696","modified":1632658225000},{"_id":"source/logo/mstile-150x150.png","hash":"d8af7c30542667c4c30c304163be4ba714f567d5","modified":1632658225000},{"_id":"source/logo/safari-pinned-tab.svg","hash":"f1545a07199abf0edada346fb87905370bf3b550","modified":1632658225000},{"_id":"source/self/backgroundA.css","hash":"0ddb21c52e9c3137c4bbdf399923316675ae7fed","modified":1632801572434},{"_id":"source/self/copyright.css","hash":"6e933c6325e2c2da876e0ebe3ad7025c87cfb492","modified":1632575909582},{"_id":"source/self/font.css","hash":"fd3c6ff77656b8e6e9f1a71637a9dbc3aafab244","modified":1632659954786},{"_id":"source/self/icon.css","hash":"623c2361d47721e67e11beb0d9aed78bfe22cd68","modified":1632627975289},{"_id":"source/self/kimbie-dark.css","hash":"23547643baef1d736029944ef99a85e01a6bf552","modified":1632575909717},{"_id":"source/self/mouse.css","hash":"adb71bf2eed665dc6e6b2798dec080c482143924","modified":1632900815295},{"_id":"source/self/pageIcon.css","hash":"22041cd4fc34c0b725e1f716c6b91515b5d33992","modified":1632575909718},{"_id":"source/self/player.css","hash":"11b4822af7e192c188f9b796fd7b00c5da8bb071","modified":1632748479955},{"_id":"source/self/topFilter.css","hash":"a3dc6c967d307677619f3f642af0bce4525236ee","modified":1632575909718},{"_id":"source/tags/index.md","hash":"b6599397d78843e6e84ed88d0fbd719d0988b55e","modified":1632575909719},{"_id":"source/_posts/ReviewOfDevelopmentGuide/run.png","hash":"451ac82036768ea4959f17404cd00f6531870396","modified":1632575909578},{"_id":"source/midesign.svg","hash":"e5fa7b852cece15cbd9cabc683b35ba633ab13bb","modified":1632575909582},{"_id":"source/logo/android-chrome-384x384.png","hash":"c4929f5d8068e29f54c3b99671f1bfb7831deb43","modified":1632658222000},{"_id":"source/logo/android-chrome-512x512.png","hash":"9f336aabf616e2e17086d199b31cfa60ec110de4","modified":1632658223000},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1632575909721},{"_id":"themes/butterfly/README.md","hash":"0f0eaee9c30ef1e9aed588fbb3e8263401348b55","modified":1632575909721},{"_id":"themes/butterfly/README_CN.md","hash":"70ec43a8aa0776b5a0a2a6b6009dd253fa3679eb","modified":1632575909721},{"_id":"themes/butterfly/_config.yml","hash":"871661a1d7c92b4ffee17496c5388fb1235a6531","modified":1632575909722},{"_id":"themes/butterfly/package.json","hash":"40fd25d5ec0895596ecba874740e90167fdb0d0d","modified":1632575909747},{"_id":"themes/butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1632575909720},{"_id":"themes/butterfly/languages/default.yml","hash":"b9dbdb20bd1f1c7ca8a8f38635bdc4ed8bb1d44c","modified":1632575909722},{"_id":"themes/butterfly/languages/en.yml","hash":"fd1c1211c8f166d089a7697872185a81182d92e1","modified":1632575909722},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"05fb724f584edc47cfb8af485e35f0df93fea59d","modified":1632575909722},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"736bec8eeb3a29d0d43669d81f1fa686e02be18e","modified":1632575909723},{"_id":"themes/butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1632575909723},{"_id":"themes/butterfly/layout/category.pug","hash":"5ac3cd8172088843cec03175c612a9c85f49cf2e","modified":1632575909723},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1632575909746},{"_id":"themes/butterfly/layout/page.pug","hash":"cae76ce64c114fd192b5da5a7d14aa0240df2f06","modified":1632575909747},{"_id":"themes/butterfly/layout/post.pug","hash":"8f2f13c9ae099dd83827ce3dbac5abc8d7d5bde3","modified":1632575909747},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1632575909747},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0b7979a908ebe8c350d73b6731f0be3e29d401c2","modified":1632575909719},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1632575909720},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1632575909720},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1632575909720},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"3cdc5e32d0f1e5866bcf86f94a0d76aaf7142937","modified":1632575909723},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"355c8f5a217689107944e393d65a13e8fd0cee79","modified":1632706507362},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1632575909724},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"f4dcc0a596eb9801c4d3c033d018d0abb413c8e5","modified":1632575909724},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"b6899458d2ae8788e56de1b94a700d0e9080e05f","modified":1632575909728},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"bb1847f45e713cc88b1c0a97035ec01f0209c995","modified":1632575909731},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"66b14189a1913119ff5927c0b933b5c73fb37f48","modified":1632575909731},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"3d923989079e415368cc129a73a9b7a90463cfbe","modified":1632575909732},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1632575909748},{"_id":"themes/butterfly/scripts/events/init.js","hash":"5803aa55d9c21e51ea64c1ae50c9b602979aaee2","modified":1632575909748},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"1e1da036fae593be7e2cc502f0a5cbeb2e7881d1","modified":1632575909748},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"98ef86305b8d2ad9dbab969715e1ac93b407f036","modified":1632575909748},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"bd29f20fad3d3fab600940e7a6dc9a803943cb33","modified":1632575909749},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1632575909749},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1632575909749},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"98ab13a60413d68bd9d02d54d121c66a6d4634d2","modified":1632575909749},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"384de3c04809ec5fa996e8aa0628f770cd4bff3e","modified":1632575909750},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"51112d3db07f87034422ff4acc69ca2eb4215b4e","modified":1632575909750},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"8cb7ef368cc2ac7f4a13c2959908b1574e572acf","modified":1632575909750},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"7ffbe625f184116e442648c8416ea58614a1cef8","modified":1632575909751},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"eb019da8c190923e759d2fd7cb846281eef8594e","modified":1632575909751},{"_id":"themes/butterfly/scripts/tag/iconfont.js","hash":"1a6b110f6d7d01d0bb4809bcefbf9e02af38926f","modified":1632575909751},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1632575909751},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1632575909751},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"829229b0074b332ba779e159219eb2466612ff6e","modified":1632575909752},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"420ba8b11e7316b4c09eb301d39814bc9bae9f90","modified":1632575909752},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1632575909752},{"_id":"themes/butterfly/source/css/index.styl","hash":"c7924868adcb046b46498626a9223c7a7b3f2e30","modified":1632575909765},{"_id":"themes/butterfly/source/css/var.styl","hash":"bf45f7a7c213217b4198af9c3efed75a6182efdd","modified":1632575909765},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1632575909765},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1632575909766},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1632575909766},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1632575909767},{"_id":"themes/butterfly/source/js/main.js","hash":"5daa345abeda9de55a9912c30944fe80c084a2bf","modified":1632575909767},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1632575909768},{"_id":"themes/butterfly/source/js/utils.js","hash":"1b8bf1e6d50fa8ffe2aff7548b141cab72540ba0","modified":1632575909769},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"3a2797d2744607ba6cdb5a02853851957c0f7e29","modified":1632575909727},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca5dc48c7138023704ac602d1251a0cc753c4f76","modified":1632575909727},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"7677911bd3f43edaf8230eea02f60a248eee9934","modified":1632575909728},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"419807903e5586b8804b1f8f17cea97bd05f0b17","modified":1632575909727},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"375135be92de700e7bbd03313738205c9d0a9aa3","modified":1632575909728},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"07380718ed3af19a7e64b30e8c13726fe5983947","modified":1632575909724},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"903d12250ce70713dd5b8ac7e1f7a20fe15eb815","modified":1632575909725},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"3ca9d9cdfd6e61df1d5b07de40f34349cda7a7c7","modified":1632575909725},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"73c04d62055840545112dd12d73807835ca62347","modified":1632575909725},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1632575909726},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1632575909726},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"d6556d5396eb0e10ea0ec10158779c21dc78f738","modified":1632575909726},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1632575909726},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1632575909727},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"2e1ab0c2ca59a1ff5a5ba9b6ef60f3e34af5430c","modified":1632575909729},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"208f9d7f1e067f439e920a3440e939b0ff4c5a18","modified":1632575909729},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"971038debf539333b1687b4a1d87cf4fc965a846","modified":1632575909729},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"dcccb1425fabcf12a1bed955518b0e7b1054cab0","modified":1632575909729},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"95924d28d71b28769963529f82b376a9dc731fad","modified":1632575909730},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"f5ea1e10a169aeb98e42b19ac084c4eb27693b46","modified":1632575909730},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"c7b518f4e24e37633380935611961b522e6c4586","modified":1632575909730},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"62dc2e683d56ddc9b588abc44dc1cfb778a2c68f","modified":1632575909730},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"e76746cc92424c3a8cc51c3a82f1cde255d8b755","modified":1632644736899},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"3e838f71592a6dd1b0abb42ee731b5b5fbdb5bc3","modified":1632575909731},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"1d507b3b54cfbeac100a0cb32850e1b80b0c9f4d","modified":1632575909732},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4c3da5a89b4e6fd3ab527f5c6d27790359d57f71","modified":1632575909738},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d06dafe7faf3a2e328ef62f26166a51ffe7a5579","modified":1632575909741},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"cda398cd6b796115dd1c6295056f3869b36f49c1","modified":1632575909741},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1632575909741},{"_id":"themes/butterfly/layout/includes/third-party/pwanotice.pug","hash":"6ea781f746e360edebcddae095472adc19178d92","modified":1632706439091},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"4a2ea9fe59f1dc8cb4f4f6a28cf24a40fc300254","modified":1632575909743},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1632575909743},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"009bdbef23381f10664622fafdc602f2ff5bf1ec","modified":1632575909744},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1632575909744},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"6c3449a44ae1a80f71dd4d9d6a85cec1781ceff1","modified":1632575909744},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1632575909744},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1632575909745},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"0f1a5c356c1ffd47ff49e153226e2d670dc61057","modified":1632575909745},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"0b5c165664f9f8691551fc5ff435b40e7f73c737","modified":1632575909745},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"471b20e71a19db1f5115727082e5188200c49383","modified":1632575909745},{"_id":"themes/butterfly/layout/includes/widget/card_self.pug","hash":"8318c7c9a6aef966afba44e283111e7ff0b2f04f","modified":1632575909745},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"9755cac8424dc578e9ec07dbcaa429fddbedd392","modified":1632575909746},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1632575909746},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"62adef7998fb9bebc5891a49472cfea944a1bf7a","modified":1632575909746},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"e4c39101d7087066a86f7743985a53d6a246470b","modified":1632575909746},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"f9de9db2a49ac4d5447660ab159171ac5c228e3c","modified":1632575909753},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"03164bca4546707543828cb2a41bc672b77bfa5a","modified":1632575909753},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"2e8e391b211b2416d3c9430ab5361659c073f348","modified":1632575909753},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3f0b8699f529f0842c3b101006f60cb7933c16ff","modified":1632575909755},{"_id":"themes/butterfly/source/css/_layout/404.styl","hash":"7730741fa8beb29e3231d397171f312957563e7b","modified":1632575909755},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"23ea60f8becc91f6e9f6cfb1cbfd25689c263b9c","modified":1632575909756},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1632575909756},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"8e6c9a2c1881985e4b2ae14ef1bdfdbb1bc83b37","modified":1632575909756},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"bfc4b9d8df66593c11c9ae78899f54e69785ca90","modified":1632575909757},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"dd71e34edece4e06b59e941fb3cc5ad9a3ad09cf","modified":1632575909757},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f11464c4d8a25c517d330c9b4cff9846ae94251f","modified":1632575909757},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"db7fe645662d87be4f8dfc08e55bbe1a3734bf93","modified":1632575909757},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"444d9867a78b0c0899163b231bfec369268ecab0","modified":1632575909758},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"8c4e08c8a63dacdfb2a733a0d0035fa97c7f5e9e","modified":1632575909758},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"69e4edef9aa18115bdeca4756a8e14926572a964","modified":1632575909758},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"a00ad74074513a1c7f6e02977b8fa778beaa2108","modified":1632575909758},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"191ce31ce0f2b1d22a64225801a88cee6054f574","modified":1632575909759},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"943aa34c83c87d0225db65ae90621870472972fa","modified":1632575909759},{"_id":"themes/butterfly/source/css/_layout/wg-bg.styl","hash":"f1c666a5e4b4151403e75a7ac53315c686013051","modified":1632575909759},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"8489722684aa9b4baa38386f4d4b39f4dbd60113","modified":1632575909759},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"89a6cb63a97cc08675319c403e4a89391f6ab401","modified":1632575909760},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"87c576a3361f30eefafec27a872ad76e9fbb2765","modified":1632575909760},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"190b85de3e686393e45869d12464995f23b304dc","modified":1632575909760},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"ca1d3a885a85a91fcd6f7b55fca96cafb6a1b0a3","modified":1632575909760},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"5e5c1d6d104cc15314ae365d0da7cb07334a6457","modified":1632575909761},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"b6bcf48399d6bbebaff2d9afc8c77af5b40ee644","modified":1632575909761},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"0da09b1811a776106ca66c56be6e2a396dca5680","modified":1632575909761},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"26e26797b3175498e20b2a8bf1679d3ed9fac5a6","modified":1632575909761},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"25ac939fc57346de07ba9e15a1a760b492baefd7","modified":1632575909762},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"e65ed98056e6c91e622f94bad5283d00fdb22142","modified":1632575909762},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"fa2985afd08556b25f5f1a01bc1a7c76b294a962","modified":1632575909762},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"c3369a14f4111c098d0177036ca57df6deb59d72","modified":1632575909763},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"6c12a03e26ca5d538537d472657d3d03a7fcbb87","modified":1632575909763},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"aa0728c556af75f5d66ecd44fa207722d474c26d","modified":1632575909763},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"56691537c7f06c2cf1ffa1509a328f506d938ee8","modified":1632575909763},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1632575909764},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"c91609b7f431cacecc3718ae2fb7403c55f8267a","modified":1632575909764},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"75a5c15c7029197ec5cffd27f7c5455891c946c9","modified":1632575909764},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"8520674768dd0b1837f947892e8402b192a4f9c1","modified":1632575909764},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1632575909765},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"a19f12257b14f70806a0c3cb0e9df1090f36e919","modified":1632575909768},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"3234942decaa1fde5b872766d4943a2e8cb9ef72","modified":1632575909768},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1632575909732},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4eebb2d94ca75809ef0cf32d70f13e9bf1e87091","modified":1632575909732},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"a18415004d03c0a1783eccac522fbcb6ce0ea1f1","modified":1632575909733},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"896dc0b7480151562c5717771e3000c5a7fc1b16","modified":1632575909733},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"f3db5c5e738e097a191dc0de59c61d3e1444f7c3","modified":1632575909733},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"eb2d840fa42de3ec7a7fda0eaa30246d52f543e2","modified":1632575909733},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1632575909734},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1632575909734},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1632575909734},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1632575909734},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1632575909734},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1632575909735},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"d5f81fd5443a1b09efb165b5f4447a35949d14ad","modified":1632575909735},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"50126b2e841b01584b8b65b2f834038e3997b694","modified":1632575909735},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"0bf6a47e804fb793b40f82690a24816b902edd41","modified":1632575909735},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0254203aae73e70b90dfce6ec4f9c9d3be9ac9f8","modified":1632575909736},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"d97403cdd58c759cfd1752dd85aa4a0f9b73dc46","modified":1632575909736},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"e877c98949873a62659db7501d19eb3d66650b51","modified":1632575909736},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1632575909736},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"5a17002e9051fb5c1cf47623b3ad5c667aebaad9","modified":1632988135724},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"1c7e9fe86b7d7ef18cc876dfce19263fd4e73066","modified":1632575909737},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"8290994cf1ee2faff60214ff245cf513fbbe94aa","modified":1632575909737},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0bf1c53b914443c66be5077ff09cfc218f111e11","modified":1632575909737},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"8890becd8220c57db2c7451409710942c103a7f4","modified":1632575909739},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"0ad766ae491e6fcba2ef3d136a7af6158cd4153e","modified":1632575909740},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"16cf05cf9649322da57e9b8d316573bb65f8d8d8","modified":1632575909740},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"767c38e3dfa0097b0dc1fdfd0df292c16f757d05","modified":1632575909740},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"a3d43cc360666b5b9730e8bb9e5c8fd940ae5b3d","modified":1632575909740},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"83103bad0db195bce095330c4a84e7529bbd40dd","modified":1632575909741},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1632575909738},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"266caf985dc0703ff81b871b8f8d206f57db6e79","modified":1632575909739},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"87e40f0c315407ab88571a2b3450d640f15c96bc","modified":1632575909739},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"faf1113de12d6db0486572d7e99b03cbd0c4a896","modified":1632575909739},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"1c06e60b120c946c1856904848ceba6ab58d1f82","modified":1632575909742},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1632575909742},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"fbcf94ecdca30bed7cfc4f4ec08b200579c2614e","modified":1632575909742},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1632575909742},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1632575909742},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1632575909743},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"7e9a7347dd8ca4c33c564fb62512743b6012bb2d","modified":1632575909743},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"b0916c8c7d15b67b55cb1618be8370870fedbf42","modified":1632575909754},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"b74c61f6e15b422e9d2df23133552bbd1b5fe513","modified":1632575909754},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1632575909754},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"4d71aab9082c67d3ee52ad58dfc3c1c9b41f2ab1","modified":1632575909755},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1632575909755},{"_id":"source/_posts/stdio.md","hash":"af7d68c9d8d4c5008a36f9d0f57cb954196fb91d","modified":1634127093570},{"_id":"themes/butterfly/source/js/coin.js","hash":"b72e816d1c4f6d7df019b43d437d58857ff5ac2c","modified":1632797815900},{"_id":"source/image/favorites.md","hash":"2f2ade375398c7f633a25e194e7f4f808abe1762","modified":1632910539696},{"_id":"source/_posts/current.md","hash":"38b17c3cbb133d315ebaa69b28384c463adb19c9","modified":1633247386300},{"_id":"source/_posts/code_advice.md","hash":"62912c73e0c8e8df05c43011ab3475c1309e4f7c","modified":1634106226688},{"_id":"source/_posts/course.md","hash":"07fdffb8d861f29e614ff33d846d8ccc33b9bd0b","modified":1635517988978},{"_id":"source/_posts/float.md","hash":"b7e67b7e8b574a381d187e1a044c88f4a6e64514","modified":1634809700008},{"_id":"source/_posts/recursion.md","hash":"761f473adce9c19c865c9582c1c7ac6bf6a66834","modified":1635600913001},{"_id":"source/image/bg.jpg","hash":"3b3ceca7b4093b10b73c7c422813430e194e739c","modified":1635609774336},{"_id":"source/_posts/pointer.md","hash":"28fcb6222427bec50677e37aa33d4e4f0eff19af","modified":1635739362396},{"_id":"source/_posts/point.md","hash":"5a2786e499e0e8e31da6a955af9ec8dfd6e8255c","modified":1635864145366}],"Category":[{"name":"Java","_id":"cku22zp2t00047kwq8bmehou1"},{"name":"MC","_id":"cku22zp35000c7kwq3hnr3za0"},{"name":"通用","_id":"cku22zp39000k7kwq713mg3c8"},{"name":"C","_id":"cku22zp3b000r7kwqefp9fu4i"},{"name":"Python","_id":"cku22zp3g00117kwqbvypduqb"},{"name":"C/C++","_id":"cku3ervpo0000s0wq69rpacqe"},{"name":"物理","_id":"ckunqfwoh0001cwwqfqwmhfyz"},{"name":"随心记","_id":"ckvdzwpgt000bh8wqd4mu7i92"}],"Data":[{"_id":"link","data":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"},{"name":"Akilar店长","link":"https://akilar.top","avatar":"https://akilar.top/img/siteicon/favicon.png","descr":"欢迎光临糖果屋","siteshot":"https://cdn.jsdelivr.net/gh/Akilarlxh/ScreenShot@gh-pages/akilar.top.jpg"}]}]}],"Page":[{"_content":"{\n    \"lang\": \"en\",\n    \"name\": \"空梦の博客\",\n    \"short_name\": \"edBlog\",\n    \"theme_color\": \"#171717\",\n    \"background_color\": \"#171717\",\n    \"display\": \"standalone\",\n    \"scope\": \"/\",\n    \"start_url\": \"/\",\n    \"icons\": [\n        {\n            \"src\": \"logo/android-chrome-36x36.png\",\n            \"sizes\": \"36x36\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-48x48.png\",\n            \"sizes\": \"48x48\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-72x72.png\",\n            \"sizes\": \"72x72\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-96x96.png\",\n            \"sizes\": \"96x96\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-144x144.png\",\n            \"sizes\": \"144x144\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-192x192.png\",\n            \"sizes\": \"192x192\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-256x256.png\",\n            \"sizes\": \"256x256\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-384x384.png\",\n            \"sizes\": \"384x384\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-512x512.png\",\n            \"sizes\": \"512x512\",\n            \"type\": \"image/png\"\n        }\n    ]\n}\n","source":"manifest.json","raw":"{\n    \"lang\": \"en\",\n    \"name\": \"空梦の博客\",\n    \"short_name\": \"edBlog\",\n    \"theme_color\": \"#171717\",\n    \"background_color\": \"#171717\",\n    \"display\": \"standalone\",\n    \"scope\": \"/\",\n    \"start_url\": \"/\",\n    \"icons\": [\n        {\n            \"src\": \"logo/android-chrome-36x36.png\",\n            \"sizes\": \"36x36\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-48x48.png\",\n            \"sizes\": \"48x48\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-72x72.png\",\n            \"sizes\": \"72x72\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-96x96.png\",\n            \"sizes\": \"96x96\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-144x144.png\",\n            \"sizes\": \"144x144\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-192x192.png\",\n            \"sizes\": \"192x192\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-256x256.png\",\n            \"sizes\": \"256x256\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-384x384.png\",\n            \"sizes\": \"384x384\",\n            \"type\": \"image/png\"\n        },\n        {\n            \"src\": \"logo/android-chrome-512x512.png\",\n            \"sizes\": \"512x512\",\n            \"type\": \"image/png\"\n        }\n    ]\n}\n","date":"2021-09-27T02:49:44.017Z","updated":"2021-09-27T02:49:44.017Z","path":"manifest.json","layout":"false","title":"","comments":1,"_id":"cku22zp2n00007kwqbdl36xxe","content":"{\"lang\":\"en\",\"name\":\"空梦の博客\",\"short_name\":\"edBlog\",\"theme_color\":\"#171717\",\"background_color\":\"#171717\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"logo/android-chrome-36x36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-48x48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-96x96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-144x144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-256x256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-384x384.png\",\"sizes\":\"384x384\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-512x512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}]}","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":"{\"lang\":\"en\",\"name\":\"空梦の博客\",\"short_name\":\"edBlog\",\"theme_color\":\"#171717\",\"background_color\":\"#171717\",\"display\":\"standalone\",\"scope\":\"/\",\"start_url\":\"/\",\"icons\":[{\"src\":\"logo/android-chrome-36x36.png\",\"sizes\":\"36x36\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-48x48.png\",\"sizes\":\"48x48\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-72x72.png\",\"sizes\":\"72x72\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-96x96.png\",\"sizes\":\"96x96\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-144x144.png\",\"sizes\":\"144x144\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-256x256.png\",\"sizes\":\"256x256\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-384x384.png\",\"sizes\":\"384x384\",\"type\":\"image/png\"},{\"src\":\"logo/android-chrome-512x512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}]}"},{"_content":"backend:\n  name: git-gateway\n  branch: master # Branch to update (master by default)\n\n# These lines should *not* be indented\nmedia_folder: \"source/images\" # Media files will be stored in the repo under source/images\npublic_folder: \"images\" # The src attribute for uploaded media will begin with images\n\n# This line should *not* be indented\npublish_mode: editorial_workflow\n\ncollections:\n  - name: \"Post\" # Used in routes, e.g., /admin/collections/blog\n    label: \"Post\" # Used in the UI\n    folder: \"source/_posts\" # The path to the folder where the documents are stored\n    create: true # Allow users to create new documents in this collection\n    slug: \"{{slug}}\" # Filename template, e.g., YYYY-MM-DD-title.md\n    fields: # The fields for each document, usually in front matter\n      - {label: \"Layout\", name: \"layout\", widget: \"hidden\", default: \"blog\"}\n      - {label: \"标题TITLE\", name: \"title\", widget: \"string\"}\n      - {label: \"发布日期PUBLISH DATE\", name: \"date\", widget: \"datetime\"}\n      - {label: \"更新日期UPDATED DATE\", name: \"updated\", widget: \"datetime\"}\n#      - {label: \"缩写\"ABBRLINK, name: \"abbrlink\", widget: \"string\"}\n      - {label: \"标签TAGS\", name: \"tags\", widget: \"list\"}\n      - {label: \"分类目录CATEGORIES\", name: \"categories\", widget: \"list\"}\n      - {label: \"目录TOC\", name: \"toc\", widget: \"boolean\", default: true}\n      - {label: \"正文BODY\", name: \"body\", widget: \"markdown\"}    \n#      - {label: \"特色图片FEATURED IMAGE\", name: \"thumbnail\", widget: \"string\"}","source":"admin/config.yml","raw":"backend:\n  name: git-gateway\n  branch: master # Branch to update (master by default)\n\n# These lines should *not* be indented\nmedia_folder: \"source/images\" # Media files will be stored in the repo under source/images\npublic_folder: \"images\" # The src attribute for uploaded media will begin with images\n\n# This line should *not* be indented\npublish_mode: editorial_workflow\n\ncollections:\n  - name: \"Post\" # Used in routes, e.g., /admin/collections/blog\n    label: \"Post\" # Used in the UI\n    folder: \"source/_posts\" # The path to the folder where the documents are stored\n    create: true # Allow users to create new documents in this collection\n    slug: \"{{slug}}\" # Filename template, e.g., YYYY-MM-DD-title.md\n    fields: # The fields for each document, usually in front matter\n      - {label: \"Layout\", name: \"layout\", widget: \"hidden\", default: \"blog\"}\n      - {label: \"标题TITLE\", name: \"title\", widget: \"string\"}\n      - {label: \"发布日期PUBLISH DATE\", name: \"date\", widget: \"datetime\"}\n      - {label: \"更新日期UPDATED DATE\", name: \"updated\", widget: \"datetime\"}\n#      - {label: \"缩写\"ABBRLINK, name: \"abbrlink\", widget: \"string\"}\n      - {label: \"标签TAGS\", name: \"tags\", widget: \"list\"}\n      - {label: \"分类目录CATEGORIES\", name: \"categories\", widget: \"list\"}\n      - {label: \"目录TOC\", name: \"toc\", widget: \"boolean\", default: true}\n      - {label: \"正文BODY\", name: \"body\", widget: \"markdown\"}    \n#      - {label: \"特色图片FEATURED IMAGE\", name: \"thumbnail\", widget: \"string\"}","date":"2021-09-25T13:18:29.580Z","updated":"2021-09-25T13:18:29.580Z","path":"admin/config.json","layout":"false","title":"","comments":1,"_id":"cku22zp2r00027kwqce4vhlor","content":"{\"backend\":{\"name\":\"git-gateway\",\"branch\":\"master\"},\"media_folder\":\"source/images\",\"public_folder\":\"images\",\"publish_mode\":\"editorial_workflow\",\"collections\":[{\"name\":\"Post\",\"label\":\"Post\",\"folder\":\"source/_posts\",\"create\":true,\"slug\":\"\",\"fields\":[{\"label\":\"Layout\",\"name\":\"layout\",\"widget\":\"hidden\",\"default\":\"blog\"},{\"label\":\"标题TITLE\",\"name\":\"title\",\"widget\":\"string\"},{\"label\":\"发布日期PUBLISH DATE\",\"name\":\"date\",\"widget\":\"datetime\"},{\"label\":\"更新日期UPDATED DATE\",\"name\":\"updated\",\"widget\":\"datetime\"},{\"label\":\"标签TAGS\",\"name\":\"tags\",\"widget\":\"list\"},{\"label\":\"分类目录CATEGORIES\",\"name\":\"categories\",\"widget\":\"list\"},{\"label\":\"目录TOC\",\"name\":\"toc\",\"widget\":\"boolean\",\"default\":true},{\"label\":\"正文BODY\",\"name\":\"body\",\"widget\":\"markdown\"}]}]}","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":"{\"backend\":{\"name\":\"git-gateway\",\"branch\":\"master\"},\"media_folder\":\"source/images\",\"public_folder\":\"images\",\"publish_mode\":\"editorial_workflow\",\"collections\":[{\"name\":\"Post\",\"label\":\"Post\",\"folder\":\"source/_posts\",\"create\":true,\"slug\":\"\",\"fields\":[{\"label\":\"Layout\",\"name\":\"layout\",\"widget\":\"hidden\",\"default\":\"blog\"},{\"label\":\"标题TITLE\",\"name\":\"title\",\"widget\":\"string\"},{\"label\":\"发布日期PUBLISH DATE\",\"name\":\"date\",\"widget\":\"datetime\"},{\"label\":\"更新日期UPDATED DATE\",\"name\":\"updated\",\"widget\":\"datetime\"},{\"label\":\"标签TAGS\",\"name\":\"tags\",\"widget\":\"list\"},{\"label\":\"分类目录CATEGORIES\",\"name\":\"categories\",\"widget\":\"list\"},{\"label\":\"目录TOC\",\"name\":\"toc\",\"widget\":\"boolean\",\"default\":true},{\"label\":\"正文BODY\",\"name\":\"body\",\"widget\":\"markdown\"}]}]}"},{"_content":"<!doctype html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>HEXO管理页面</title>\n</head>\n\n<body>\n    <!-- Include the script that builds the page and powers Netlify CMS -->\n    <script src=\"https://cdn.jsdelivr.net/npm/netlify-cms@2.3.1/dist/cms.js\" integrity=\"sha256-Zv4A5owfOF4cDiraaQ7d66BMIs+XzF6tkmpAn+BAJ5U=\"\n        crossorigin=\"anonymous\"></script>\n    <script src=\"https://identity.netlify.com/v1/netlify-identity-widget.js\"></script>\n</body>\n\n</html>","source":"admin/index.html","raw":"<!doctype html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>HEXO管理页面</title>\n</head>\n\n<body>\n    <!-- Include the script that builds the page and powers Netlify CMS -->\n    <script src=\"https://cdn.jsdelivr.net/npm/netlify-cms@2.3.1/dist/cms.js\" integrity=\"sha256-Zv4A5owfOF4cDiraaQ7d66BMIs+XzF6tkmpAn+BAJ5U=\"\n        crossorigin=\"anonymous\"></script>\n    <script src=\"https://identity.netlify.com/v1/netlify-identity-widget.js\"></script>\n</body>\n\n</html>","date":"2021-09-25T13:18:29.581Z","updated":"2021-09-25T13:18:29.581Z","path":"admin/index.html","title":"","comments":1,"layout":"page","_id":"cku22zp2u00067kwq4hah4fwj","content":"<!doctype html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>HEXO管理页面</title>\n</head>\n\n<body>\n    <!-- Include the script that builds the page and powers Netlify CMS -->\n    <script src=\"https://cdn.jsdelivr.net/npm/netlify-cms@2.3.1/dist/cms.js\" integrity=\"sha256-Zv4A5owfOF4cDiraaQ7d66BMIs+XzF6tkmpAn+BAJ5U=\" crossorigin=\"anonymous\"></script>\n    <script src=\"https://identity.netlify.com/v1/netlify-identity-widget.js\"></script>\n</body>\n\n</html>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":"<!doctype html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>HEXO管理页面</title>\n</head>\n\n<body>\n    <!-- Include the script that builds the page and powers Netlify CMS -->\n    <script src=\"https://cdn.jsdelivr.net/npm/netlify-cms@2.3.1/dist/cms.js\" integrity=\"sha256-Zv4A5owfOF4cDiraaQ7d66BMIs+XzF6tkmpAn+BAJ5U=\" crossorigin=\"anonymous\"></script>\n    <script src=\"https://identity.netlify.com/v1/netlify-identity-widget.js\"></script>\n</body>\n\n</html>"},{"title":"分类","date":"2020-04-10T13:03:32.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2020-04-10 21:03:32\ntype: \"categories\"\n---","updated":"2021-09-25T13:18:29.581Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cku22zp2x00087kwqek5s6dmb","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":""},{"title":"友情链接","date":"2021-09-22T11:27:12.000Z","type":"link","comments":0,"_content":"","source":"link/index.md","raw":"---\ntitle: 友情链接\ndate: 2021-09-22 19:27:12\ntype: \"link\"\ncomments: false\n---\n","updated":"2021-09-25T13:18:29.581Z","path":"link/index.html","layout":"page","_id":"cku22zp34000a7kwq2pe30t30","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":""},{"_content":"/* 首页文章卡片 */\n[data-theme=\"light\"]\n  #recent-posts > .recent-post-item{\n    background:rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  #recent-posts > .recent-post-item{\n    background:rgba(20, 20, 20, 0.75);\n}\n/* 首页侧栏卡片 */\n[data-theme=\"light\"]\n  .card-widget{\n    background:rgba(250, 250, 250, 0.85)!important;\n}\n[data-theme=\"dark\"]\n  .card-widget{\n    background:rgba(20, 20, 20, 0.75)!important;\n}\n/* 文章页面正文背景 */\n[data-theme=\"light\"]\n  div#post{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#post{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 分页页面 */\n[data-theme=\"light\"]\n  div#page{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#page{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 归档页面 */\n[data-theme=\"light\"]\n  div#archive{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#archive{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 标签页面 */\n[data-theme=\"light\"]\n  div#tag{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#tag{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 分类页面 */\n[data-theme=\"light\"]\n  div#category{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#category{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 页脚背景 */\n#footer:before {\n    background: rgba(0,0,0,0.1) !important;\n}\n/* 有序列表序号 */\n[data-theme=\"dark\"]\n  li::before{\n    background: #2e2e2e !important;\n    box-shadow: 0 0 1px blue !important;\n  }\n/* 引入背景 */\n[data-theme=\"dark\"]\n  blockquote{\n    background-color: rgba(20,20,20,0.65) !important;\n  }\n/* 阅读模式代码框文字背景 */\n[data-theme=\"light\"]\n  #article-container figure.highlight .hljs{\n    background: rgba(0,0,0,0) !important;\n  }\n[data-theme=\"light\"]\n  div#sidebar-menus{\n    background: rgba(255,255,255,0.8) !important;\n  }\n[data-theme=\"dark\"]\n  div#sidebar-menus{\n    background: rgba(18,18,18,0.8) !important;\n  }\n[data-theme=\"dark\"]\n  div#menu-mask{\n    background: rgba(0,0,0,0.6) !important;\n  }\n[data-theme=\"dark\"]\n  div#sidebar-menus.site-page{\n    background: rgba(255,255,255,0.5);\n  }","source":"self/backgroundA.css","raw":"/* 首页文章卡片 */\n[data-theme=\"light\"]\n  #recent-posts > .recent-post-item{\n    background:rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  #recent-posts > .recent-post-item{\n    background:rgba(20, 20, 20, 0.75);\n}\n/* 首页侧栏卡片 */\n[data-theme=\"light\"]\n  .card-widget{\n    background:rgba(250, 250, 250, 0.85)!important;\n}\n[data-theme=\"dark\"]\n  .card-widget{\n    background:rgba(20, 20, 20, 0.75)!important;\n}\n/* 文章页面正文背景 */\n[data-theme=\"light\"]\n  div#post{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#post{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 分页页面 */\n[data-theme=\"light\"]\n  div#page{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#page{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 归档页面 */\n[data-theme=\"light\"]\n  div#archive{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#archive{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 标签页面 */\n[data-theme=\"light\"]\n  div#tag{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#tag{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 分类页面 */\n[data-theme=\"light\"]\n  div#category{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#category{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 页脚背景 */\n#footer:before {\n    background: rgba(0,0,0,0.1) !important;\n}\n/* 有序列表序号 */\n[data-theme=\"dark\"]\n  li::before{\n    background: #2e2e2e !important;\n    box-shadow: 0 0 1px blue !important;\n  }\n/* 引入背景 */\n[data-theme=\"dark\"]\n  blockquote{\n    background-color: rgba(20,20,20,0.65) !important;\n  }\n/* 阅读模式代码框文字背景 */\n[data-theme=\"light\"]\n  #article-container figure.highlight .hljs{\n    background: rgba(0,0,0,0) !important;\n  }\n[data-theme=\"light\"]\n  div#sidebar-menus{\n    background: rgba(255,255,255,0.8) !important;\n  }\n[data-theme=\"dark\"]\n  div#sidebar-menus{\n    background: rgba(18,18,18,0.8) !important;\n  }\n[data-theme=\"dark\"]\n  div#menu-mask{\n    background: rgba(0,0,0,0.6) !important;\n  }\n[data-theme=\"dark\"]\n  div#sidebar-menus.site-page{\n    background: rgba(255,255,255,0.5);\n  }","date":"2021-09-28T03:59:32.434Z","updated":"2021-09-28T03:59:32.434Z","path":"self/backgroundA.css","layout":"false","_id":"cku22zp36000f7kwq2e3a09xa","title":"","comments":1,"content":"/* 首页文章卡片 */\n[data-theme=\"light\"]\n  #recent-posts > .recent-post-item{\n    background:rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  #recent-posts > .recent-post-item{\n    background:rgba(20, 20, 20, 0.75);\n}\n/* 首页侧栏卡片 */\n[data-theme=\"light\"]\n  .card-widget{\n    background:rgba(250, 250, 250, 0.85)!important;\n}\n[data-theme=\"dark\"]\n  .card-widget{\n    background:rgba(20, 20, 20, 0.75)!important;\n}\n/* 文章页面正文背景 */\n[data-theme=\"light\"]\n  div#post{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#post{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 分页页面 */\n[data-theme=\"light\"]\n  div#page{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#page{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 归档页面 */\n[data-theme=\"light\"]\n  div#archive{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#archive{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 标签页面 */\n[data-theme=\"light\"]\n  div#tag{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#tag{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 分类页面 */\n[data-theme=\"light\"]\n  div#category{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#category{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 页脚背景 */\n#footer:before {\n    background: rgba(0,0,0,0.1) !important;\n}\n/* 有序列表序号 */\n[data-theme=\"dark\"]\n  li::before{\n    background: #2e2e2e !important;\n    box-shadow: 0 0 1px blue !important;\n  }\n/* 引入背景 */\n[data-theme=\"dark\"]\n  blockquote{\n    background-color: rgba(20,20,20,0.65) !important;\n  }\n/* 阅读模式代码框文字背景 */\n[data-theme=\"light\"]\n  #article-container figure.highlight .hljs{\n    background: rgba(0,0,0,0) !important;\n  }\n[data-theme=\"light\"]\n  div#sidebar-menus{\n    background: rgba(255,255,255,0.8) !important;\n  }\n[data-theme=\"dark\"]\n  div#sidebar-menus{\n    background: rgba(18,18,18,0.8) !important;\n  }\n[data-theme=\"dark\"]\n  div#menu-mask{\n    background: rgba(0,0,0,0.6) !important;\n  }\n[data-theme=\"dark\"]\n  div#sidebar-menus.site-page{\n    background: rgba(255,255,255,0.5);\n  }","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":"/* 首页文章卡片 */\n[data-theme=\"light\"]\n  #recent-posts > .recent-post-item{\n    background:rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  #recent-posts > .recent-post-item{\n    background:rgba(20, 20, 20, 0.75);\n}\n/* 首页侧栏卡片 */\n[data-theme=\"light\"]\n  .card-widget{\n    background:rgba(250, 250, 250, 0.85)!important;\n}\n[data-theme=\"dark\"]\n  .card-widget{\n    background:rgba(20, 20, 20, 0.75)!important;\n}\n/* 文章页面正文背景 */\n[data-theme=\"light\"]\n  div#post{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#post{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 分页页面 */\n[data-theme=\"light\"]\n  div#page{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#page{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 归档页面 */\n[data-theme=\"light\"]\n  div#archive{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#archive{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 标签页面 */\n[data-theme=\"light\"]\n  div#tag{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#tag{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 分类页面 */\n[data-theme=\"light\"]\n  div#category{\n    background: rgba(250, 250, 250, 0.85);\n}\n[data-theme=\"dark\"]\n  div#category{\n    background: rgba(20, 20, 20, 0.75);\n}\n/* 页脚背景 */\n#footer:before {\n    background: rgba(0,0,0,0.1) !important;\n}\n/* 有序列表序号 */\n[data-theme=\"dark\"]\n  li::before{\n    background: #2e2e2e !important;\n    box-shadow: 0 0 1px blue !important;\n  }\n/* 引入背景 */\n[data-theme=\"dark\"]\n  blockquote{\n    background-color: rgba(20,20,20,0.65) !important;\n  }\n/* 阅读模式代码框文字背景 */\n[data-theme=\"light\"]\n  #article-container figure.highlight .hljs{\n    background: rgba(0,0,0,0) !important;\n  }\n[data-theme=\"light\"]\n  div#sidebar-menus{\n    background: rgba(255,255,255,0.8) !important;\n  }\n[data-theme=\"dark\"]\n  div#sidebar-menus{\n    background: rgba(18,18,18,0.8) !important;\n  }\n[data-theme=\"dark\"]\n  div#menu-mask{\n    background: rgba(0,0,0,0.6) !important;\n  }\n[data-theme=\"dark\"]\n  div#sidebar-menus.site-page{\n    background: rgba(255,255,255,0.5);\n  }"},{"_content":"[data-theme=\"dark\"]\n  #post .post-copyright {\n    background-color: rgb(7 8 10);\n    text-shadow: #bfbeb8 1px 0 4px;\n  }\n[data-theme=\"dark\"]\n  #post .post-copyright {\n    border: 1px solid rgb(19 18 18 / 35%);\n  }\n[data-theme=\"dark\"]\n  .post-copyright-info {\n    color: #e0e0e4;\n  }\n#post .post-copyright__title{\n    font-size:22px;\n}\n#post .post-copyright__notice{\n    font-size:15px;\n}","source":"self/copyright.css","raw":"[data-theme=\"dark\"]\n  #post .post-copyright {\n    background-color: rgb(7 8 10);\n    text-shadow: #bfbeb8 1px 0 4px;\n  }\n[data-theme=\"dark\"]\n  #post .post-copyright {\n    border: 1px solid rgb(19 18 18 / 35%);\n  }\n[data-theme=\"dark\"]\n  .post-copyright-info {\n    color: #e0e0e4;\n  }\n#post .post-copyright__title{\n    font-size:22px;\n}\n#post .post-copyright__notice{\n    font-size:15px;\n}","date":"2021-09-25T13:18:29.582Z","updated":"2021-09-25T13:18:29.582Z","path":"self/copyright.css","layout":"false","title":"","comments":1,"_id":"cku22zp38000h7kwqg72x7mai","content":"[data-theme=\"dark\"]\n  #post .post-copyright {\n    background-color: rgb(7 8 10);\n    text-shadow: #bfbeb8 1px 0 4px;\n  }\n[data-theme=\"dark\"]\n  #post .post-copyright {\n    border: 1px solid rgb(19 18 18 / 35%);\n  }\n[data-theme=\"dark\"]\n  .post-copyright-info {\n    color: #e0e0e4;\n  }\n#post .post-copyright__title{\n    font-size:22px;\n}\n#post .post-copyright__notice{\n    font-size:15px;\n}","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":"[data-theme=\"dark\"]\n  #post .post-copyright {\n    background-color: rgb(7 8 10);\n    text-shadow: #bfbeb8 1px 0 4px;\n  }\n[data-theme=\"dark\"]\n  #post .post-copyright {\n    border: 1px solid rgb(19 18 18 / 35%);\n  }\n[data-theme=\"dark\"]\n  .post-copyright-info {\n    color: #e0e0e4;\n  }\n#post .post-copyright__title{\n    font-size:22px;\n}\n#post .post-copyright__notice{\n    font-size:15px;\n}"},{"_content":"[data-theme=\"light\"]\n  div#menus span, a#site-name, span#subtitle, .author-info__name, h1{\n    text-shadow: 0 0 2px black !important;\n}\na#site-name {\n  font-size: xx-large;\n}","source":"self/font.css","raw":"[data-theme=\"light\"]\n  div#menus span, a#site-name, span#subtitle, .author-info__name, h1{\n    text-shadow: 0 0 2px black !important;\n}\na#site-name {\n  font-size: xx-large;\n}","date":"2021-09-26T12:39:14.786Z","updated":"2021-09-26T12:39:14.786Z","path":"self/font.css","layout":"false","title":"","comments":1,"_id":"cku22zp3a000m7kwq3nhh020q","content":"[data-theme=\"light\"]\n  div#menus span, a#site-name, span#subtitle, .author-info__name, h1{\n    text-shadow: 0 0 2px black !important;\n}\na#site-name {\n  font-size: xx-large;\n}","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":"[data-theme=\"light\"]\n  div#menus span, a#site-name, span#subtitle, .author-info__name, h1{\n    text-shadow: 0 0 2px black !important;\n}\na#site-name {\n  font-size: xx-large;\n}"},{"_content":"svg.icon {\n   width: 1.25em; height: 1.25em;\n   /* width和height定义图标的默认宽度和高度*/\n   vertical-align: -0.15em;\n   fill: currentColor;\n   overflow: hidden;\n   text-shadow: 0 0 1px black;\n}","source":"self/icon.css","raw":"svg.icon {\n   width: 1.25em; height: 1.25em;\n   /* width和height定义图标的默认宽度和高度*/\n   vertical-align: -0.15em;\n   fill: currentColor;\n   overflow: hidden;\n   text-shadow: 0 0 1px black;\n}","date":"2021-09-26T03:46:15.289Z","updated":"2021-09-26T03:46:15.289Z","path":"self/icon.css","layout":"false","title":"","comments":1,"_id":"cku22zp3a000p7kwqh01zbg0u","content":"svg.icon {\n   width: 1.25em; height: 1.25em;\n   /* width和height定义图标的默认宽度和高度*/\n   vertical-align: -0.15em;\n   fill: currentColor;\n   overflow: hidden;\n   text-shadow: 0 0 1px black;\n}","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":"svg.icon {\n   width: 1.25em; height: 1.25em;\n   /* width和height定义图标的默认宽度和高度*/\n   vertical-align: -0.15em;\n   fill: currentColor;\n   overflow: hidden;\n   text-shadow: 0 0 1px black;\n}"},{"_content":"/*\n    Name:     Kimbie (dark)\n    Author:   Jan T. Sott\n    License:  Creative Commons Attribution-ShareAlike 4.0 Unported License\n    URL:      https://github.com/idleberg/Kimbie-highlight.js\n*/\n\n:root {\n  --hl-color: #d3af86;\n  --hl-bg: #171717;\n  --hltools-bg: #1a1a1a;\n  --hltools-color: #a3adaf;\n  --hlnumber-bg: #272626;\n  --hlnumber-color: #a3adaf;\n}\n\n#article-container figure.highlight .hljs {\n  background: #171717;\n  color: #d3af86;\n}\n\n/* Kimbie Comment */\n.hljs-comment,\n.hljs-quote {\n  color: #d6baad;\n}\n\n/* Kimbie Red */\n.hljs-variable,\n.hljs-template-variable,\n.hljs-tag,\n.hljs-name,\n.hljs-selector-id,\n.hljs-selector-class,\n.hljs-regexp,\n.hljs-meta {\n  color: #dc3958;\n}\n\n/* Kimbie Orange */\n.hljs-number,\n.hljs-built_in,\n.hljs-literal,\n.hljs-type,\n.hljs-params,\n.hljs-deletion,\n.hljs-link {\n  color: #f79a32;\n}\n\n/* Kimbie Green */\n.hljs-string,\n.hljs-symbol,\n.hljs-bullet,\n.hljs-addition {\n  color: #889b4a;\n}\n\n/* Kimbie Purple */\n.hljs-keyword,\n.hljs-selector-tag,\n.hljs-function {\n  color: #98676a;\n}\n\n/* Kimbie Yellow */\n.hljs-title,\n.hljs-section,\n.hljs-attribute {\n  color: #f06431;\n}\n\n.hljs-emphasis {\n  font-style: italic;\n}\n\n.hljs-strong {\n  font-weight: bold;\n}","source":"self/kimbie-dark.css","raw":"/*\n    Name:     Kimbie (dark)\n    Author:   Jan T. Sott\n    License:  Creative Commons Attribution-ShareAlike 4.0 Unported License\n    URL:      https://github.com/idleberg/Kimbie-highlight.js\n*/\n\n:root {\n  --hl-color: #d3af86;\n  --hl-bg: #171717;\n  --hltools-bg: #1a1a1a;\n  --hltools-color: #a3adaf;\n  --hlnumber-bg: #272626;\n  --hlnumber-color: #a3adaf;\n}\n\n#article-container figure.highlight .hljs {\n  background: #171717;\n  color: #d3af86;\n}\n\n/* Kimbie Comment */\n.hljs-comment,\n.hljs-quote {\n  color: #d6baad;\n}\n\n/* Kimbie Red */\n.hljs-variable,\n.hljs-template-variable,\n.hljs-tag,\n.hljs-name,\n.hljs-selector-id,\n.hljs-selector-class,\n.hljs-regexp,\n.hljs-meta {\n  color: #dc3958;\n}\n\n/* Kimbie Orange */\n.hljs-number,\n.hljs-built_in,\n.hljs-literal,\n.hljs-type,\n.hljs-params,\n.hljs-deletion,\n.hljs-link {\n  color: #f79a32;\n}\n\n/* Kimbie Green */\n.hljs-string,\n.hljs-symbol,\n.hljs-bullet,\n.hljs-addition {\n  color: #889b4a;\n}\n\n/* Kimbie Purple */\n.hljs-keyword,\n.hljs-selector-tag,\n.hljs-function {\n  color: #98676a;\n}\n\n/* Kimbie Yellow */\n.hljs-title,\n.hljs-section,\n.hljs-attribute {\n  color: #f06431;\n}\n\n.hljs-emphasis {\n  font-style: italic;\n}\n\n.hljs-strong {\n  font-weight: bold;\n}","date":"2021-09-26T03:25:02.608Z","updated":"2021-09-25T13:18:29.717Z","path":"self/kimbie-dark.css","layout":"false","title":"","comments":1,"_id":"cku22zp3b000t7kwqbz9qay8u","content":"/*\n    Name:     Kimbie (dark)\n    Author:   Jan T. Sott\n    License:  Creative Commons Attribution-ShareAlike 4.0 Unported License\n    URL:      https://github.com/idleberg/Kimbie-highlight.js\n*/\n\n:root {\n  --hl-color: #d3af86;\n  --hl-bg: #171717;\n  --hltools-bg: #1a1a1a;\n  --hltools-color: #a3adaf;\n  --hlnumber-bg: #272626;\n  --hlnumber-color: #a3adaf;\n}\n\n#article-container figure.highlight .hljs {\n  background: #171717;\n  color: #d3af86;\n}\n\n/* Kimbie Comment */\n.hljs-comment,\n.hljs-quote {\n  color: #d6baad;\n}\n\n/* Kimbie Red */\n.hljs-variable,\n.hljs-template-variable,\n.hljs-tag,\n.hljs-name,\n.hljs-selector-id,\n.hljs-selector-class,\n.hljs-regexp,\n.hljs-meta {\n  color: #dc3958;\n}\n\n/* Kimbie Orange */\n.hljs-number,\n.hljs-built_in,\n.hljs-literal,\n.hljs-type,\n.hljs-params,\n.hljs-deletion,\n.hljs-link {\n  color: #f79a32;\n}\n\n/* Kimbie Green */\n.hljs-string,\n.hljs-symbol,\n.hljs-bullet,\n.hljs-addition {\n  color: #889b4a;\n}\n\n/* Kimbie Purple */\n.hljs-keyword,\n.hljs-selector-tag,\n.hljs-function {\n  color: #98676a;\n}\n\n/* Kimbie Yellow */\n.hljs-title,\n.hljs-section,\n.hljs-attribute {\n  color: #f06431;\n}\n\n.hljs-emphasis {\n  font-style: italic;\n}\n\n.hljs-strong {\n  font-weight: bold;\n}","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":"/*\n    Name:     Kimbie (dark)\n    Author:   Jan T. Sott\n    License:  Creative Commons Attribution-ShareAlike 4.0 Unported License\n    URL:      https://github.com/idleberg/Kimbie-highlight.js\n*/\n\n:root {\n  --hl-color: #d3af86;\n  --hl-bg: #171717;\n  --hltools-bg: #1a1a1a;\n  --hltools-color: #a3adaf;\n  --hlnumber-bg: #272626;\n  --hlnumber-color: #a3adaf;\n}\n\n#article-container figure.highlight .hljs {\n  background: #171717;\n  color: #d3af86;\n}\n\n/* Kimbie Comment */\n.hljs-comment,\n.hljs-quote {\n  color: #d6baad;\n}\n\n/* Kimbie Red */\n.hljs-variable,\n.hljs-template-variable,\n.hljs-tag,\n.hljs-name,\n.hljs-selector-id,\n.hljs-selector-class,\n.hljs-regexp,\n.hljs-meta {\n  color: #dc3958;\n}\n\n/* Kimbie Orange */\n.hljs-number,\n.hljs-built_in,\n.hljs-literal,\n.hljs-type,\n.hljs-params,\n.hljs-deletion,\n.hljs-link {\n  color: #f79a32;\n}\n\n/* Kimbie Green */\n.hljs-string,\n.hljs-symbol,\n.hljs-bullet,\n.hljs-addition {\n  color: #889b4a;\n}\n\n/* Kimbie Purple */\n.hljs-keyword,\n.hljs-selector-tag,\n.hljs-function {\n  color: #98676a;\n}\n\n/* Kimbie Yellow */\n.hljs-title,\n.hljs-section,\n.hljs-attribute {\n  color: #f06431;\n}\n\n.hljs-emphasis {\n  font-style: italic;\n}\n\n.hljs-strong {\n  font-weight: bold;\n}"},{"_content":"/* 全局默认鼠标指针 */\nbody,\nhtml, li:hover::before{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto !important;\n}\n/* 选择链接、标签、图片、按钮时的鼠标指针 */\na:hover, a#site-name:hover, img, button:hover, div#scroll-down:hover, i:hover{\n    cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 选中输入框时的鼠标指针 */\ninput:hover{\n    cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/texto.cur'),auto;\n}\n/* 悬停页脚链接标签（例如页脚徽标）时的鼠标指针 */\n#footer-wrap a:hover{\n      cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto;\n}\n/* 悬停页码时的鼠标指针 */\n#pagination .page-number:hover{\n      cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/Alternative2.cur'),auto;\n}\n/* 悬停菜单栏时的鼠标指针 */\n#nav .site-page:hover{\n      cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/Alternative2.cur'),auto;\n}\n/* 播放器 */\n/* 总体 */\n.aplayer:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 歌单列表 */\n.aplayer-list li:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 歌曲封面 */\n.aplayer-pic:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 控制台 */\n.aplayer-body:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 按钮图标 */\n.aplayer-icon:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 信息栏 */\n.aplayer-info:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 列表数字标号 */\n.aplayer-list-index:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto;\n}\n/* 列表歌手名称 */\n.aplayer-list-author:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 控制台歌手信息 */\n.aplayer-author:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 控制台歌曲名称 */\n.aplayer-title:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 控制台歌曲信息背景 */\n.aplayer-music:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto !important;\n}\n/* 进度条 */\n.aplayer-bar-wrap div:hover, .aplayer-bar-wrap span:hover, .aplayer-bar-wrap svg:hover, .aplayer-bar-wrap path:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 音量条 */\n.aplayer-volume-bar-wrap:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto !important;\n}","source":"self/mouse.css","raw":"/* 全局默认鼠标指针 */\nbody,\nhtml, li:hover::before{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto !important;\n}\n/* 选择链接、标签、图片、按钮时的鼠标指针 */\na:hover, a#site-name:hover, img, button:hover, div#scroll-down:hover, i:hover{\n    cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 选中输入框时的鼠标指针 */\ninput:hover{\n    cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/texto.cur'),auto;\n}\n/* 悬停页脚链接标签（例如页脚徽标）时的鼠标指针 */\n#footer-wrap a:hover{\n      cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto;\n}\n/* 悬停页码时的鼠标指针 */\n#pagination .page-number:hover{\n      cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/Alternative2.cur'),auto;\n}\n/* 悬停菜单栏时的鼠标指针 */\n#nav .site-page:hover{\n      cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/Alternative2.cur'),auto;\n}\n/* 播放器 */\n/* 总体 */\n.aplayer:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 歌单列表 */\n.aplayer-list li:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 歌曲封面 */\n.aplayer-pic:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 控制台 */\n.aplayer-body:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 按钮图标 */\n.aplayer-icon:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 信息栏 */\n.aplayer-info:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 列表数字标号 */\n.aplayer-list-index:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto;\n}\n/* 列表歌手名称 */\n.aplayer-list-author:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 控制台歌手信息 */\n.aplayer-author:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 控制台歌曲名称 */\n.aplayer-title:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 控制台歌曲信息背景 */\n.aplayer-music:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto !important;\n}\n/* 进度条 */\n.aplayer-bar-wrap div:hover, .aplayer-bar-wrap span:hover, .aplayer-bar-wrap svg:hover, .aplayer-bar-wrap path:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 音量条 */\n.aplayer-volume-bar-wrap:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto !important;\n}","date":"2021-09-29T07:33:35.295Z","updated":"2021-09-29T07:33:35.295Z","path":"self/mouse.css","layout":"false","_id":"cku22zp3b000v7kwqadh6ef11","title":"","comments":1,"content":"/* 全局默认鼠标指针 */\nbody,\nhtml, li:hover::before{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto !important;\n}\n/* 选择链接、标签、图片、按钮时的鼠标指针 */\na:hover, a#site-name:hover, img, button:hover, div#scroll-down:hover, i:hover{\n    cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 选中输入框时的鼠标指针 */\ninput:hover{\n    cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/texto.cur'),auto;\n}\n/* 悬停页脚链接标签（例如页脚徽标）时的鼠标指针 */\n#footer-wrap a:hover{\n      cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto;\n}\n/* 悬停页码时的鼠标指针 */\n#pagination .page-number:hover{\n      cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/Alternative2.cur'),auto;\n}\n/* 悬停菜单栏时的鼠标指针 */\n#nav .site-page:hover{\n      cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/Alternative2.cur'),auto;\n}\n/* 播放器 */\n/* 总体 */\n.aplayer:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 歌单列表 */\n.aplayer-list li:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 歌曲封面 */\n.aplayer-pic:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 控制台 */\n.aplayer-body:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 按钮图标 */\n.aplayer-icon:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 信息栏 */\n.aplayer-info:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 列表数字标号 */\n.aplayer-list-index:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto;\n}\n/* 列表歌手名称 */\n.aplayer-list-author:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 控制台歌手信息 */\n.aplayer-author:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 控制台歌曲名称 */\n.aplayer-title:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 控制台歌曲信息背景 */\n.aplayer-music:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto !important;\n}\n/* 进度条 */\n.aplayer-bar-wrap div:hover, .aplayer-bar-wrap span:hover, .aplayer-bar-wrap svg:hover, .aplayer-bar-wrap path:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 音量条 */\n.aplayer-volume-bar-wrap:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto !important;\n}","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":"/* 全局默认鼠标指针 */\nbody,\nhtml, li:hover::before{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto !important;\n}\n/* 选择链接、标签、图片、按钮时的鼠标指针 */\na:hover, a#site-name:hover, img, button:hover, div#scroll-down:hover, i:hover{\n    cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 选中输入框时的鼠标指针 */\ninput:hover{\n    cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/texto.cur'),auto;\n}\n/* 悬停页脚链接标签（例如页脚徽标）时的鼠标指针 */\n#footer-wrap a:hover{\n      cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto;\n}\n/* 悬停页码时的鼠标指针 */\n#pagination .page-number:hover{\n      cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/Alternative2.cur'),auto;\n}\n/* 悬停菜单栏时的鼠标指针 */\n#nav .site-page:hover{\n      cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/Alternative2.cur'),auto;\n}\n/* 播放器 */\n/* 总体 */\n.aplayer:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 歌单列表 */\n.aplayer-list li:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 歌曲封面 */\n.aplayer-pic:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 控制台 */\n.aplayer-body:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 按钮图标 */\n.aplayer-icon:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 信息栏 */\n.aplayer-info:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 列表数字标号 */\n.aplayer-list-index:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto;\n}\n/* 列表歌手名称 */\n.aplayer-list-author:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 控制台歌手信息 */\n.aplayer-author:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 控制台歌曲名称 */\n.aplayer-title:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto;\n}\n/* 控制台歌曲信息背景 */\n.aplayer-music:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto !important;\n}\n/* 进度条 */\n.aplayer-bar-wrap div:hover, .aplayer-bar-wrap span:hover, .aplayer-bar-wrap svg:hover, .aplayer-bar-wrap path:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/link.cur'),auto !important;\n}\n/* 音量条 */\n.aplayer-volume-bar-wrap:hover{\n  cursor: url('https://cdn.jsdelivr.net/gh/EmptyDreams/resources/mouse/normal.cur'),auto !important;\n}"},{"_content":"/* 文章页H1-H6图标样式效果 */\nh1::before, h2::before, h3::before, h4::before, h5::before, h6::before {\n    -webkit-animation: ccc 1.6s linear infinite ;\n    animation: ccc 1.6s linear infinite ;\n}\n@-webkit-keyframes ccc {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg)\n    }\n    to {\n        -webkit-transform: rotate(-1turn);\n        transform: rotate(-1turn)\n    }\n}\n@keyframes ccc {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg)\n    }\n    to {\n        -webkit-transform: rotate(-1turn);\n        transform: rotate(-1turn)\n    }\n}\n\n#content-inner.layout h1::before {\n    color: #ef50a8 ;\n    margin-left: -1.55rem;\n    font-size: 1.45rem;\n    margin-top: -0.23rem;\n}\n#content-inner.layout h2::before {\n    color: #fb7061 ;\n    margin-left: -1.35rem;\n    font-size: 1.2rem;\n    margin-top: -0.12rem;\n}\n#content-inner.layout h3::before {\n    color: #ffbf00 ;\n    margin-left: -1.22rem;\n    font-size: 1.0rem;\n    margin-top: -0.09rem;\n}\n#content-inner.layout h4::before {\n    color: #a9e000 ;\n    margin-left: -1.05rem;\n    font-size: 0.85rem;\n    margin-top: -0.09rem;\n}\n#content-inner.layout h5::before {\n    color: #57c850 ;\n    margin-left: -0.9rem;\n    font-size: 0.7rem;\n    margin-top: 0.0rem;\n}\n#content-inner.layout h6::before {\n    color: #5ec1e0 ;\n    margin-left: -0.9rem;\n    font-size: 0.6rem;\n    margin-top: 0.0rem;\n}\n\n#content-inner.layout h1:hover, #content-inner.layout h2:hover, #content-inner.layout h3:hover, #content-inner.layout h4:hover, #content-inner.layout h5:hover, #content-inner.layout h6:hover {\n    color: #49b1f5 ;\n}","source":"self/pageIcon.css","raw":"/* 文章页H1-H6图标样式效果 */\nh1::before, h2::before, h3::before, h4::before, h5::before, h6::before {\n    -webkit-animation: ccc 1.6s linear infinite ;\n    animation: ccc 1.6s linear infinite ;\n}\n@-webkit-keyframes ccc {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg)\n    }\n    to {\n        -webkit-transform: rotate(-1turn);\n        transform: rotate(-1turn)\n    }\n}\n@keyframes ccc {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg)\n    }\n    to {\n        -webkit-transform: rotate(-1turn);\n        transform: rotate(-1turn)\n    }\n}\n\n#content-inner.layout h1::before {\n    color: #ef50a8 ;\n    margin-left: -1.55rem;\n    font-size: 1.45rem;\n    margin-top: -0.23rem;\n}\n#content-inner.layout h2::before {\n    color: #fb7061 ;\n    margin-left: -1.35rem;\n    font-size: 1.2rem;\n    margin-top: -0.12rem;\n}\n#content-inner.layout h3::before {\n    color: #ffbf00 ;\n    margin-left: -1.22rem;\n    font-size: 1.0rem;\n    margin-top: -0.09rem;\n}\n#content-inner.layout h4::before {\n    color: #a9e000 ;\n    margin-left: -1.05rem;\n    font-size: 0.85rem;\n    margin-top: -0.09rem;\n}\n#content-inner.layout h5::before {\n    color: #57c850 ;\n    margin-left: -0.9rem;\n    font-size: 0.7rem;\n    margin-top: 0.0rem;\n}\n#content-inner.layout h6::before {\n    color: #5ec1e0 ;\n    margin-left: -0.9rem;\n    font-size: 0.6rem;\n    margin-top: 0.0rem;\n}\n\n#content-inner.layout h1:hover, #content-inner.layout h2:hover, #content-inner.layout h3:hover, #content-inner.layout h4:hover, #content-inner.layout h5:hover, #content-inner.layout h6:hover {\n    color: #49b1f5 ;\n}","date":"2021-09-26T03:20:58.826Z","updated":"2021-09-25T13:18:29.718Z","path":"self/pageIcon.css","layout":"false","title":"","comments":1,"_id":"cku22zp3c000z7kwqfwu1fp0m","content":"/* 文章页H1-H6图标样式效果 */\nh1::before, h2::before, h3::before, h4::before, h5::before, h6::before {\n    -webkit-animation: ccc 1.6s linear infinite ;\n    animation: ccc 1.6s linear infinite ;\n}\n@-webkit-keyframes ccc {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg)\n    }\n    to {\n        -webkit-transform: rotate(-1turn);\n        transform: rotate(-1turn)\n    }\n}\n@keyframes ccc {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg)\n    }\n    to {\n        -webkit-transform: rotate(-1turn);\n        transform: rotate(-1turn)\n    }\n}\n\n#content-inner.layout h1::before {\n    color: #ef50a8 ;\n    margin-left: -1.55rem;\n    font-size: 1.45rem;\n    margin-top: -0.23rem;\n}\n#content-inner.layout h2::before {\n    color: #fb7061 ;\n    margin-left: -1.35rem;\n    font-size: 1.2rem;\n    margin-top: -0.12rem;\n}\n#content-inner.layout h3::before {\n    color: #ffbf00 ;\n    margin-left: -1.22rem;\n    font-size: 1.0rem;\n    margin-top: -0.09rem;\n}\n#content-inner.layout h4::before {\n    color: #a9e000 ;\n    margin-left: -1.05rem;\n    font-size: 0.85rem;\n    margin-top: -0.09rem;\n}\n#content-inner.layout h5::before {\n    color: #57c850 ;\n    margin-left: -0.9rem;\n    font-size: 0.7rem;\n    margin-top: 0.0rem;\n}\n#content-inner.layout h6::before {\n    color: #5ec1e0 ;\n    margin-left: -0.9rem;\n    font-size: 0.6rem;\n    margin-top: 0.0rem;\n}\n\n#content-inner.layout h1:hover, #content-inner.layout h2:hover, #content-inner.layout h3:hover, #content-inner.layout h4:hover, #content-inner.layout h5:hover, #content-inner.layout h6:hover {\n    color: #49b1f5 ;\n}","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":"/* 文章页H1-H6图标样式效果 */\nh1::before, h2::before, h3::before, h4::before, h5::before, h6::before {\n    -webkit-animation: ccc 1.6s linear infinite ;\n    animation: ccc 1.6s linear infinite ;\n}\n@-webkit-keyframes ccc {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg)\n    }\n    to {\n        -webkit-transform: rotate(-1turn);\n        transform: rotate(-1turn)\n    }\n}\n@keyframes ccc {\n    0% {\n        -webkit-transform: rotate(0deg);\n        transform: rotate(0deg)\n    }\n    to {\n        -webkit-transform: rotate(-1turn);\n        transform: rotate(-1turn)\n    }\n}\n\n#content-inner.layout h1::before {\n    color: #ef50a8 ;\n    margin-left: -1.55rem;\n    font-size: 1.45rem;\n    margin-top: -0.23rem;\n}\n#content-inner.layout h2::before {\n    color: #fb7061 ;\n    margin-left: -1.35rem;\n    font-size: 1.2rem;\n    margin-top: -0.12rem;\n}\n#content-inner.layout h3::before {\n    color: #ffbf00 ;\n    margin-left: -1.22rem;\n    font-size: 1.0rem;\n    margin-top: -0.09rem;\n}\n#content-inner.layout h4::before {\n    color: #a9e000 ;\n    margin-left: -1.05rem;\n    font-size: 0.85rem;\n    margin-top: -0.09rem;\n}\n#content-inner.layout h5::before {\n    color: #57c850 ;\n    margin-left: -0.9rem;\n    font-size: 0.7rem;\n    margin-top: 0.0rem;\n}\n#content-inner.layout h6::before {\n    color: #5ec1e0 ;\n    margin-left: -0.9rem;\n    font-size: 0.6rem;\n    margin-top: 0.0rem;\n}\n\n#content-inner.layout h1:hover, #content-inner.layout h2:hover, #content-inner.layout h3:hover, #content-inner.layout h4:hover, #content-inner.layout h5:hover, #content-inner.layout h6:hover {\n    color: #49b1f5 ;\n}"},{"_content":"/* 默认情况下缩进左侧66px，只留一点箭头部分 */\n.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {\n  left: -66px !important;\n}\n/* 鼠标点击时左侧缩进归零，完全显示按钮 */\n.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:click {\n  left: 0 !important;\n}\n\n/* 颜色配置 */\n/*歌单背景 */\n[data-theme=\"dark\"]\n  .aplayer{\n    background: rgba(43,43,43,0.85);\n  }\n/* 鼠标选取背景 */\n[data-theme=\"dark\"]\n  .aplayer-list li:hover{\n    background: rgba(55,55,55,0.85) !important;\n  }\n/* 正在播放的歌曲的背景 */\n[data-theme=\"dark\"]\n  .aplayer-list-light{\n    background:rgba(63,63,63,0.9) !important;\n  }\n/* 下方主体 */\n[data-theme=\"dark\"]\n  .aplayer-body{\n    background:rgba(33,33,33,0.85) !important;\n  }\n/* 伸缩按钮 */\n[data-theme=\"dark\"]\n  .aplayer-miniswitcher{\n    background:rgba(60,60,60,0.4) !important;\n  }\n/* 歌曲名称 */\n[data-theme=\"dark\"]\n  .aplayer-title{\n    color: #ffffff;\n  }\n[data-theme=\"dark\"]\n  .aplayer-list-title{\n    color: #c8c8c8;\n  }\n/* 歌手信息 */\n[data-theme=\"dark\"]\n  .aplayer-author{\n    color: #b3b3b3 !important;\n  }\n/* 列表歌手信息 */\n[data-theme=\"dark\"]\n  .aplayer-list-author{\n    color: #c8c8c8 !important;\n  }\n/* 列表序号 */\n[data-theme=\"dark\"]\n  .aplayer-list-index{\n    color: #dcdcdc !important;\n  }\n/* 封面透明度 */\n[data-theme=\"dark\"]\n  .aplayer-pic{\n    opacity: 1;\n  }\n/* 按钮填充 */\n[data-theme=\"dark\"]\n  .aplayer-icon path{\n    fill: rgba(203,203,205, 0.85) !important;\n  }\n/* 按钮选择 */\n[data-theme=\"dark\"]\n  .aplayer-icon:hover path{\n    fill: rgb(255,255,255) !important;\n  }\n/* 进度条-已播放 */\n[data-theme=\"dark\"]\n  .aplayer-played{\n    background: rgba(216,65,65,0.85) !important;\n  }\n/* 进度条-已加载 */\n[data-theme=\"dark\"]\n  .aplayer-loaded{\n    background: rgba(129,129,129,0.85) !important;\n  }\n/* 进度条-按钮 */\n[data-theme=\"dark\"]\n  .aplayer-thumb{\n    background: rgba(236,65,65,0.85) !important;\n  }","source":"self/player.css","raw":"/* 默认情况下缩进左侧66px，只留一点箭头部分 */\n.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {\n  left: -66px !important;\n}\n/* 鼠标点击时左侧缩进归零，完全显示按钮 */\n.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:click {\n  left: 0 !important;\n}\n\n/* 颜色配置 */\n/*歌单背景 */\n[data-theme=\"dark\"]\n  .aplayer{\n    background: rgba(43,43,43,0.85);\n  }\n/* 鼠标选取背景 */\n[data-theme=\"dark\"]\n  .aplayer-list li:hover{\n    background: rgba(55,55,55,0.85) !important;\n  }\n/* 正在播放的歌曲的背景 */\n[data-theme=\"dark\"]\n  .aplayer-list-light{\n    background:rgba(63,63,63,0.9) !important;\n  }\n/* 下方主体 */\n[data-theme=\"dark\"]\n  .aplayer-body{\n    background:rgba(33,33,33,0.85) !important;\n  }\n/* 伸缩按钮 */\n[data-theme=\"dark\"]\n  .aplayer-miniswitcher{\n    background:rgba(60,60,60,0.4) !important;\n  }\n/* 歌曲名称 */\n[data-theme=\"dark\"]\n  .aplayer-title{\n    color: #ffffff;\n  }\n[data-theme=\"dark\"]\n  .aplayer-list-title{\n    color: #c8c8c8;\n  }\n/* 歌手信息 */\n[data-theme=\"dark\"]\n  .aplayer-author{\n    color: #b3b3b3 !important;\n  }\n/* 列表歌手信息 */\n[data-theme=\"dark\"]\n  .aplayer-list-author{\n    color: #c8c8c8 !important;\n  }\n/* 列表序号 */\n[data-theme=\"dark\"]\n  .aplayer-list-index{\n    color: #dcdcdc !important;\n  }\n/* 封面透明度 */\n[data-theme=\"dark\"]\n  .aplayer-pic{\n    opacity: 1;\n  }\n/* 按钮填充 */\n[data-theme=\"dark\"]\n  .aplayer-icon path{\n    fill: rgba(203,203,205, 0.85) !important;\n  }\n/* 按钮选择 */\n[data-theme=\"dark\"]\n  .aplayer-icon:hover path{\n    fill: rgb(255,255,255) !important;\n  }\n/* 进度条-已播放 */\n[data-theme=\"dark\"]\n  .aplayer-played{\n    background: rgba(216,65,65,0.85) !important;\n  }\n/* 进度条-已加载 */\n[data-theme=\"dark\"]\n  .aplayer-loaded{\n    background: rgba(129,129,129,0.85) !important;\n  }\n/* 进度条-按钮 */\n[data-theme=\"dark\"]\n  .aplayer-thumb{\n    background: rgba(236,65,65,0.85) !important;\n  }","date":"2021-09-27T13:14:39.955Z","updated":"2021-09-27T13:14:39.955Z","path":"self/player.css","layout":"false","_id":"cku22zp3e00107kwq8gha0s5k","title":"","comments":1,"content":"/* 默认情况下缩进左侧66px，只留一点箭头部分 */\n.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {\n  left: -66px !important;\n}\n/* 鼠标点击时左侧缩进归零，完全显示按钮 */\n.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:click {\n  left: 0 !important;\n}\n\n/* 颜色配置 */\n/*歌单背景 */\n[data-theme=\"dark\"]\n  .aplayer{\n    background: rgba(43,43,43,0.85);\n  }\n/* 鼠标选取背景 */\n[data-theme=\"dark\"]\n  .aplayer-list li:hover{\n    background: rgba(55,55,55,0.85) !important;\n  }\n/* 正在播放的歌曲的背景 */\n[data-theme=\"dark\"]\n  .aplayer-list-light{\n    background:rgba(63,63,63,0.9) !important;\n  }\n/* 下方主体 */\n[data-theme=\"dark\"]\n  .aplayer-body{\n    background:rgba(33,33,33,0.85) !important;\n  }\n/* 伸缩按钮 */\n[data-theme=\"dark\"]\n  .aplayer-miniswitcher{\n    background:rgba(60,60,60,0.4) !important;\n  }\n/* 歌曲名称 */\n[data-theme=\"dark\"]\n  .aplayer-title{\n    color: #ffffff;\n  }\n[data-theme=\"dark\"]\n  .aplayer-list-title{\n    color: #c8c8c8;\n  }\n/* 歌手信息 */\n[data-theme=\"dark\"]\n  .aplayer-author{\n    color: #b3b3b3 !important;\n  }\n/* 列表歌手信息 */\n[data-theme=\"dark\"]\n  .aplayer-list-author{\n    color: #c8c8c8 !important;\n  }\n/* 列表序号 */\n[data-theme=\"dark\"]\n  .aplayer-list-index{\n    color: #dcdcdc !important;\n  }\n/* 封面透明度 */\n[data-theme=\"dark\"]\n  .aplayer-pic{\n    opacity: 1;\n  }\n/* 按钮填充 */\n[data-theme=\"dark\"]\n  .aplayer-icon path{\n    fill: rgba(203,203,205, 0.85) !important;\n  }\n/* 按钮选择 */\n[data-theme=\"dark\"]\n  .aplayer-icon:hover path{\n    fill: rgb(255,255,255) !important;\n  }\n/* 进度条-已播放 */\n[data-theme=\"dark\"]\n  .aplayer-played{\n    background: rgba(216,65,65,0.85) !important;\n  }\n/* 进度条-已加载 */\n[data-theme=\"dark\"]\n  .aplayer-loaded{\n    background: rgba(129,129,129,0.85) !important;\n  }\n/* 进度条-按钮 */\n[data-theme=\"dark\"]\n  .aplayer-thumb{\n    background: rgba(236,65,65,0.85) !important;\n  }","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":"/* 默认情况下缩进左侧66px，只留一点箭头部分 */\n.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {\n  left: -66px !important;\n}\n/* 鼠标点击时左侧缩进归零，完全显示按钮 */\n.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:click {\n  left: 0 !important;\n}\n\n/* 颜色配置 */\n/*歌单背景 */\n[data-theme=\"dark\"]\n  .aplayer{\n    background: rgba(43,43,43,0.85);\n  }\n/* 鼠标选取背景 */\n[data-theme=\"dark\"]\n  .aplayer-list li:hover{\n    background: rgba(55,55,55,0.85) !important;\n  }\n/* 正在播放的歌曲的背景 */\n[data-theme=\"dark\"]\n  .aplayer-list-light{\n    background:rgba(63,63,63,0.9) !important;\n  }\n/* 下方主体 */\n[data-theme=\"dark\"]\n  .aplayer-body{\n    background:rgba(33,33,33,0.85) !important;\n  }\n/* 伸缩按钮 */\n[data-theme=\"dark\"]\n  .aplayer-miniswitcher{\n    background:rgba(60,60,60,0.4) !important;\n  }\n/* 歌曲名称 */\n[data-theme=\"dark\"]\n  .aplayer-title{\n    color: #ffffff;\n  }\n[data-theme=\"dark\"]\n  .aplayer-list-title{\n    color: #c8c8c8;\n  }\n/* 歌手信息 */\n[data-theme=\"dark\"]\n  .aplayer-author{\n    color: #b3b3b3 !important;\n  }\n/* 列表歌手信息 */\n[data-theme=\"dark\"]\n  .aplayer-list-author{\n    color: #c8c8c8 !important;\n  }\n/* 列表序号 */\n[data-theme=\"dark\"]\n  .aplayer-list-index{\n    color: #dcdcdc !important;\n  }\n/* 封面透明度 */\n[data-theme=\"dark\"]\n  .aplayer-pic{\n    opacity: 1;\n  }\n/* 按钮填充 */\n[data-theme=\"dark\"]\n  .aplayer-icon path{\n    fill: rgba(203,203,205, 0.85) !important;\n  }\n/* 按钮选择 */\n[data-theme=\"dark\"]\n  .aplayer-icon:hover path{\n    fill: rgb(255,255,255) !important;\n  }\n/* 进度条-已播放 */\n[data-theme=\"dark\"]\n  .aplayer-played{\n    background: rgba(216,65,65,0.85) !important;\n  }\n/* 进度条-已加载 */\n[data-theme=\"dark\"]\n  .aplayer-loaded{\n    background: rgba(129,129,129,0.85) !important;\n  }\n/* 进度条-按钮 */\n[data-theme=\"dark\"]\n  .aplayer-thumb{\n    background: rgba(236,65,65,0.85) !important;\n  }"},{"_content":"/*10s为加载动画的时间，1为加载动画的次数，ease-in-out为动画效果*/\n#page-header,\n#web_bg {\n    -webkit-animation: imgblur 2s 1 ease-in-out;\n    animation: imgblur 2s 1 ease-in-out;\n}\n@keyframes imgblur {\n  0% {\n    filter: blur(5px);\n  }\n  100% {\n    filter: blur(0px);\n  }\n}\n/*适配使用-webkit内核的浏览器 */\n@-webkit-keyframes imgblur {\n  0% {\n    -webkit-filter: blur(5px);\n  }\n  100% {\n    -webkit-filter: blur(0px);\n  }\n}","source":"self/topFilter.css","raw":"/*10s为加载动画的时间，1为加载动画的次数，ease-in-out为动画效果*/\n#page-header,\n#web_bg {\n    -webkit-animation: imgblur 2s 1 ease-in-out;\n    animation: imgblur 2s 1 ease-in-out;\n}\n@keyframes imgblur {\n  0% {\n    filter: blur(5px);\n  }\n  100% {\n    filter: blur(0px);\n  }\n}\n/*适配使用-webkit内核的浏览器 */\n@-webkit-keyframes imgblur {\n  0% {\n    -webkit-filter: blur(5px);\n  }\n  100% {\n    -webkit-filter: blur(0px);\n  }\n}","date":"2021-09-26T03:23:40.465Z","updated":"2021-09-25T13:18:29.718Z","path":"self/topFilter.css","layout":"false","title":"","comments":1,"_id":"cku22zp3g00147kwq5lhfcdtz","content":"/*10s为加载动画的时间，1为加载动画的次数，ease-in-out为动画效果*/\n#page-header,\n#web_bg {\n    -webkit-animation: imgblur 2s 1 ease-in-out;\n    animation: imgblur 2s 1 ease-in-out;\n}\n@keyframes imgblur {\n  0% {\n    filter: blur(5px);\n  }\n  100% {\n    filter: blur(0px);\n  }\n}\n/*适配使用-webkit内核的浏览器 */\n@-webkit-keyframes imgblur {\n  0% {\n    -webkit-filter: blur(5px);\n  }\n  100% {\n    -webkit-filter: blur(0px);\n  }\n}","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":"/*10s为加载动画的时间，1为加载动画的次数，ease-in-out为动画效果*/\n#page-header,\n#web_bg {\n    -webkit-animation: imgblur 2s 1 ease-in-out;\n    animation: imgblur 2s 1 ease-in-out;\n}\n@keyframes imgblur {\n  0% {\n    filter: blur(5px);\n  }\n  100% {\n    filter: blur(0px);\n  }\n}\n/*适配使用-webkit内核的浏览器 */\n@-webkit-keyframes imgblur {\n  0% {\n    -webkit-filter: blur(5px);\n  }\n  100% {\n    -webkit-filter: blur(0px);\n  }\n}"},{"title":"标签","date":"2020-04-10T13:09:21.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-04-10 21:09:21\ntype: \"tags\"\n---\n","updated":"2021-09-25T13:18:29.719Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cku22zp3h00167kwqb0ns8p64","content":"","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/b0.png","excerpt":"","more":""},{"title":"多年苦心搜罗的小姐姐","date":"2021-09-29T10:12:55.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b10.jpeg","_content":"\n\n\n# 新的小姐姐\n\n{@newImage@}\n\n\n\n# 陈年老姐\n\n{@oldImage@}\n\n","source":"image/favorites.md","raw":"---\ntitle: 多年苦心搜罗的小姐姐\ndate: 2021-09-29 18:12:55\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b10.jpeg\n---\n\n\n\n# 新的小姐姐\n\n{@newImage@}\n\n\n\n# 陈年老姐\n\n{@oldImage@}\n\n","updated":"2021-09-29T10:15:39.696Z","path":"image/favorites.html","comments":1,"layout":"page","_id":"cku5ic76300000wwqgt0o8dij","content":"<h1 id=\"新的小姐姐\"><a href=\"#新的小姐姐\" class=\"headerlink\" title=\"新的小姐姐\"></a>新的小姐姐</h1><p>{@newImage@}</p>\n<h1 id=\"陈年老姐\"><a href=\"#陈年老姐\" class=\"headerlink\" title=\"陈年老姐\"></a>陈年老姐</h1><p>{@oldImage@}</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"}]}]}},"excerpt":"","more":"<h1 id=\"新的小姐姐\"><a href=\"#新的小姐姐\" class=\"headerlink\" title=\"新的小姐姐\"></a>新的小姐姐</h1><p>{@newImage@}</p>\n<h1 id=\"陈年老姐\"><a href=\"#陈年老姐\" class=\"headerlink\" title=\"陈年老姐\"></a>陈年老姐</h1><p>{@oldImage@}</p>\n"}],"Post":[{"title":"个人对局部内部类的一些理解","date":"2020-01-15T12:31:38.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b0.png","description":"有关局部内部类访问局部变量的限制的简单解释","_content":"\n&emsp;&emsp;很多人对于局部内部类访问局部变量的限制有些疑惑，这里我就简单的解答以下。\n\n# 什么是局部内部类\n\n&emsp;&emsp;和局部变量类似，局部内部类指的就是在方法体中声明的类，包括匿名内部类和非匿名内部类，例如以下代码中的“A”、“new Object(){}”、“lambda表达式” 都是局部内部类：（以下简称内部类）\n``` java\npublic class Test {\n\tpublic void run() {\n\t\tclass A { }\n\t\tnew Object() { };\n\t\tList<?> list = new ArrayList<>();\n\t\tlist.forEach(System.out::println);\n\t}\n}\n```\n\n# 内部类的限制\n\n&emsp;&emsp;很多人都知道的的一个内部类的使用限制就是不能修改局部变量，比如下面这段代码就是错误的：\n```java\n//代码块 A1\npublic void run() {\n\tint k = 0;\n\tnew Object() {\n\t\t{\n\t\t\tSystem.out.println(k);\n\t\t\tk = 1;\n\t\t}\n\t};\n}\n```\n&emsp;&emsp;编译器会毫不客气的抛出==Variable 'k' is accessed from within inner class, needs to be final or effectively final==。\n&emsp;&emsp;显而易见，错误的原因是k没有被final修饰，那到底时什么原因导致内部类不能修改局部变量呢？同时需要注意的是导致编译错误的是“k = 1”而非“println(k)”。\n\n# 其他人的见解\n\n## 初始化问题\n&emsp;&emsp;这个问题我曾经请教过其它人，得到的回复是：\n\n> &emsp;&emsp;我认为是因为在创建内部类的时候局部变量没有得到初始化，即值是不确定的，所以导致编译错误。\n\n&emsp;&emsp;但是我很快否定了这个说法，因为这样的说法无法解释“println(k)”这样子的代码可以通过编译。\n\n## 高深解法\n&emsp;&emsp;网上有很多关于这个问题的“高深解法”，[比如这里](https://blog.csdn.net/dazhaoDai/article/details/83097017)，但是这些说辞不适用于新手或者是水平还没有达到相对应的地点的人，这里我就引用一部分内容，后文中我将围绕这一小部分内容在代码层面进行讲解：\n\n> &emsp;&emsp;内部类并不是直接使用传递进来的参数，而是将传递进来的参数通过自己的构造器备份到自己内部，表面看是同一个变量，实际调用的是自己的属性而不是外部类方法的参数，如果在内部类中，修改了这些参数，并不会对外部变量产生影响，仅仅改变局部内部类中备份的参数。但是在外部调用时发现值并没有被修改，这种问题就会很尴尬，造成数据不同步。所以使用final避免数据不同步的问题。\n————————————————\n版权声明：本文为CSDN博主「T9的第三个三角」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/dazhaoDai/article/details/83097017\n\n# 个人讲解\n\n&emsp;&emsp;上面这段话对于一部分人可能仍然很难理解，不要担心，下面这些内容会对这一段话进行展开。\n&emsp;&emsp;上文中说内部类中引用外部局部变量是一个拷贝，这句话可以用下面的代码理解：\n```java\n//代码块 A2 | 实际与A1相同\npublic void run() {\n\tint k = 0;\n\tnew Object() {\n\t\t//final int k = k;\n\t\t{\n\t\t\tSystem.out.println(k);\n\t\t\tk = 1;\n\t\t}\n\t}\n}\n```\n&emsp;&emsp;这样子就可以比较直观的理解“拷贝”的含义，注释掉的代码可以理解成一个隐式声明。相当于编译器为你自动复制了可访问的局部变量的值。\n&emsp;&emsp;那这个声明为什么不能更改呢？这就涉及到了上文中提到的同步问题，如果你在内部类中修改了这个值，你修改的是复制后的值，在内部类的外部根部无法观测到这个改变，如果编译器允许你的更改，那就容易造成一个不太容易发现的BUG：我明明修改了这个值，为什么它没有变化？为了彻底避免这个问题，所以就干脆让这个声明是不可以修改的了。\n\n# 深度理解“复制”\n&emsp;&emsp;这里说的复制是什么意思呢？在了解复制前我们要首先了解我们是怎么访问对象的：\n```java\nObject o = new Object();\nObject o2 = new Object();\nSystem.out.println(\"o == o2 is \" + o == o2);\t//false\no = o2;\nSystem.out.println(\"o == o2 is \" + o == o2);\t//true\n```\n&emsp;&emsp;这段代码的输出结果代表了什么？在修改\"o\"的值后\"o\"与\"o2\"的地址是一样的，也就是说\"o = o2\"并没有触发深度复制，而是知识简单的让\"o\"也指向了\"o2\"所指向的值。\n&emsp;&emsp;显而易见，\"o\"和\"o2\"并没有直接存储一个对象，我们可以简单的认为存储的对象的地址（实际上没有这么简单，具体方法略微有些复杂，读者可以自行查阅资料），\"o = o2\"这个语句就是将\"o2\"指向的对象的地址复制给\"o\"，这时候修改两者中的任意一个，另一个也会收到影响。\n&emsp;&emsp;同样，编译器为我们复制变量的时候也没有进行深度复制，而是进行简单的复制，这个特性我们下文中会再说到。\n\n# 修改外部值的方法\n\n## 1.把这个值变成全局变量：\n&emsp;&emsp;这样子就可以随意更改，但是并不建议这么做因为这样子写不但性能不高，还容易让代码变得晦涩难懂。\n## 2.将要修改的量声明为数组：\n&emsp;&emsp;细心的小伙伴写代码的时候可能会发现下面的情况：\n```java\nnew ArrayList<int[]>();\t  //right\nnew ArrayList<int>();\t\t//error\n```\n&emsp;&emsp;第一行代码可以通过编译而第二行不可以，具体原因这里不再解释，读者只要明白int和int[]的区别就可以了。在Java中int是基本类型，但是int[]并不是，可以当作对象处理，所以int[]也可以当作泛型的参数。\n&emsp;&emsp;知道这个有什么用呢？很简单，被final修饰的数组虽然我们不能再修改它的地址，但是我们可以修改数组中存储的数据，比如说我们可以写出来下面的代码：\n```java\npublic void run() {\n\tfinal int[] k = { 0 };\n\tnew Object() {\n\t\t{ k[0] = 1; }\n\t};\n}\n```\n## 3.使用类存储数据：\n&emsp;&emsp;第二种方法看起来很正确，但是很容易混淆代码的意图，我们同样根据复制的原理，将值存在一个类中，然后我们通过这个类访问值即可进行修改：\n```java\npublic void run() {\n\tfinal AtomicInteger k = new AtomicInteger(0);\n\tnew Object() {\n\t\t{ k.set(1); }\n\t};\n}\n```","source":"_posts/LocalInnerClass.md","raw":"---\ntitle: 个人对局部内部类的一些理解\ndate: 2020-01-15 20:31:38\ncategories:\n\t- Java\ntags: \n\t- 类\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b0.png\ndescription: 有关局部内部类访问局部变量的限制的简单解释\n---\n\n&emsp;&emsp;很多人对于局部内部类访问局部变量的限制有些疑惑，这里我就简单的解答以下。\n\n# 什么是局部内部类\n\n&emsp;&emsp;和局部变量类似，局部内部类指的就是在方法体中声明的类，包括匿名内部类和非匿名内部类，例如以下代码中的“A”、“new Object(){}”、“lambda表达式” 都是局部内部类：（以下简称内部类）\n``` java\npublic class Test {\n\tpublic void run() {\n\t\tclass A { }\n\t\tnew Object() { };\n\t\tList<?> list = new ArrayList<>();\n\t\tlist.forEach(System.out::println);\n\t}\n}\n```\n\n# 内部类的限制\n\n&emsp;&emsp;很多人都知道的的一个内部类的使用限制就是不能修改局部变量，比如下面这段代码就是错误的：\n```java\n//代码块 A1\npublic void run() {\n\tint k = 0;\n\tnew Object() {\n\t\t{\n\t\t\tSystem.out.println(k);\n\t\t\tk = 1;\n\t\t}\n\t};\n}\n```\n&emsp;&emsp;编译器会毫不客气的抛出==Variable 'k' is accessed from within inner class, needs to be final or effectively final==。\n&emsp;&emsp;显而易见，错误的原因是k没有被final修饰，那到底时什么原因导致内部类不能修改局部变量呢？同时需要注意的是导致编译错误的是“k = 1”而非“println(k)”。\n\n# 其他人的见解\n\n## 初始化问题\n&emsp;&emsp;这个问题我曾经请教过其它人，得到的回复是：\n\n> &emsp;&emsp;我认为是因为在创建内部类的时候局部变量没有得到初始化，即值是不确定的，所以导致编译错误。\n\n&emsp;&emsp;但是我很快否定了这个说法，因为这样的说法无法解释“println(k)”这样子的代码可以通过编译。\n\n## 高深解法\n&emsp;&emsp;网上有很多关于这个问题的“高深解法”，[比如这里](https://blog.csdn.net/dazhaoDai/article/details/83097017)，但是这些说辞不适用于新手或者是水平还没有达到相对应的地点的人，这里我就引用一部分内容，后文中我将围绕这一小部分内容在代码层面进行讲解：\n\n> &emsp;&emsp;内部类并不是直接使用传递进来的参数，而是将传递进来的参数通过自己的构造器备份到自己内部，表面看是同一个变量，实际调用的是自己的属性而不是外部类方法的参数，如果在内部类中，修改了这些参数，并不会对外部变量产生影响，仅仅改变局部内部类中备份的参数。但是在外部调用时发现值并没有被修改，这种问题就会很尴尬，造成数据不同步。所以使用final避免数据不同步的问题。\n————————————————\n版权声明：本文为CSDN博主「T9的第三个三角」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/dazhaoDai/article/details/83097017\n\n# 个人讲解\n\n&emsp;&emsp;上面这段话对于一部分人可能仍然很难理解，不要担心，下面这些内容会对这一段话进行展开。\n&emsp;&emsp;上文中说内部类中引用外部局部变量是一个拷贝，这句话可以用下面的代码理解：\n```java\n//代码块 A2 | 实际与A1相同\npublic void run() {\n\tint k = 0;\n\tnew Object() {\n\t\t//final int k = k;\n\t\t{\n\t\t\tSystem.out.println(k);\n\t\t\tk = 1;\n\t\t}\n\t}\n}\n```\n&emsp;&emsp;这样子就可以比较直观的理解“拷贝”的含义，注释掉的代码可以理解成一个隐式声明。相当于编译器为你自动复制了可访问的局部变量的值。\n&emsp;&emsp;那这个声明为什么不能更改呢？这就涉及到了上文中提到的同步问题，如果你在内部类中修改了这个值，你修改的是复制后的值，在内部类的外部根部无法观测到这个改变，如果编译器允许你的更改，那就容易造成一个不太容易发现的BUG：我明明修改了这个值，为什么它没有变化？为了彻底避免这个问题，所以就干脆让这个声明是不可以修改的了。\n\n# 深度理解“复制”\n&emsp;&emsp;这里说的复制是什么意思呢？在了解复制前我们要首先了解我们是怎么访问对象的：\n```java\nObject o = new Object();\nObject o2 = new Object();\nSystem.out.println(\"o == o2 is \" + o == o2);\t//false\no = o2;\nSystem.out.println(\"o == o2 is \" + o == o2);\t//true\n```\n&emsp;&emsp;这段代码的输出结果代表了什么？在修改\"o\"的值后\"o\"与\"o2\"的地址是一样的，也就是说\"o = o2\"并没有触发深度复制，而是知识简单的让\"o\"也指向了\"o2\"所指向的值。\n&emsp;&emsp;显而易见，\"o\"和\"o2\"并没有直接存储一个对象，我们可以简单的认为存储的对象的地址（实际上没有这么简单，具体方法略微有些复杂，读者可以自行查阅资料），\"o = o2\"这个语句就是将\"o2\"指向的对象的地址复制给\"o\"，这时候修改两者中的任意一个，另一个也会收到影响。\n&emsp;&emsp;同样，编译器为我们复制变量的时候也没有进行深度复制，而是进行简单的复制，这个特性我们下文中会再说到。\n\n# 修改外部值的方法\n\n## 1.把这个值变成全局变量：\n&emsp;&emsp;这样子就可以随意更改，但是并不建议这么做因为这样子写不但性能不高，还容易让代码变得晦涩难懂。\n## 2.将要修改的量声明为数组：\n&emsp;&emsp;细心的小伙伴写代码的时候可能会发现下面的情况：\n```java\nnew ArrayList<int[]>();\t  //right\nnew ArrayList<int>();\t\t//error\n```\n&emsp;&emsp;第一行代码可以通过编译而第二行不可以，具体原因这里不再解释，读者只要明白int和int[]的区别就可以了。在Java中int是基本类型，但是int[]并不是，可以当作对象处理，所以int[]也可以当作泛型的参数。\n&emsp;&emsp;知道这个有什么用呢？很简单，被final修饰的数组虽然我们不能再修改它的地址，但是我们可以修改数组中存储的数据，比如说我们可以写出来下面的代码：\n```java\npublic void run() {\n\tfinal int[] k = { 0 };\n\tnew Object() {\n\t\t{ k[0] = 1; }\n\t};\n}\n```\n## 3.使用类存储数据：\n&emsp;&emsp;第二种方法看起来很正确，但是很容易混淆代码的意图，我们同样根据复制的原理，将值存在一个类中，然后我们通过这个类访问值即可进行修改：\n```java\npublic void run() {\n\tfinal AtomicInteger k = new AtomicInteger(0);\n\tnew Object() {\n\t\t{ k.set(1); }\n\t};\n}\n```","slug":"LocalInnerClass","published":1,"updated":"2021-09-27T13:18:01.547Z","_id":"cku22zp2p00017kwqei1o83bq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>&emsp;&emsp;很多人对于局部内部类访问局部变量的限制有些疑惑，这里我就简单的解答以下。</p>\n<h1 id=\"什么是局部内部类\"><a href=\"#什么是局部内部类\" class=\"headerlink\" title=\"什么是局部内部类\"></a>什么是局部内部类</h1><p>&emsp;&emsp;和局部变量类似，局部内部类指的就是在方法体中声明的类，包括匿名内部类和非匿名内部类，例如以下代码中的“A”、“new Object(){}”、“lambda表达式” 都是局部内部类：（以下简称内部类）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> </span>&#123; &#125;<br>\t\t<span class=\"hljs-keyword\">new</span> Object() &#123; &#125;;<br>\t\tList&lt;?&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>\t\tlist.forEach(System.out::println);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"内部类的限制\"><a href=\"#内部类的限制\" class=\"headerlink\" title=\"内部类的限制\"></a>内部类的限制</h1><p>&emsp;&emsp;很多人都知道的的一个内部类的使用限制就是不能修改局部变量，比如下面这段代码就是错误的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//代码块 A1</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">new</span> Object() &#123;<br>\t\t&#123;<br>\t\t\tSystem.out.println(k);<br>\t\t\tk = <span class=\"hljs-number\">1</span>;<br>\t\t&#125;<br>\t&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;编译器会毫不客气的抛出==Variable ‘k’ is accessed from within inner class, needs to be final or effectively final==。<br>&emsp;&emsp;显而易见，错误的原因是k没有被final修饰，那到底时什么原因导致内部类不能修改局部变量呢？同时需要注意的是导致编译错误的是“k = 1”而非“println(k)”。</p>\n<h1 id=\"其他人的见解\"><a href=\"#其他人的见解\" class=\"headerlink\" title=\"其他人的见解\"></a>其他人的见解</h1><h2 id=\"初始化问题\"><a href=\"#初始化问题\" class=\"headerlink\" title=\"初始化问题\"></a>初始化问题</h2><p>&emsp;&emsp;这个问题我曾经请教过其它人，得到的回复是：</p>\n<blockquote>\n<p>&emsp;&emsp;我认为是因为在创建内部类的时候局部变量没有得到初始化，即值是不确定的，所以导致编译错误。</p>\n</blockquote>\n<p>&emsp;&emsp;但是我很快否定了这个说法，因为这样的说法无法解释“println(k)”这样子的代码可以通过编译。</p>\n<h2 id=\"高深解法\"><a href=\"#高深解法\" class=\"headerlink\" title=\"高深解法\"></a>高深解法</h2><p>&emsp;&emsp;网上有很多关于这个问题的“高深解法”，<a href=\"https://blog.csdn.net/dazhaoDai/article/details/83097017\">比如这里</a>，但是这些说辞不适用于新手或者是水平还没有达到相对应的地点的人，这里我就引用一部分内容，后文中我将围绕这一小部分内容在代码层面进行讲解：</p>\n<blockquote>\n<p>&emsp;&emsp;内部类并不是直接使用传递进来的参数，而是将传递进来的参数通过自己的构造器备份到自己内部，表面看是同一个变量，实际调用的是自己的属性而不是外部类方法的参数，如果在内部类中，修改了这些参数，并不会对外部变量产生影响，仅仅改变局部内部类中备份的参数。但是在外部调用时发现值并没有被修改，这种问题就会很尴尬，造成数据不同步。所以使用final避免数据不同步的问题。<br>————————————————<br>版权声明：本文为CSDN博主「T9的第三个三角」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/dazhaoDai/article/details/83097017\">https://blog.csdn.net/dazhaoDai/article/details/83097017</a></p>\n</blockquote>\n<h1 id=\"个人讲解\"><a href=\"#个人讲解\" class=\"headerlink\" title=\"个人讲解\"></a>个人讲解</h1><p>&emsp;&emsp;上面这段话对于一部分人可能仍然很难理解，不要担心，下面这些内容会对这一段话进行展开。<br>&emsp;&emsp;上文中说内部类中引用外部局部变量是一个拷贝，这句话可以用下面的代码理解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//代码块 A2 | 实际与A1相同</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">new</span> Object() &#123;<br>\t\t<span class=\"hljs-comment\">//final int k = k;</span><br>\t\t&#123;<br>\t\t\tSystem.out.println(k);<br>\t\t\tk = <span class=\"hljs-number\">1</span>;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这样子就可以比较直观的理解“拷贝”的含义，注释掉的代码可以理解成一个隐式声明。相当于编译器为你自动复制了可访问的局部变量的值。<br>&emsp;&emsp;那这个声明为什么不能更改呢？这就涉及到了上文中提到的同步问题，如果你在内部类中修改了这个值，你修改的是复制后的值，在内部类的外部根部无法观测到这个改变，如果编译器允许你的更改，那就容易造成一个不太容易发现的BUG：我明明修改了这个值，为什么它没有变化？为了彻底避免这个问题，所以就干脆让这个声明是不可以修改的了。</p>\n<h1 id=\"深度理解“复制”\"><a href=\"#深度理解“复制”\" class=\"headerlink\" title=\"深度理解“复制”\"></a>深度理解“复制”</h1><p>&emsp;&emsp;这里说的复制是什么意思呢？在了解复制前我们要首先了解我们是怎么访问对象的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Object o = <span class=\"hljs-keyword\">new</span> Object();<br>Object o2 = <span class=\"hljs-keyword\">new</span> Object();<br>System.out.println(<span class=\"hljs-string\">&quot;o == o2 is &quot;</span> + o == o2);\t<span class=\"hljs-comment\">//false</span><br>o = o2;<br>System.out.println(<span class=\"hljs-string\">&quot;o == o2 is &quot;</span> + o == o2);\t<span class=\"hljs-comment\">//true</span><br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这段代码的输出结果代表了什么？在修改”o”的值后”o”与”o2”的地址是一样的，也就是说”o = o2”并没有触发深度复制，而是知识简单的让”o”也指向了”o2”所指向的值。<br>&emsp;&emsp;显而易见，”o”和”o2”并没有直接存储一个对象，我们可以简单的认为存储的对象的地址（实际上没有这么简单，具体方法略微有些复杂，读者可以自行查阅资料），”o = o2”这个语句就是将”o2”指向的对象的地址复制给”o”，这时候修改两者中的任意一个，另一个也会收到影响。<br>&emsp;&emsp;同样，编译器为我们复制变量的时候也没有进行深度复制，而是进行简单的复制，这个特性我们下文中会再说到。</p>\n<h1 id=\"修改外部值的方法\"><a href=\"#修改外部值的方法\" class=\"headerlink\" title=\"修改外部值的方法\"></a>修改外部值的方法</h1><h2 id=\"1-把这个值变成全局变量：\"><a href=\"#1-把这个值变成全局变量：\" class=\"headerlink\" title=\"1.把这个值变成全局变量：\"></a>1.把这个值变成全局变量：</h2><p>&emsp;&emsp;这样子就可以随意更改，但是并不建议这么做因为这样子写不但性能不高，还容易让代码变得晦涩难懂。</p>\n<h2 id=\"2-将要修改的量声明为数组：\"><a href=\"#2-将要修改的量声明为数组：\" class=\"headerlink\" title=\"2.将要修改的量声明为数组：\"></a>2.将要修改的量声明为数组：</h2><p>&emsp;&emsp;细心的小伙伴写代码的时候可能会发现下面的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">new</span> ArrayList&lt;<span class=\"hljs-keyword\">int</span>[]&gt;();\t  <span class=\"hljs-comment\">//right</span><br><span class=\"hljs-keyword\">new</span> ArrayList&lt;<span class=\"hljs-keyword\">int</span>&gt;();\t\t<span class=\"hljs-comment\">//error</span><br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;第一行代码可以通过编译而第二行不可以，具体原因这里不再解释，读者只要明白int和int[]的区别就可以了。在Java中int是基本类型，但是int[]并不是，可以当作对象处理，所以int[]也可以当作泛型的参数。<br>&emsp;&emsp;知道这个有什么用呢？很简单，被final修饰的数组虽然我们不能再修改它的地址，但是我们可以修改数组中存储的数据，比如说我们可以写出来下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span>[] k = &#123; <span class=\"hljs-number\">0</span> &#125;;<br>\t<span class=\"hljs-keyword\">new</span> Object() &#123;<br>\t\t&#123; k[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>; &#125;<br>\t&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-使用类存储数据：\"><a href=\"#3-使用类存储数据：\" class=\"headerlink\" title=\"3.使用类存储数据：\"></a>3.使用类存储数据：</h2><p>&emsp;&emsp;第二种方法看起来很正确，但是很容易混淆代码的意图，我们同样根据复制的原理，将值存在一个类中，然后我们通过这个类访问值即可进行修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">final</span> AtomicInteger k = <span class=\"hljs-keyword\">new</span> AtomicInteger(<span class=\"hljs-number\">0</span>);<br>\t<span class=\"hljs-keyword\">new</span> Object() &#123;<br>\t\t&#123; k.set(<span class=\"hljs-number\">1</span>); &#125;<br>\t&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"excerpt":"","more":"<p>&emsp;&emsp;很多人对于局部内部类访问局部变量的限制有些疑惑，这里我就简单的解答以下。</p>\n<h1 id=\"什么是局部内部类\"><a href=\"#什么是局部内部类\" class=\"headerlink\" title=\"什么是局部内部类\"></a>什么是局部内部类</h1><p>&emsp;&emsp;和局部变量类似，局部内部类指的就是在方法体中声明的类，包括匿名内部类和非匿名内部类，例如以下代码中的“A”、“new Object(){}”、“lambda表达式” 都是局部内部类：（以下简称内部类）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Test</span> </span>&#123;<br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">A</span> </span>&#123; &#125;<br>\t\t<span class=\"hljs-keyword\">new</span> Object() &#123; &#125;;<br>\t\tList&lt;?&gt; list = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();<br>\t\tlist.forEach(System.out::println);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"内部类的限制\"><a href=\"#内部类的限制\" class=\"headerlink\" title=\"内部类的限制\"></a>内部类的限制</h1><p>&emsp;&emsp;很多人都知道的的一个内部类的使用限制就是不能修改局部变量，比如下面这段代码就是错误的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//代码块 A1</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">new</span> Object() &#123;<br>\t\t&#123;<br>\t\t\tSystem.out.println(k);<br>\t\t\tk = <span class=\"hljs-number\">1</span>;<br>\t\t&#125;<br>\t&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;编译器会毫不客气的抛出==Variable ‘k’ is accessed from within inner class, needs to be final or effectively final==。<br>&emsp;&emsp;显而易见，错误的原因是k没有被final修饰，那到底时什么原因导致内部类不能修改局部变量呢？同时需要注意的是导致编译错误的是“k = 1”而非“println(k)”。</p>\n<h1 id=\"其他人的见解\"><a href=\"#其他人的见解\" class=\"headerlink\" title=\"其他人的见解\"></a>其他人的见解</h1><h2 id=\"初始化问题\"><a href=\"#初始化问题\" class=\"headerlink\" title=\"初始化问题\"></a>初始化问题</h2><p>&emsp;&emsp;这个问题我曾经请教过其它人，得到的回复是：</p>\n<blockquote>\n<p>&emsp;&emsp;我认为是因为在创建内部类的时候局部变量没有得到初始化，即值是不确定的，所以导致编译错误。</p>\n</blockquote>\n<p>&emsp;&emsp;但是我很快否定了这个说法，因为这样的说法无法解释“println(k)”这样子的代码可以通过编译。</p>\n<h2 id=\"高深解法\"><a href=\"#高深解法\" class=\"headerlink\" title=\"高深解法\"></a>高深解法</h2><p>&emsp;&emsp;网上有很多关于这个问题的“高深解法”，<a href=\"https://blog.csdn.net/dazhaoDai/article/details/83097017\">比如这里</a>，但是这些说辞不适用于新手或者是水平还没有达到相对应的地点的人，这里我就引用一部分内容，后文中我将围绕这一小部分内容在代码层面进行讲解：</p>\n<blockquote>\n<p>&emsp;&emsp;内部类并不是直接使用传递进来的参数，而是将传递进来的参数通过自己的构造器备份到自己内部，表面看是同一个变量，实际调用的是自己的属性而不是外部类方法的参数，如果在内部类中，修改了这些参数，并不会对外部变量产生影响，仅仅改变局部内部类中备份的参数。但是在外部调用时发现值并没有被修改，这种问题就会很尴尬，造成数据不同步。所以使用final避免数据不同步的问题。<br>————————————————<br>版权声明：本文为CSDN博主「T9的第三个三角」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/dazhaoDai/article/details/83097017\">https://blog.csdn.net/dazhaoDai/article/details/83097017</a></p>\n</blockquote>\n<h1 id=\"个人讲解\"><a href=\"#个人讲解\" class=\"headerlink\" title=\"个人讲解\"></a>个人讲解</h1><p>&emsp;&emsp;上面这段话对于一部分人可能仍然很难理解，不要担心，下面这些内容会对这一段话进行展开。<br>&emsp;&emsp;上文中说内部类中引用外部局部变量是一个拷贝，这句话可以用下面的代码理解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//代码块 A2 | 实际与A1相同</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">new</span> Object() &#123;<br>\t\t<span class=\"hljs-comment\">//final int k = k;</span><br>\t\t&#123;<br>\t\t\tSystem.out.println(k);<br>\t\t\tk = <span class=\"hljs-number\">1</span>;<br>\t\t&#125;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这样子就可以比较直观的理解“拷贝”的含义，注释掉的代码可以理解成一个隐式声明。相当于编译器为你自动复制了可访问的局部变量的值。<br>&emsp;&emsp;那这个声明为什么不能更改呢？这就涉及到了上文中提到的同步问题，如果你在内部类中修改了这个值，你修改的是复制后的值，在内部类的外部根部无法观测到这个改变，如果编译器允许你的更改，那就容易造成一个不太容易发现的BUG：我明明修改了这个值，为什么它没有变化？为了彻底避免这个问题，所以就干脆让这个声明是不可以修改的了。</p>\n<h1 id=\"深度理解“复制”\"><a href=\"#深度理解“复制”\" class=\"headerlink\" title=\"深度理解“复制”\"></a>深度理解“复制”</h1><p>&emsp;&emsp;这里说的复制是什么意思呢？在了解复制前我们要首先了解我们是怎么访问对象的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Object o = <span class=\"hljs-keyword\">new</span> Object();<br>Object o2 = <span class=\"hljs-keyword\">new</span> Object();<br>System.out.println(<span class=\"hljs-string\">&quot;o == o2 is &quot;</span> + o == o2);\t<span class=\"hljs-comment\">//false</span><br>o = o2;<br>System.out.println(<span class=\"hljs-string\">&quot;o == o2 is &quot;</span> + o == o2);\t<span class=\"hljs-comment\">//true</span><br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这段代码的输出结果代表了什么？在修改”o”的值后”o”与”o2”的地址是一样的，也就是说”o = o2”并没有触发深度复制，而是知识简单的让”o”也指向了”o2”所指向的值。<br>&emsp;&emsp;显而易见，”o”和”o2”并没有直接存储一个对象，我们可以简单的认为存储的对象的地址（实际上没有这么简单，具体方法略微有些复杂，读者可以自行查阅资料），”o = o2”这个语句就是将”o2”指向的对象的地址复制给”o”，这时候修改两者中的任意一个，另一个也会收到影响。<br>&emsp;&emsp;同样，编译器为我们复制变量的时候也没有进行深度复制，而是进行简单的复制，这个特性我们下文中会再说到。</p>\n<h1 id=\"修改外部值的方法\"><a href=\"#修改外部值的方法\" class=\"headerlink\" title=\"修改外部值的方法\"></a>修改外部值的方法</h1><h2 id=\"1-把这个值变成全局变量：\"><a href=\"#1-把这个值变成全局变量：\" class=\"headerlink\" title=\"1.把这个值变成全局变量：\"></a>1.把这个值变成全局变量：</h2><p>&emsp;&emsp;这样子就可以随意更改，但是并不建议这么做因为这样子写不但性能不高，还容易让代码变得晦涩难懂。</p>\n<h2 id=\"2-将要修改的量声明为数组：\"><a href=\"#2-将要修改的量声明为数组：\" class=\"headerlink\" title=\"2.将要修改的量声明为数组：\"></a>2.将要修改的量声明为数组：</h2><p>&emsp;&emsp;细心的小伙伴写代码的时候可能会发现下面的情况：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">new</span> ArrayList&lt;<span class=\"hljs-keyword\">int</span>[]&gt;();\t  <span class=\"hljs-comment\">//right</span><br><span class=\"hljs-keyword\">new</span> ArrayList&lt;<span class=\"hljs-keyword\">int</span>&gt;();\t\t<span class=\"hljs-comment\">//error</span><br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;第一行代码可以通过编译而第二行不可以，具体原因这里不再解释，读者只要明白int和int[]的区别就可以了。在Java中int是基本类型，但是int[]并不是，可以当作对象处理，所以int[]也可以当作泛型的参数。<br>&emsp;&emsp;知道这个有什么用呢？很简单，被final修饰的数组虽然我们不能再修改它的地址，但是我们可以修改数组中存储的数据，比如说我们可以写出来下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">int</span>[] k = &#123; <span class=\"hljs-number\">0</span> &#125;;<br>\t<span class=\"hljs-keyword\">new</span> Object() &#123;<br>\t\t&#123; k[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>; &#125;<br>\t&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"3-使用类存储数据：\"><a href=\"#3-使用类存储数据：\" class=\"headerlink\" title=\"3.使用类存储数据：\"></a>3.使用类存储数据：</h2><p>&emsp;&emsp;第二种方法看起来很正确，但是很容易混淆代码的意图，我们同样根据复制的原理，将值存在一个类中，然后我们通过这个类访问值即可进行修改：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">final</span> AtomicInteger k = <span class=\"hljs-keyword\">new</span> AtomicInteger(<span class=\"hljs-number\">0</span>);<br>\t<span class=\"hljs-keyword\">new</span> Object() &#123;<br>\t\t&#123; k.set(<span class=\"hljs-number\">1</span>); &#125;<br>\t&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"《我的世界：Minecraft模组开发指南》读后感","date":"2020-07-23T09:54:24.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b2.png","description":"经过漫长的等待终于拿到书了，迫不及待地大致的把书翻看了一遍，今天就简单的谈一下阅读时发现的问题","_content":"\n&emsp;&emsp;拿到书后迫不及待的大概的把书翻看了一遍，总体来说不太满意，感觉内容中难度上卡到了入门和熟练之间，读起来比较捉急，既没有真的把入门的东西讲全，也没有提到高级的东西。\n\n&emsp;&emsp;按照个人的意见来说，这本书并不适合Java和Forge的深度学习，学习Forge推荐阅读4z的[Minecraft 1.8.9 FML Mod 开发教程](https://fmltutor.ustc-zzzz.net/)以及[先驱者教程](https://harbinger.covertdragon.team)，其中4z的教程版本较老但是较为完善，先驱者是1.12.2版本但是内容不完善同时对新手不太友好，所以可以两个搭配食用。学习Java的话在文章尾部笔者罗列了一些书籍，读者可以选择性的阅读。\n\n&emsp;&emsp;同时按照我个人的看法，开始写模组之前一定要熟练掌握Java编程，不然开发过程中会遇到很多问题。\n\n&emsp;&emsp;同时阅读的时候也发现了一些我个人认为有待改进、不严谨和错误的地方，这里简单罗列一下：\n\n### 代码风格\n\n&emsp;&emsp;书中简要提及了代码风格的问题，但是说明的不够详细，详细介绍可以[看这里](https://www.jianshu.com/p/e7d500f36da4)，如果看完仍然不清楚的话可以自行百度查阅更多资料。\n\n### 启动/调试模组的方式（P19）\n\n&emsp;&emsp;书中给出的方式是`gradlew.bat runClient`和`gradlew.bat runServer`，实际上如果使用`gradlew.bat genIntelliRuns`配置的运行方式应该是下图中的样子(其中的虚拟机选项、程序参数、使用模块的类路径与JRE默认不是这样子，服务端与这个类似)：![客户端运行配置](https://blog.emptydreams.xyz/ReviewOfDevelopmentGuide/run.png)\n\n### 注册名称（P57...）\n\n&emsp;&emsp;书中一直在使用`setRegistryName(String name)`方法设置名称，虽然Forge可以自动推导modid，但是我个人仍然推荐使用`setRegistryName(String modid, String name)`、`setRegistryName(ResourceLocation name)`或者是`setRegistryName(\"modid:name\")`。\n\n&emsp;&emsp;同时使用`ResourceLocation`时也建议使用`new ResourceLocation(String resourceDomainIn, String resourcePathIn)`这个构造函数而不是手动的拼接modid与方块名称，其中对于方块来讲，`resourceDomainIn`对应modid，`resourcePathIn`对应方块name。\n\n### 垃圾回收机制（P58---倒数第三行）\n\n> 每过一段时间就会检查JVM中部分对象或所有对象\n\n&emsp;&emsp;这句话实际上不严谨，GC（垃圾回收器）不会按照固定的时间进行回收，只会在满足特定条件时进行回收，至于检查所有对象还是部分对象，不同的垃圾回收器以及不同的收集方式会有所区别，这里不进行深究，读者感兴趣可以去查阅[《深入理解Java虚拟机：JVM高级特性与最佳实践》](https://book.douban.com/subject/6522893/)中的相关章节，书中详细说明了GC的相关算法与实现。\n\n### SideOnly注解（P62---代码下方）\n\n> @SideOnly的作用是表明这个方法只作用于客户端\n\n&emsp;&emsp;实际上应该是`@SideOnly(CLIENT)`表明被修饰的元素只作用于客户端（@SideOnly可以修饰类、方法和字段），同时`@SideOnly(SERVER)`在普通开发中一般见不到，因为一旦使用了这个注解，那么模组将无法在本地游戏中使用被注解的元素。\n\n### 材质大小（P63---最后一行）\n\n> PNG文件本身大小应该是16像素x16像素，不过32像素x32像素的PNG图片也是可行的\n\n&emsp;&emsp;做过材质的读者应该知道，MC中的材质大小只需要是2的整次幂就可以了（2，4，8，16……）。\n\n### 未说明的代码\n\n&emsp;&emsp;书中有多处给出了代码却没有说明用途的地方，如`Block`的构造函数、`GuiContainer#renderHoveredToolTip(int, int)`等。\n\n### 书写错误\n\n> 1.这是我们第一次编写拥有返回值的方法，也就是返回值声明为void。\n>\n> ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t------ P71 · 第一行\n>\n> 2.IntelliJ IDEA 提出了两个方案——实现对应方法，并把这个类同样变成抽象类。\n>\n> ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t------ P83 · 第四行\n>\n> 3.返回值是EnumActionResult.PASS的情况都将被视为成功执行，并忽略副手上的物品。\n>\n> ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t------ P226 · 第七行\n\n1). 应该为：这是我们第一次编写拥有返回值的方法，也就是返回值声明为`非void`。| 书中写成了\"void\"。\n\n2). 应该为：IntelliJ IDEA 提出了两个方案——实现对应方法，`或`把这个类同样变成抽象类。| 书中将“或”写为了“并”。\n\n3). 应该为：返回值是`EnumActionResult.SUCCESS`的情况都将被视为成功执行，并忽略副手上的物品。 | 书中将“SUCCESS”写成了“PASS”。\n\n### ItemStack类（P85---倒数第三行）\n\n> 这个数量在大部分情况下可以是1到64之间的任意值，当然，对于调用了setMaxStackSize方法，也就是设置了最大堆叠的物品，最大数字可能小于64。\n\n&emsp;&emsp;这里只是补充一下，就算设置的最大值，也可以突破这个数值，极端一点的说，就算你设置了最大数值为\"1\"，也可以通过`setCount(int)`、`grow(int)`等方法使堆叠数量超过这个数值，不过开发中建议不要超过最大数量。\n\n### 缺失的注解（P89---第一段代码）\n\n&emsp;&emsp;文中明确说明“为覆盖用的方法也加上这一注解”，但是在下方代码中并没有出现`@sideOnly`注解，同时这句话我感觉应该是多写了一个“用”字。\n\n### 被忽视的工具（P90）\n\n&emsp;&emsp;文中提到了挖掘速度，指出速度等级为：木 < 石 < 铁 < 钻石，但是其中漏掉了“金”，加上金的排序如下：木 < 石 < 铁 < 钻石 < 金。\n\n### 更为方便的数组声明方式（P101---最后一行）\n\n&emsp;&emsp;书中使用`int[] intArray = new int[] {1, 2, 3, 4}`创建了数组，其实也可以简写为`int[] intArray = {1, 2, 3, 4}`。\n\n### 冗余的对象比较方式（P120---最后一段代码）\n\n&emsp;&emsp;虽然这么写比较没有问题，但是可以简写为：\n\n```java\nBlocks.DIRT.getRegistryName().equals(registryName)\n```\n\n&emsp;&emsp;或者使用更直白的方式：\n\n```java\nItem.getItemFromBlock(Blocks.DIRT) == event.getItemStack().getItem()\n```\n\n### 未说明的`hashCode()`方法（P121）\n\n&emsp;&emsp;书中简单叙述了`equals(Object)`方法，但是却漏掉了`hashCode()`方法。在开发过程中，如果一个类重写了`equals(Object)`方法，那么它就应当也重写`hashCode()`方法，如果只重写其中一个，那么这个类将无法更好的与集合类合作。因为集合类为了优化性能，在比较对象时会优先比较hashCode，如果hashCode不同那么这两个对象一定不相等，如果相同再调用`equals(Object)`确保对象一致。\n\n&emsp;&emsp;关于`hashCode()`方法这里就不详细说明了，读者可以查阅相关文章[(CSND)](https://www.cnblogs.com/zhchoutai/p/8676351.html)。\n\n### 生成器模式（P167）\n\n&emsp;&emsp;书中简要叙述了“生成器模式”，不过没有提到其它模式让人感觉有些可惜，读者[可以到这里](http://c.biancheng.net/design_pattern/)查阅相关内容，网页中不是所有模式都需要阅读，阅读：单例模式、工厂模式、建造者模式（即生成器模式）、代理模式、观察者模式、访问者模式即可。\n\n&emsp;&emsp;不过小伙伴Java语言基础不怎么好的话可以先不看，留着以后阅读就好。\n\n### 漏写的代码（P168）\n\n&emsp;&emsp;书中写了`FooBuilder.create()`这样子的代码，但是每行都忘记在末尾加上`.build()`了。\n\n### 装箱与拆箱\n\n&emsp;&emsp;关于装箱与拆箱这里做一个补充：在能使用基本类型的时候不要使用包装类型，因为使用包装类型很可能会带来“许多”不必要的装箱与拆箱，会较为严重的影响程序性能。\n\n### 识别NBT类型（P216）\n\n> nbt instanceof NBTTagByte：检查nbt是否是byte类型的数据\n\n&emsp;&emsp;同样这里只做一个简单的补充：NBT中`boolean`类型同样是以`NBTTagByte`的形式存储的。\n\n### 过于简单的提及meta（P256）\n\n&emsp;&emsp;关于meta书中只说明了只能使用4位，却没有提及二进制运算，实在令人感到可惜，读者可以阅读这篇文章了解[二进制（位）运算](https://www.cnblogs.com/shuaiding/p/11124974.html)。\n\n&emsp;&emsp;同时书中给的代码其实是无法正常运行的，在游戏启动时会造成崩溃，应该写为如下形式：\n\n```java\nEnumFacing facing = EnumFacing.getHorizontal(meta);\nif (facing.getAxis() == EnumFacing.Axis.Y) {\n\tfacing = EnumFacing.NORTH;\n}\nreturn getDefaultState().widthProperty(FACING, facing);\n```\n\n\n\n### 混淆for与for-each（P272）\n\n> 以for开头的语句被称为for-each循环语句。\n\n&emsp;&emsp;实际上，只有如下形式的循环成为`for-each循环`，其他都成为`for循环`\n\n```java\n//\"var\"指数据类型，\"array\"指支持for-each循环的类型\nfor (var i : array) {\n    //do something......\n}\n```\n\n&emsp;&emsp;另外提一点，并非只有数组支持for-each循环，所有实现了`Iterable<E>`接口的类都可以支持for-each循环。\n\n### 误用for-each循环（P272）\n\n&emsp;&emsp;文中写了下面这样的代码：\n\n```java\nint[] range = new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8};\nfor (int i : range) {\n    //do something......\n}\n```\n\n&emsp;&emsp;但是for-each循环的目的不是为了循环指定次数，而是用于遍历，循环指定次数应当使用如下代码：\n\n```java\nfor (int i = 0; i < 8; ++i) {\n    //do something......\n}\n```\n\n### 排版问题\n\n&emsp;&emsp;书中代码的排版问题还是很明显的，这里罗列一个（P226）：\n\n```java\n@Override\nprotected void onImact(RayTraceResult result)\n{\n    if (!this.world.isRemote)\n    {\n        if (result.entityHit != null)\n        {\n            float amount = 6.0F;\n            DamageSource source = DamageSource.causeThrownDamage(this, this\n.getThrower());\n            if (result.entityHit instanceof EntityLivingBase)\n            {\n                EntityLivingBase target = ((EntityLivingBase) result.entityHit);\n                if (target.isPotionActive(PotionRegistryHandler.POTION_DIRT_\nPROTECTION))\n                {\n                    PotionEffect effect = target.getActivePotionEffect(PotionRegi\nstryHandler.POTION_DIRT_PROTECTION);\n                    amount = effect.getAmplifier() > 0 ? 0 : amount / 2;\n                }\n            }\n            result.entityHit.attackEntityFrom(source, amount);\n        }\n        this.setDead();\n    }\n}\n```\n\n&emsp;&emsp;这段代码看起来无疑是非常混乱的，那么有没有办法让代码打印出来依然美观呢？答案是有的，有两种方法，第一种简单粗暴，直接贴张截图就可以了；另一种则是修改代码的样式。\n\n&emsp;&emsp;比如说这段代码，我们可以看到缩进浪费了很多空间，那么我们可以把前两个`if`改成下面这种形式：\n\n```java\nif (this.world.isRemote) return;\nif (result.entityHit == null)\n{\n    this.setDead();\n    return;\n}\n```\n\n\n\n&emsp;&emsp;这样子后面的代码就不需要缩进了，并且阅读代码的人看到前面的代码就能非常清楚的知道：这段代码在这两种情况下是不需要执行后面的逻辑的，按照原本的写法，读者还需要继续往下看，直到找到其对应的`}`然后发现原来这个情况是没有任何代码需要执行的。实际上在开发中，也建议使用后面的写法，会使代码更加的清晰易懂。\n\n&emsp;&emsp;但是很明显，就算消除了缩进，中间最长的代码依然超出了打印的最大宽度，那么如何解决？很简单，仔细阅读就会发现代码中一个静态常量使用了两次，那么为了缩短打印出来的代码，我们可以使用`import static`或者直接干脆告诉读者因为印刷原因xxx简写成xxx来完成。同时我们也可以省去`this`，或者使用“伪代码”来节省版面。\n\n&emsp;&emsp;经过简单的修改，代码就变成了下面这样，是不是好看了很多：\n\n```java\n//import static PotionRegistryHandler.POTION_DIRT_PROTECTION\n@Override\nprotected void onImact(RayTraceResult result)\n{\n    if (this.world.isRemote) return;\n    if (result.entityHit == null)\n    {\n        this.setDead();\n        return;\n    }\n    \n    float amount = 6.0F;\n    DamageSource source = DamageSource.causeThrownDamage(this, getThrower());\n    if (result.entityHit instanceof EntityLivingBase)\n    {\n    \tEntityLivingBase target = ((EntityLivingBase) result.entityHit);\n        if (target.isPotionActive(POTION_DIRT_PROTECTION))\n        {\n        \tPotionEffect effect = target.getActivePotionEffect(POTION_DIRT_PROTECTION);\n            amount = effect.getAmplifier() > 0 ? 0 : amount / 2;\n        }\n\t}\n    result.entityHit.attackEntityFrom(source, amount);\n    setDead();\n}\n```\n\n&emsp;&emsp;我们再举一个栗子，比如说P239的代码：\n\n```java\nmc.ingameGUI.drawTexturedModalRect(width / 2 - 170, height - 35, orange < 4 ? 0 : 9, 0, 9, 9);\nmc.ingameGUI.drawTexturedModalRect(width / 2 - 170, height - 24, green < 4 ? 0 : 9, 0, 9, 9);\n......\n```\n\n&emsp;&emsp;首先，我们看到代码中有一个重复出现的量，即：`width / 2 - 170`，那么我们可以把它保存下来，变成下面这样的代码：\n\n```java\nint x = width / 2 - 170;\nmc.ingameGUI.drawTexturedModalRect(x, height - 35, orange < 4 ? 0 : 9, 0, 9, 9);\nmc.ingameGUI.drawTexturedModalRect(x, height - 24, green < 4 ? 0 : 9, 0, 9, 9);\n......\n```\n\n&emsp;&emsp;这里我们假设一个情况，就是已经缩短到最简，无法进行任何缩减了该怎么办？比如P242的代码：\n\n```java\n\tprivate static final FMLEventChannel CHANNEL = NetworkRegistry.INSTANCE.\nnewEventDrivenChannel(NAME);\n```\n\n&emsp;&emsp;虽然可以使用`import static`进行缩短，但是这里我们换一种方法，就是拆分，把一行代码写成多行：\n\n```java\nprivate static final FMLEventChannel CHANNEL =\n    \t\t\tNetworkRegistry.INSTANCE.newEventDrivenChannel(NAME);\n```\n\n### 书籍推荐\n\n&emsp;&emsp;这里我罗列出一些我看过的感觉还不错的编程书，大家可以根据自己的需求阅读：\n\n| 归类 |                                  书籍名称 |\n| :--: | ----------------------------------------: |\n| 入门 |                          Java从入门到精通 |\n| 入门 |                              Java编程思想 |\n| 提升 |                            Effective Java |\n| 提升 |                        Java数据结构与算法 |\n| 提升 |                  重构：改善既有代码的设计 |\n| 提升 |                                Java8 实战 |\n| 拔高 | 深入理解Java虚拟机：JVM高级特性与最佳实践 |","source":"_posts/ReviewOfDevelopmentGuide.md","raw":"---\ntitle: 《我的世界：Minecraft模组开发指南》读后感\ndate: 2020-07-23 17:54:24\ntags:\n\t- Java\ncategories:\n    - MC\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b2.png\ndescription: 经过漫长的等待终于拿到书了，迫不及待地大致的把书翻看了一遍，今天就简单的谈一下阅读时发现的问题\n---\n\n&emsp;&emsp;拿到书后迫不及待的大概的把书翻看了一遍，总体来说不太满意，感觉内容中难度上卡到了入门和熟练之间，读起来比较捉急，既没有真的把入门的东西讲全，也没有提到高级的东西。\n\n&emsp;&emsp;按照个人的意见来说，这本书并不适合Java和Forge的深度学习，学习Forge推荐阅读4z的[Minecraft 1.8.9 FML Mod 开发教程](https://fmltutor.ustc-zzzz.net/)以及[先驱者教程](https://harbinger.covertdragon.team)，其中4z的教程版本较老但是较为完善，先驱者是1.12.2版本但是内容不完善同时对新手不太友好，所以可以两个搭配食用。学习Java的话在文章尾部笔者罗列了一些书籍，读者可以选择性的阅读。\n\n&emsp;&emsp;同时按照我个人的看法，开始写模组之前一定要熟练掌握Java编程，不然开发过程中会遇到很多问题。\n\n&emsp;&emsp;同时阅读的时候也发现了一些我个人认为有待改进、不严谨和错误的地方，这里简单罗列一下：\n\n### 代码风格\n\n&emsp;&emsp;书中简要提及了代码风格的问题，但是说明的不够详细，详细介绍可以[看这里](https://www.jianshu.com/p/e7d500f36da4)，如果看完仍然不清楚的话可以自行百度查阅更多资料。\n\n### 启动/调试模组的方式（P19）\n\n&emsp;&emsp;书中给出的方式是`gradlew.bat runClient`和`gradlew.bat runServer`，实际上如果使用`gradlew.bat genIntelliRuns`配置的运行方式应该是下图中的样子(其中的虚拟机选项、程序参数、使用模块的类路径与JRE默认不是这样子，服务端与这个类似)：![客户端运行配置](https://blog.emptydreams.xyz/ReviewOfDevelopmentGuide/run.png)\n\n### 注册名称（P57...）\n\n&emsp;&emsp;书中一直在使用`setRegistryName(String name)`方法设置名称，虽然Forge可以自动推导modid，但是我个人仍然推荐使用`setRegistryName(String modid, String name)`、`setRegistryName(ResourceLocation name)`或者是`setRegistryName(\"modid:name\")`。\n\n&emsp;&emsp;同时使用`ResourceLocation`时也建议使用`new ResourceLocation(String resourceDomainIn, String resourcePathIn)`这个构造函数而不是手动的拼接modid与方块名称，其中对于方块来讲，`resourceDomainIn`对应modid，`resourcePathIn`对应方块name。\n\n### 垃圾回收机制（P58---倒数第三行）\n\n> 每过一段时间就会检查JVM中部分对象或所有对象\n\n&emsp;&emsp;这句话实际上不严谨，GC（垃圾回收器）不会按照固定的时间进行回收，只会在满足特定条件时进行回收，至于检查所有对象还是部分对象，不同的垃圾回收器以及不同的收集方式会有所区别，这里不进行深究，读者感兴趣可以去查阅[《深入理解Java虚拟机：JVM高级特性与最佳实践》](https://book.douban.com/subject/6522893/)中的相关章节，书中详细说明了GC的相关算法与实现。\n\n### SideOnly注解（P62---代码下方）\n\n> @SideOnly的作用是表明这个方法只作用于客户端\n\n&emsp;&emsp;实际上应该是`@SideOnly(CLIENT)`表明被修饰的元素只作用于客户端（@SideOnly可以修饰类、方法和字段），同时`@SideOnly(SERVER)`在普通开发中一般见不到，因为一旦使用了这个注解，那么模组将无法在本地游戏中使用被注解的元素。\n\n### 材质大小（P63---最后一行）\n\n> PNG文件本身大小应该是16像素x16像素，不过32像素x32像素的PNG图片也是可行的\n\n&emsp;&emsp;做过材质的读者应该知道，MC中的材质大小只需要是2的整次幂就可以了（2，4，8，16……）。\n\n### 未说明的代码\n\n&emsp;&emsp;书中有多处给出了代码却没有说明用途的地方，如`Block`的构造函数、`GuiContainer#renderHoveredToolTip(int, int)`等。\n\n### 书写错误\n\n> 1.这是我们第一次编写拥有返回值的方法，也就是返回值声明为void。\n>\n> ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t------ P71 · 第一行\n>\n> 2.IntelliJ IDEA 提出了两个方案——实现对应方法，并把这个类同样变成抽象类。\n>\n> ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t------ P83 · 第四行\n>\n> 3.返回值是EnumActionResult.PASS的情况都将被视为成功执行，并忽略副手上的物品。\n>\n> ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t------ P226 · 第七行\n\n1). 应该为：这是我们第一次编写拥有返回值的方法，也就是返回值声明为`非void`。| 书中写成了\"void\"。\n\n2). 应该为：IntelliJ IDEA 提出了两个方案——实现对应方法，`或`把这个类同样变成抽象类。| 书中将“或”写为了“并”。\n\n3). 应该为：返回值是`EnumActionResult.SUCCESS`的情况都将被视为成功执行，并忽略副手上的物品。 | 书中将“SUCCESS”写成了“PASS”。\n\n### ItemStack类（P85---倒数第三行）\n\n> 这个数量在大部分情况下可以是1到64之间的任意值，当然，对于调用了setMaxStackSize方法，也就是设置了最大堆叠的物品，最大数字可能小于64。\n\n&emsp;&emsp;这里只是补充一下，就算设置的最大值，也可以突破这个数值，极端一点的说，就算你设置了最大数值为\"1\"，也可以通过`setCount(int)`、`grow(int)`等方法使堆叠数量超过这个数值，不过开发中建议不要超过最大数量。\n\n### 缺失的注解（P89---第一段代码）\n\n&emsp;&emsp;文中明确说明“为覆盖用的方法也加上这一注解”，但是在下方代码中并没有出现`@sideOnly`注解，同时这句话我感觉应该是多写了一个“用”字。\n\n### 被忽视的工具（P90）\n\n&emsp;&emsp;文中提到了挖掘速度，指出速度等级为：木 < 石 < 铁 < 钻石，但是其中漏掉了“金”，加上金的排序如下：木 < 石 < 铁 < 钻石 < 金。\n\n### 更为方便的数组声明方式（P101---最后一行）\n\n&emsp;&emsp;书中使用`int[] intArray = new int[] {1, 2, 3, 4}`创建了数组，其实也可以简写为`int[] intArray = {1, 2, 3, 4}`。\n\n### 冗余的对象比较方式（P120---最后一段代码）\n\n&emsp;&emsp;虽然这么写比较没有问题，但是可以简写为：\n\n```java\nBlocks.DIRT.getRegistryName().equals(registryName)\n```\n\n&emsp;&emsp;或者使用更直白的方式：\n\n```java\nItem.getItemFromBlock(Blocks.DIRT) == event.getItemStack().getItem()\n```\n\n### 未说明的`hashCode()`方法（P121）\n\n&emsp;&emsp;书中简单叙述了`equals(Object)`方法，但是却漏掉了`hashCode()`方法。在开发过程中，如果一个类重写了`equals(Object)`方法，那么它就应当也重写`hashCode()`方法，如果只重写其中一个，那么这个类将无法更好的与集合类合作。因为集合类为了优化性能，在比较对象时会优先比较hashCode，如果hashCode不同那么这两个对象一定不相等，如果相同再调用`equals(Object)`确保对象一致。\n\n&emsp;&emsp;关于`hashCode()`方法这里就不详细说明了，读者可以查阅相关文章[(CSND)](https://www.cnblogs.com/zhchoutai/p/8676351.html)。\n\n### 生成器模式（P167）\n\n&emsp;&emsp;书中简要叙述了“生成器模式”，不过没有提到其它模式让人感觉有些可惜，读者[可以到这里](http://c.biancheng.net/design_pattern/)查阅相关内容，网页中不是所有模式都需要阅读，阅读：单例模式、工厂模式、建造者模式（即生成器模式）、代理模式、观察者模式、访问者模式即可。\n\n&emsp;&emsp;不过小伙伴Java语言基础不怎么好的话可以先不看，留着以后阅读就好。\n\n### 漏写的代码（P168）\n\n&emsp;&emsp;书中写了`FooBuilder.create()`这样子的代码，但是每行都忘记在末尾加上`.build()`了。\n\n### 装箱与拆箱\n\n&emsp;&emsp;关于装箱与拆箱这里做一个补充：在能使用基本类型的时候不要使用包装类型，因为使用包装类型很可能会带来“许多”不必要的装箱与拆箱，会较为严重的影响程序性能。\n\n### 识别NBT类型（P216）\n\n> nbt instanceof NBTTagByte：检查nbt是否是byte类型的数据\n\n&emsp;&emsp;同样这里只做一个简单的补充：NBT中`boolean`类型同样是以`NBTTagByte`的形式存储的。\n\n### 过于简单的提及meta（P256）\n\n&emsp;&emsp;关于meta书中只说明了只能使用4位，却没有提及二进制运算，实在令人感到可惜，读者可以阅读这篇文章了解[二进制（位）运算](https://www.cnblogs.com/shuaiding/p/11124974.html)。\n\n&emsp;&emsp;同时书中给的代码其实是无法正常运行的，在游戏启动时会造成崩溃，应该写为如下形式：\n\n```java\nEnumFacing facing = EnumFacing.getHorizontal(meta);\nif (facing.getAxis() == EnumFacing.Axis.Y) {\n\tfacing = EnumFacing.NORTH;\n}\nreturn getDefaultState().widthProperty(FACING, facing);\n```\n\n\n\n### 混淆for与for-each（P272）\n\n> 以for开头的语句被称为for-each循环语句。\n\n&emsp;&emsp;实际上，只有如下形式的循环成为`for-each循环`，其他都成为`for循环`\n\n```java\n//\"var\"指数据类型，\"array\"指支持for-each循环的类型\nfor (var i : array) {\n    //do something......\n}\n```\n\n&emsp;&emsp;另外提一点，并非只有数组支持for-each循环，所有实现了`Iterable<E>`接口的类都可以支持for-each循环。\n\n### 误用for-each循环（P272）\n\n&emsp;&emsp;文中写了下面这样的代码：\n\n```java\nint[] range = new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8};\nfor (int i : range) {\n    //do something......\n}\n```\n\n&emsp;&emsp;但是for-each循环的目的不是为了循环指定次数，而是用于遍历，循环指定次数应当使用如下代码：\n\n```java\nfor (int i = 0; i < 8; ++i) {\n    //do something......\n}\n```\n\n### 排版问题\n\n&emsp;&emsp;书中代码的排版问题还是很明显的，这里罗列一个（P226）：\n\n```java\n@Override\nprotected void onImact(RayTraceResult result)\n{\n    if (!this.world.isRemote)\n    {\n        if (result.entityHit != null)\n        {\n            float amount = 6.0F;\n            DamageSource source = DamageSource.causeThrownDamage(this, this\n.getThrower());\n            if (result.entityHit instanceof EntityLivingBase)\n            {\n                EntityLivingBase target = ((EntityLivingBase) result.entityHit);\n                if (target.isPotionActive(PotionRegistryHandler.POTION_DIRT_\nPROTECTION))\n                {\n                    PotionEffect effect = target.getActivePotionEffect(PotionRegi\nstryHandler.POTION_DIRT_PROTECTION);\n                    amount = effect.getAmplifier() > 0 ? 0 : amount / 2;\n                }\n            }\n            result.entityHit.attackEntityFrom(source, amount);\n        }\n        this.setDead();\n    }\n}\n```\n\n&emsp;&emsp;这段代码看起来无疑是非常混乱的，那么有没有办法让代码打印出来依然美观呢？答案是有的，有两种方法，第一种简单粗暴，直接贴张截图就可以了；另一种则是修改代码的样式。\n\n&emsp;&emsp;比如说这段代码，我们可以看到缩进浪费了很多空间，那么我们可以把前两个`if`改成下面这种形式：\n\n```java\nif (this.world.isRemote) return;\nif (result.entityHit == null)\n{\n    this.setDead();\n    return;\n}\n```\n\n\n\n&emsp;&emsp;这样子后面的代码就不需要缩进了，并且阅读代码的人看到前面的代码就能非常清楚的知道：这段代码在这两种情况下是不需要执行后面的逻辑的，按照原本的写法，读者还需要继续往下看，直到找到其对应的`}`然后发现原来这个情况是没有任何代码需要执行的。实际上在开发中，也建议使用后面的写法，会使代码更加的清晰易懂。\n\n&emsp;&emsp;但是很明显，就算消除了缩进，中间最长的代码依然超出了打印的最大宽度，那么如何解决？很简单，仔细阅读就会发现代码中一个静态常量使用了两次，那么为了缩短打印出来的代码，我们可以使用`import static`或者直接干脆告诉读者因为印刷原因xxx简写成xxx来完成。同时我们也可以省去`this`，或者使用“伪代码”来节省版面。\n\n&emsp;&emsp;经过简单的修改，代码就变成了下面这样，是不是好看了很多：\n\n```java\n//import static PotionRegistryHandler.POTION_DIRT_PROTECTION\n@Override\nprotected void onImact(RayTraceResult result)\n{\n    if (this.world.isRemote) return;\n    if (result.entityHit == null)\n    {\n        this.setDead();\n        return;\n    }\n    \n    float amount = 6.0F;\n    DamageSource source = DamageSource.causeThrownDamage(this, getThrower());\n    if (result.entityHit instanceof EntityLivingBase)\n    {\n    \tEntityLivingBase target = ((EntityLivingBase) result.entityHit);\n        if (target.isPotionActive(POTION_DIRT_PROTECTION))\n        {\n        \tPotionEffect effect = target.getActivePotionEffect(POTION_DIRT_PROTECTION);\n            amount = effect.getAmplifier() > 0 ? 0 : amount / 2;\n        }\n\t}\n    result.entityHit.attackEntityFrom(source, amount);\n    setDead();\n}\n```\n\n&emsp;&emsp;我们再举一个栗子，比如说P239的代码：\n\n```java\nmc.ingameGUI.drawTexturedModalRect(width / 2 - 170, height - 35, orange < 4 ? 0 : 9, 0, 9, 9);\nmc.ingameGUI.drawTexturedModalRect(width / 2 - 170, height - 24, green < 4 ? 0 : 9, 0, 9, 9);\n......\n```\n\n&emsp;&emsp;首先，我们看到代码中有一个重复出现的量，即：`width / 2 - 170`，那么我们可以把它保存下来，变成下面这样的代码：\n\n```java\nint x = width / 2 - 170;\nmc.ingameGUI.drawTexturedModalRect(x, height - 35, orange < 4 ? 0 : 9, 0, 9, 9);\nmc.ingameGUI.drawTexturedModalRect(x, height - 24, green < 4 ? 0 : 9, 0, 9, 9);\n......\n```\n\n&emsp;&emsp;这里我们假设一个情况，就是已经缩短到最简，无法进行任何缩减了该怎么办？比如P242的代码：\n\n```java\n\tprivate static final FMLEventChannel CHANNEL = NetworkRegistry.INSTANCE.\nnewEventDrivenChannel(NAME);\n```\n\n&emsp;&emsp;虽然可以使用`import static`进行缩短，但是这里我们换一种方法，就是拆分，把一行代码写成多行：\n\n```java\nprivate static final FMLEventChannel CHANNEL =\n    \t\t\tNetworkRegistry.INSTANCE.newEventDrivenChannel(NAME);\n```\n\n### 书籍推荐\n\n&emsp;&emsp;这里我罗列出一些我看过的感觉还不错的编程书，大家可以根据自己的需求阅读：\n\n| 归类 |                                  书籍名称 |\n| :--: | ----------------------------------------: |\n| 入门 |                          Java从入门到精通 |\n| 入门 |                              Java编程思想 |\n| 提升 |                            Effective Java |\n| 提升 |                        Java数据结构与算法 |\n| 提升 |                  重构：改善既有代码的设计 |\n| 提升 |                                Java8 实战 |\n| 拔高 | 深入理解Java虚拟机：JVM高级特性与最佳实践 |","slug":"ReviewOfDevelopmentGuide","published":1,"updated":"2021-09-27T13:18:10.413Z","_id":"cku22zp2s00037kwq5j6cczv4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>&emsp;&emsp;拿到书后迫不及待的大概的把书翻看了一遍，总体来说不太满意，感觉内容中难度上卡到了入门和熟练之间，读起来比较捉急，既没有真的把入门的东西讲全，也没有提到高级的东西。</p>\n<p>&emsp;&emsp;按照个人的意见来说，这本书并不适合Java和Forge的深度学习，学习Forge推荐阅读4z的<a href=\"https://fmltutor.ustc-zzzz.net/\">Minecraft 1.8.9 FML Mod 开发教程</a>以及<a href=\"https://harbinger.covertdragon.team\">先驱者教程</a>，其中4z的教程版本较老但是较为完善，先驱者是1.12.2版本但是内容不完善同时对新手不太友好，所以可以两个搭配食用。学习Java的话在文章尾部笔者罗列了一些书籍，读者可以选择性的阅读。</p>\n<p>&emsp;&emsp;同时按照我个人的看法，开始写模组之前一定要熟练掌握Java编程，不然开发过程中会遇到很多问题。</p>\n<p>&emsp;&emsp;同时阅读的时候也发现了一些我个人认为有待改进、不严谨和错误的地方，这里简单罗列一下：</p>\n<h3 id=\"代码风格\"><a href=\"#代码风格\" class=\"headerlink\" title=\"代码风格\"></a>代码风格</h3><p>&emsp;&emsp;书中简要提及了代码风格的问题，但是说明的不够详细，详细介绍可以<a href=\"https://www.jianshu.com/p/e7d500f36da4\">看这里</a>，如果看完仍然不清楚的话可以自行百度查阅更多资料。</p>\n<h3 id=\"启动-调试模组的方式（P19）\"><a href=\"#启动-调试模组的方式（P19）\" class=\"headerlink\" title=\"启动/调试模组的方式（P19）\"></a>启动/调试模组的方式（P19）</h3><p>&emsp;&emsp;书中给出的方式是<code>gradlew.bat runClient</code>和<code>gradlew.bat runServer</code>，实际上如果使用<code>gradlew.bat genIntelliRuns</code>配置的运行方式应该是下图中的样子(其中的虚拟机选项、程序参数、使用模块的类路径与JRE默认不是这样子，服务端与这个类似)：<img src=\"https://blog.emptydreams.xyz/ReviewOfDevelopmentGuide/run.png\" alt=\"客户端运行配置\"></p>\n<h3 id=\"注册名称（P57…）\"><a href=\"#注册名称（P57…）\" class=\"headerlink\" title=\"注册名称（P57…）\"></a>注册名称（P57…）</h3><p>&emsp;&emsp;书中一直在使用<code>setRegistryName(String name)</code>方法设置名称，虽然Forge可以自动推导modid，但是我个人仍然推荐使用<code>setRegistryName(String modid, String name)</code>、<code>setRegistryName(ResourceLocation name)</code>或者是<code>setRegistryName(&quot;modid:name&quot;)</code>。</p>\n<p>&emsp;&emsp;同时使用<code>ResourceLocation</code>时也建议使用<code>new ResourceLocation(String resourceDomainIn, String resourcePathIn)</code>这个构造函数而不是手动的拼接modid与方块名称，其中对于方块来讲，<code>resourceDomainIn</code>对应modid，<code>resourcePathIn</code>对应方块name。</p>\n<h3 id=\"垃圾回收机制（P58—倒数第三行）\"><a href=\"#垃圾回收机制（P58—倒数第三行）\" class=\"headerlink\" title=\"垃圾回收机制（P58—倒数第三行）\"></a>垃圾回收机制（P58—倒数第三行）</h3><blockquote>\n<p>每过一段时间就会检查JVM中部分对象或所有对象</p>\n</blockquote>\n<p>&emsp;&emsp;这句话实际上不严谨，GC（垃圾回收器）不会按照固定的时间进行回收，只会在满足特定条件时进行回收，至于检查所有对象还是部分对象，不同的垃圾回收器以及不同的收集方式会有所区别，这里不进行深究，读者感兴趣可以去查阅<a href=\"https://book.douban.com/subject/6522893/\">《深入理解Java虚拟机：JVM高级特性与最佳实践》</a>中的相关章节，书中详细说明了GC的相关算法与实现。</p>\n<h3 id=\"SideOnly注解（P62—代码下方）\"><a href=\"#SideOnly注解（P62—代码下方）\" class=\"headerlink\" title=\"SideOnly注解（P62—代码下方）\"></a>SideOnly注解（P62—代码下方）</h3><blockquote>\n<p>@SideOnly的作用是表明这个方法只作用于客户端</p>\n</blockquote>\n<p>&emsp;&emsp;实际上应该是<code>@SideOnly(CLIENT)</code>表明被修饰的元素只作用于客户端（@SideOnly可以修饰类、方法和字段），同时<code>@SideOnly(SERVER)</code>在普通开发中一般见不到，因为一旦使用了这个注解，那么模组将无法在本地游戏中使用被注解的元素。</p>\n<h3 id=\"材质大小（P63—最后一行）\"><a href=\"#材质大小（P63—最后一行）\" class=\"headerlink\" title=\"材质大小（P63—最后一行）\"></a>材质大小（P63—最后一行）</h3><blockquote>\n<p>PNG文件本身大小应该是16像素x16像素，不过32像素x32像素的PNG图片也是可行的</p>\n</blockquote>\n<p>&emsp;&emsp;做过材质的读者应该知道，MC中的材质大小只需要是2的整次幂就可以了（2，4，8，16……）。</p>\n<h3 id=\"未说明的代码\"><a href=\"#未说明的代码\" class=\"headerlink\" title=\"未说明的代码\"></a>未说明的代码</h3><p>&emsp;&emsp;书中有多处给出了代码却没有说明用途的地方，如<code>Block</code>的构造函数、<code>GuiContainer#renderHoveredToolTip(int, int)</code>等。</p>\n<h3 id=\"书写错误\"><a href=\"#书写错误\" class=\"headerlink\" title=\"书写错误\"></a>书写错误</h3><blockquote>\n<p>1.这是我们第一次编写拥有返回值的方法，也就是返回值声明为void。</p>\n<p>​                                                                            —— P71 · 第一行</p>\n<p>2.IntelliJ IDEA 提出了两个方案——实现对应方法，并把这个类同样变成抽象类。</p>\n<p>​                                                                            —— P83 · 第四行</p>\n<p>3.返回值是EnumActionResult.PASS的情况都将被视为成功执行，并忽略副手上的物品。</p>\n<p>​                                                                            —— P226 · 第七行</p>\n</blockquote>\n<p>1). 应该为：这是我们第一次编写拥有返回值的方法，也就是返回值声明为<code>非void</code>。| 书中写成了”void”。</p>\n<p>2). 应该为：IntelliJ IDEA 提出了两个方案——实现对应方法，<code>或</code>把这个类同样变成抽象类。| 书中将“或”写为了“并”。</p>\n<p>3). 应该为：返回值是<code>EnumActionResult.SUCCESS</code>的情况都将被视为成功执行，并忽略副手上的物品。 | 书中将“SUCCESS”写成了“PASS”。</p>\n<h3 id=\"ItemStack类（P85—倒数第三行）\"><a href=\"#ItemStack类（P85—倒数第三行）\" class=\"headerlink\" title=\"ItemStack类（P85—倒数第三行）\"></a>ItemStack类（P85—倒数第三行）</h3><blockquote>\n<p>这个数量在大部分情况下可以是1到64之间的任意值，当然，对于调用了setMaxStackSize方法，也就是设置了最大堆叠的物品，最大数字可能小于64。</p>\n</blockquote>\n<p>&emsp;&emsp;这里只是补充一下，就算设置的最大值，也可以突破这个数值，极端一点的说，就算你设置了最大数值为”1”，也可以通过<code>setCount(int)</code>、<code>grow(int)</code>等方法使堆叠数量超过这个数值，不过开发中建议不要超过最大数量。</p>\n<h3 id=\"缺失的注解（P89—第一段代码）\"><a href=\"#缺失的注解（P89—第一段代码）\" class=\"headerlink\" title=\"缺失的注解（P89—第一段代码）\"></a>缺失的注解（P89—第一段代码）</h3><p>&emsp;&emsp;文中明确说明“为覆盖用的方法也加上这一注解”，但是在下方代码中并没有出现<code>@sideOnly</code>注解，同时这句话我感觉应该是多写了一个“用”字。</p>\n<h3 id=\"被忽视的工具（P90）\"><a href=\"#被忽视的工具（P90）\" class=\"headerlink\" title=\"被忽视的工具（P90）\"></a>被忽视的工具（P90）</h3><p>&emsp;&emsp;文中提到了挖掘速度，指出速度等级为：木 &lt; 石 &lt; 铁 &lt; 钻石，但是其中漏掉了“金”，加上金的排序如下：木 &lt; 石 &lt; 铁 &lt; 钻石 &lt; 金。</p>\n<h3 id=\"更为方便的数组声明方式（P101—最后一行）\"><a href=\"#更为方便的数组声明方式（P101—最后一行）\" class=\"headerlink\" title=\"更为方便的数组声明方式（P101—最后一行）\"></a>更为方便的数组声明方式（P101—最后一行）</h3><p>&emsp;&emsp;书中使用<code>int[] intArray = new int[] &#123;1, 2, 3, 4&#125;</code>创建了数组，其实也可以简写为<code>int[] intArray = &#123;1, 2, 3, 4&#125;</code>。</p>\n<h3 id=\"冗余的对象比较方式（P120—最后一段代码）\"><a href=\"#冗余的对象比较方式（P120—最后一段代码）\" class=\"headerlink\" title=\"冗余的对象比较方式（P120—最后一段代码）\"></a>冗余的对象比较方式（P120—最后一段代码）</h3><p>&emsp;&emsp;虽然这么写比较没有问题，但是可以简写为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Blocks.DIRT.getRegistryName().equals(registryName)<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;或者使用更直白的方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Item.getItemFromBlock(Blocks.DIRT) == event.getItemStack().getItem()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"未说明的hashCode-方法（P121）\"><a href=\"#未说明的hashCode-方法（P121）\" class=\"headerlink\" title=\"未说明的hashCode()方法（P121）\"></a>未说明的<code>hashCode()</code>方法（P121）</h3><p>&emsp;&emsp;书中简单叙述了<code>equals(Object)</code>方法，但是却漏掉了<code>hashCode()</code>方法。在开发过程中，如果一个类重写了<code>equals(Object)</code>方法，那么它就应当也重写<code>hashCode()</code>方法，如果只重写其中一个，那么这个类将无法更好的与集合类合作。因为集合类为了优化性能，在比较对象时会优先比较hashCode，如果hashCode不同那么这两个对象一定不相等，如果相同再调用<code>equals(Object)</code>确保对象一致。</p>\n<p>&emsp;&emsp;关于<code>hashCode()</code>方法这里就不详细说明了，读者可以查阅相关文章<a href=\"https://www.cnblogs.com/zhchoutai/p/8676351.html\">(CSND)</a>。</p>\n<h3 id=\"生成器模式（P167）\"><a href=\"#生成器模式（P167）\" class=\"headerlink\" title=\"生成器模式（P167）\"></a>生成器模式（P167）</h3><p>&emsp;&emsp;书中简要叙述了“生成器模式”，不过没有提到其它模式让人感觉有些可惜，读者<a href=\"http://c.biancheng.net/design_pattern/\">可以到这里</a>查阅相关内容，网页中不是所有模式都需要阅读，阅读：单例模式、工厂模式、建造者模式（即生成器模式）、代理模式、观察者模式、访问者模式即可。</p>\n<p>&emsp;&emsp;不过小伙伴Java语言基础不怎么好的话可以先不看，留着以后阅读就好。</p>\n<h3 id=\"漏写的代码（P168）\"><a href=\"#漏写的代码（P168）\" class=\"headerlink\" title=\"漏写的代码（P168）\"></a>漏写的代码（P168）</h3><p>&emsp;&emsp;书中写了<code>FooBuilder.create()</code>这样子的代码，但是每行都忘记在末尾加上<code>.build()</code>了。</p>\n<h3 id=\"装箱与拆箱\"><a href=\"#装箱与拆箱\" class=\"headerlink\" title=\"装箱与拆箱\"></a>装箱与拆箱</h3><p>&emsp;&emsp;关于装箱与拆箱这里做一个补充：在能使用基本类型的时候不要使用包装类型，因为使用包装类型很可能会带来“许多”不必要的装箱与拆箱，会较为严重的影响程序性能。</p>\n<h3 id=\"识别NBT类型（P216）\"><a href=\"#识别NBT类型（P216）\" class=\"headerlink\" title=\"识别NBT类型（P216）\"></a>识别NBT类型（P216）</h3><blockquote>\n<p>nbt instanceof NBTTagByte：检查nbt是否是byte类型的数据</p>\n</blockquote>\n<p>&emsp;&emsp;同样这里只做一个简单的补充：NBT中<code>boolean</code>类型同样是以<code>NBTTagByte</code>的形式存储的。</p>\n<h3 id=\"过于简单的提及meta（P256）\"><a href=\"#过于简单的提及meta（P256）\" class=\"headerlink\" title=\"过于简单的提及meta（P256）\"></a>过于简单的提及meta（P256）</h3><p>&emsp;&emsp;关于meta书中只说明了只能使用4位，却没有提及二进制运算，实在令人感到可惜，读者可以阅读这篇文章了解<a href=\"https://www.cnblogs.com/shuaiding/p/11124974.html\">二进制（位）运算</a>。</p>\n<p>&emsp;&emsp;同时书中给的代码其实是无法正常运行的，在游戏启动时会造成崩溃，应该写为如下形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">EnumFacing facing = EnumFacing.getHorizontal(meta);<br><span class=\"hljs-keyword\">if</span> (facing.getAxis() == EnumFacing.Axis.Y) &#123;<br>\tfacing = EnumFacing.NORTH;<br>&#125;<br><span class=\"hljs-keyword\">return</span> getDefaultState().widthProperty(FACING, facing);<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"混淆for与for-each（P272）\"><a href=\"#混淆for与for-each（P272）\" class=\"headerlink\" title=\"混淆for与for-each（P272）\"></a>混淆for与for-each（P272）</h3><blockquote>\n<p>以for开头的语句被称为for-each循环语句。</p>\n</blockquote>\n<p>&emsp;&emsp;实际上，只有如下形式的循环成为<code>for-each循环</code>，其他都成为<code>for循环</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//&quot;var&quot;指数据类型，&quot;array&quot;指支持for-each循环的类型</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i : array) &#123;<br>    <span class=\"hljs-comment\">//do something......</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;另外提一点，并非只有数组支持for-each循环，所有实现了<code>Iterable&lt;E&gt;</code>接口的类都可以支持for-each循环。</p>\n<h3 id=\"误用for-each循环（P272）\"><a href=\"#误用for-each循环（P272）\" class=\"headerlink\" title=\"误用for-each循环（P272）\"></a>误用for-each循环（P272）</h3><p>&emsp;&emsp;文中写了下面这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">int</span>[] range = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[] &#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>&#125;;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i : range) &#123;<br>    <span class=\"hljs-comment\">//do something......</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;但是for-each循环的目的不是为了循环指定次数，而是用于遍历，循环指定次数应当使用如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">8</span>; ++i) &#123;<br>    <span class=\"hljs-comment\">//do something......</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"排版问题\"><a href=\"#排版问题\" class=\"headerlink\" title=\"排版问题\"></a>排版问题</h3><p>&emsp;&emsp;书中代码的排版问题还是很明显的，这里罗列一个（P226）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onImact</span><span class=\"hljs-params\">(RayTraceResult result)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.world.isRemote)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (result.entityHit != <span class=\"hljs-keyword\">null</span>)<br>        &#123;<br>            <span class=\"hljs-keyword\">float</span> amount = <span class=\"hljs-number\">6.0F</span>;<br>            DamageSource source = DamageSource.causeThrownDamage(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span><br>.getThrower());<br>            <span class=\"hljs-keyword\">if</span> (result.entityHit <span class=\"hljs-keyword\">instanceof</span> EntityLivingBase)<br>            &#123;<br>                EntityLivingBase target = ((EntityLivingBase) result.entityHit);<br>                <span class=\"hljs-keyword\">if</span> (target.isPotionActive(PotionRegistryHandler.POTION_DIRT_<br>PROTECTION))<br>                &#123;<br>                    PotionEffect effect = target.getActivePotionEffect(PotionRegi<br>stryHandler.POTION_DIRT_PROTECTION);<br>                    amount = effect.getAmplifier() &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">0</span> : amount / <span class=\"hljs-number\">2</span>;<br>                &#125;<br>            &#125;<br>            result.entityHit.attackEntityFrom(source, amount);<br>        &#125;<br>        <span class=\"hljs-keyword\">this</span>.setDead();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;这段代码看起来无疑是非常混乱的，那么有没有办法让代码打印出来依然美观呢？答案是有的，有两种方法，第一种简单粗暴，直接贴张截图就可以了；另一种则是修改代码的样式。</p>\n<p>&emsp;&emsp;比如说这段代码，我们可以看到缩进浪费了很多空间，那么我们可以把前两个<code>if</code>改成下面这种形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.world.isRemote) <span class=\"hljs-keyword\">return</span>;<br><span class=\"hljs-keyword\">if</span> (result.entityHit == <span class=\"hljs-keyword\">null</span>)<br>&#123;<br>    <span class=\"hljs-keyword\">this</span>.setDead();<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>&emsp;&emsp;这样子后面的代码就不需要缩进了，并且阅读代码的人看到前面的代码就能非常清楚的知道：这段代码在这两种情况下是不需要执行后面的逻辑的，按照原本的写法，读者还需要继续往下看，直到找到其对应的<code>&#125;</code>然后发现原来这个情况是没有任何代码需要执行的。实际上在开发中，也建议使用后面的写法，会使代码更加的清晰易懂。</p>\n<p>&emsp;&emsp;但是很明显，就算消除了缩进，中间最长的代码依然超出了打印的最大宽度，那么如何解决？很简单，仔细阅读就会发现代码中一个静态常量使用了两次，那么为了缩短打印出来的代码，我们可以使用<code>import static</code>或者直接干脆告诉读者因为印刷原因xxx简写成xxx来完成。同时我们也可以省去<code>this</code>，或者使用“伪代码”来节省版面。</p>\n<p>&emsp;&emsp;经过简单的修改，代码就变成了下面这样，是不是好看了很多：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//import static PotionRegistryHandler.POTION_DIRT_PROTECTION</span><br><span class=\"hljs-meta\">@Override</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onImact</span><span class=\"hljs-params\">(RayTraceResult result)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.world.isRemote) <span class=\"hljs-keyword\">return</span>;<br>    <span class=\"hljs-keyword\">if</span> (result.entityHit == <span class=\"hljs-keyword\">null</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">this</span>.setDead();<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">float</span> amount = <span class=\"hljs-number\">6.0F</span>;<br>    DamageSource source = DamageSource.causeThrownDamage(<span class=\"hljs-keyword\">this</span>, getThrower());<br>    <span class=\"hljs-keyword\">if</span> (result.entityHit <span class=\"hljs-keyword\">instanceof</span> EntityLivingBase)<br>    &#123;<br>    \tEntityLivingBase target = ((EntityLivingBase) result.entityHit);<br>        <span class=\"hljs-keyword\">if</span> (target.isPotionActive(POTION_DIRT_PROTECTION))<br>        &#123;<br>        \tPotionEffect effect = target.getActivePotionEffect(POTION_DIRT_PROTECTION);<br>            amount = effect.getAmplifier() &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">0</span> : amount / <span class=\"hljs-number\">2</span>;<br>        &#125;<br>\t&#125;<br>    result.entityHit.attackEntityFrom(source, amount);<br>    setDead();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;我们再举一个栗子，比如说P239的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">mc.ingameGUI.drawTexturedModalRect(width / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">170</span>, height - <span class=\"hljs-number\">35</span>, orange &lt; <span class=\"hljs-number\">4</span> ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">9</span>);<br>mc.ingameGUI.drawTexturedModalRect(width / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">170</span>, height - <span class=\"hljs-number\">24</span>, green &lt; <span class=\"hljs-number\">4</span> ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">9</span>);<br>......<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;首先，我们看到代码中有一个重复出现的量，即：<code>width / 2 - 170</code>，那么我们可以把它保存下来，变成下面这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">int</span> x = width / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">170</span>;<br>mc.ingameGUI.drawTexturedModalRect(x, height - <span class=\"hljs-number\">35</span>, orange &lt; <span class=\"hljs-number\">4</span> ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">9</span>);<br>mc.ingameGUI.drawTexturedModalRect(x, height - <span class=\"hljs-number\">24</span>, green &lt; <span class=\"hljs-number\">4</span> ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">9</span>);<br>......<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;这里我们假设一个情况，就是已经缩短到最简，无法进行任何缩减了该怎么办？比如P242的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> FMLEventChannel CHANNEL = NetworkRegistry.INSTANCE.<br>newEventDrivenChannel(NAME);<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;虽然可以使用<code>import static</code>进行缩短，但是这里我们换一种方法，就是拆分，把一行代码写成多行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> FMLEventChannel CHANNEL =<br>    \t\t\tNetworkRegistry.INSTANCE.newEventDrivenChannel(NAME);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"书籍推荐\"><a href=\"#书籍推荐\" class=\"headerlink\" title=\"书籍推荐\"></a>书籍推荐</h3><p>&emsp;&emsp;这里我罗列出一些我看过的感觉还不错的编程书，大家可以根据自己的需求阅读：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">归类</th>\n<th align=\"right\">书籍名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">入门</td>\n<td align=\"right\">Java从入门到精通</td>\n</tr>\n<tr>\n<td align=\"center\">入门</td>\n<td align=\"right\">Java编程思想</td>\n</tr>\n<tr>\n<td align=\"center\">提升</td>\n<td align=\"right\">Effective Java</td>\n</tr>\n<tr>\n<td align=\"center\">提升</td>\n<td align=\"right\">Java数据结构与算法</td>\n</tr>\n<tr>\n<td align=\"center\">提升</td>\n<td align=\"right\">重构：改善既有代码的设计</td>\n</tr>\n<tr>\n<td align=\"center\">提升</td>\n<td align=\"right\">Java8 实战</td>\n</tr>\n<tr>\n<td align=\"center\">拔高</td>\n<td align=\"right\">深入理解Java虚拟机：JVM高级特性与最佳实践</td>\n</tr>\n</tbody></table>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"excerpt":"","more":"<p>&emsp;&emsp;拿到书后迫不及待的大概的把书翻看了一遍，总体来说不太满意，感觉内容中难度上卡到了入门和熟练之间，读起来比较捉急，既没有真的把入门的东西讲全，也没有提到高级的东西。</p>\n<p>&emsp;&emsp;按照个人的意见来说，这本书并不适合Java和Forge的深度学习，学习Forge推荐阅读4z的<a href=\"https://fmltutor.ustc-zzzz.net/\">Minecraft 1.8.9 FML Mod 开发教程</a>以及<a href=\"https://harbinger.covertdragon.team\">先驱者教程</a>，其中4z的教程版本较老但是较为完善，先驱者是1.12.2版本但是内容不完善同时对新手不太友好，所以可以两个搭配食用。学习Java的话在文章尾部笔者罗列了一些书籍，读者可以选择性的阅读。</p>\n<p>&emsp;&emsp;同时按照我个人的看法，开始写模组之前一定要熟练掌握Java编程，不然开发过程中会遇到很多问题。</p>\n<p>&emsp;&emsp;同时阅读的时候也发现了一些我个人认为有待改进、不严谨和错误的地方，这里简单罗列一下：</p>\n<h3 id=\"代码风格\"><a href=\"#代码风格\" class=\"headerlink\" title=\"代码风格\"></a>代码风格</h3><p>&emsp;&emsp;书中简要提及了代码风格的问题，但是说明的不够详细，详细介绍可以<a href=\"https://www.jianshu.com/p/e7d500f36da4\">看这里</a>，如果看完仍然不清楚的话可以自行百度查阅更多资料。</p>\n<h3 id=\"启动-调试模组的方式（P19）\"><a href=\"#启动-调试模组的方式（P19）\" class=\"headerlink\" title=\"启动/调试模组的方式（P19）\"></a>启动/调试模组的方式（P19）</h3><p>&emsp;&emsp;书中给出的方式是<code>gradlew.bat runClient</code>和<code>gradlew.bat runServer</code>，实际上如果使用<code>gradlew.bat genIntelliRuns</code>配置的运行方式应该是下图中的样子(其中的虚拟机选项、程序参数、使用模块的类路径与JRE默认不是这样子，服务端与这个类似)：<img src=\"https://blog.emptydreams.xyz/ReviewOfDevelopmentGuide/run.png\" alt=\"客户端运行配置\"></p>\n<h3 id=\"注册名称（P57…）\"><a href=\"#注册名称（P57…）\" class=\"headerlink\" title=\"注册名称（P57…）\"></a>注册名称（P57…）</h3><p>&emsp;&emsp;书中一直在使用<code>setRegistryName(String name)</code>方法设置名称，虽然Forge可以自动推导modid，但是我个人仍然推荐使用<code>setRegistryName(String modid, String name)</code>、<code>setRegistryName(ResourceLocation name)</code>或者是<code>setRegistryName(&quot;modid:name&quot;)</code>。</p>\n<p>&emsp;&emsp;同时使用<code>ResourceLocation</code>时也建议使用<code>new ResourceLocation(String resourceDomainIn, String resourcePathIn)</code>这个构造函数而不是手动的拼接modid与方块名称，其中对于方块来讲，<code>resourceDomainIn</code>对应modid，<code>resourcePathIn</code>对应方块name。</p>\n<h3 id=\"垃圾回收机制（P58—倒数第三行）\"><a href=\"#垃圾回收机制（P58—倒数第三行）\" class=\"headerlink\" title=\"垃圾回收机制（P58—倒数第三行）\"></a>垃圾回收机制（P58—倒数第三行）</h3><blockquote>\n<p>每过一段时间就会检查JVM中部分对象或所有对象</p>\n</blockquote>\n<p>&emsp;&emsp;这句话实际上不严谨，GC（垃圾回收器）不会按照固定的时间进行回收，只会在满足特定条件时进行回收，至于检查所有对象还是部分对象，不同的垃圾回收器以及不同的收集方式会有所区别，这里不进行深究，读者感兴趣可以去查阅<a href=\"https://book.douban.com/subject/6522893/\">《深入理解Java虚拟机：JVM高级特性与最佳实践》</a>中的相关章节，书中详细说明了GC的相关算法与实现。</p>\n<h3 id=\"SideOnly注解（P62—代码下方）\"><a href=\"#SideOnly注解（P62—代码下方）\" class=\"headerlink\" title=\"SideOnly注解（P62—代码下方）\"></a>SideOnly注解（P62—代码下方）</h3><blockquote>\n<p>@SideOnly的作用是表明这个方法只作用于客户端</p>\n</blockquote>\n<p>&emsp;&emsp;实际上应该是<code>@SideOnly(CLIENT)</code>表明被修饰的元素只作用于客户端（@SideOnly可以修饰类、方法和字段），同时<code>@SideOnly(SERVER)</code>在普通开发中一般见不到，因为一旦使用了这个注解，那么模组将无法在本地游戏中使用被注解的元素。</p>\n<h3 id=\"材质大小（P63—最后一行）\"><a href=\"#材质大小（P63—最后一行）\" class=\"headerlink\" title=\"材质大小（P63—最后一行）\"></a>材质大小（P63—最后一行）</h3><blockquote>\n<p>PNG文件本身大小应该是16像素x16像素，不过32像素x32像素的PNG图片也是可行的</p>\n</blockquote>\n<p>&emsp;&emsp;做过材质的读者应该知道，MC中的材质大小只需要是2的整次幂就可以了（2，4，8，16……）。</p>\n<h3 id=\"未说明的代码\"><a href=\"#未说明的代码\" class=\"headerlink\" title=\"未说明的代码\"></a>未说明的代码</h3><p>&emsp;&emsp;书中有多处给出了代码却没有说明用途的地方，如<code>Block</code>的构造函数、<code>GuiContainer#renderHoveredToolTip(int, int)</code>等。</p>\n<h3 id=\"书写错误\"><a href=\"#书写错误\" class=\"headerlink\" title=\"书写错误\"></a>书写错误</h3><blockquote>\n<p>1.这是我们第一次编写拥有返回值的方法，也就是返回值声明为void。</p>\n<p>​                                                                            —— P71 · 第一行</p>\n<p>2.IntelliJ IDEA 提出了两个方案——实现对应方法，并把这个类同样变成抽象类。</p>\n<p>​                                                                            —— P83 · 第四行</p>\n<p>3.返回值是EnumActionResult.PASS的情况都将被视为成功执行，并忽略副手上的物品。</p>\n<p>​                                                                            —— P226 · 第七行</p>\n</blockquote>\n<p>1). 应该为：这是我们第一次编写拥有返回值的方法，也就是返回值声明为<code>非void</code>。| 书中写成了”void”。</p>\n<p>2). 应该为：IntelliJ IDEA 提出了两个方案——实现对应方法，<code>或</code>把这个类同样变成抽象类。| 书中将“或”写为了“并”。</p>\n<p>3). 应该为：返回值是<code>EnumActionResult.SUCCESS</code>的情况都将被视为成功执行，并忽略副手上的物品。 | 书中将“SUCCESS”写成了“PASS”。</p>\n<h3 id=\"ItemStack类（P85—倒数第三行）\"><a href=\"#ItemStack类（P85—倒数第三行）\" class=\"headerlink\" title=\"ItemStack类（P85—倒数第三行）\"></a>ItemStack类（P85—倒数第三行）</h3><blockquote>\n<p>这个数量在大部分情况下可以是1到64之间的任意值，当然，对于调用了setMaxStackSize方法，也就是设置了最大堆叠的物品，最大数字可能小于64。</p>\n</blockquote>\n<p>&emsp;&emsp;这里只是补充一下，就算设置的最大值，也可以突破这个数值，极端一点的说，就算你设置了最大数值为”1”，也可以通过<code>setCount(int)</code>、<code>grow(int)</code>等方法使堆叠数量超过这个数值，不过开发中建议不要超过最大数量。</p>\n<h3 id=\"缺失的注解（P89—第一段代码）\"><a href=\"#缺失的注解（P89—第一段代码）\" class=\"headerlink\" title=\"缺失的注解（P89—第一段代码）\"></a>缺失的注解（P89—第一段代码）</h3><p>&emsp;&emsp;文中明确说明“为覆盖用的方法也加上这一注解”，但是在下方代码中并没有出现<code>@sideOnly</code>注解，同时这句话我感觉应该是多写了一个“用”字。</p>\n<h3 id=\"被忽视的工具（P90）\"><a href=\"#被忽视的工具（P90）\" class=\"headerlink\" title=\"被忽视的工具（P90）\"></a>被忽视的工具（P90）</h3><p>&emsp;&emsp;文中提到了挖掘速度，指出速度等级为：木 &lt; 石 &lt; 铁 &lt; 钻石，但是其中漏掉了“金”，加上金的排序如下：木 &lt; 石 &lt; 铁 &lt; 钻石 &lt; 金。</p>\n<h3 id=\"更为方便的数组声明方式（P101—最后一行）\"><a href=\"#更为方便的数组声明方式（P101—最后一行）\" class=\"headerlink\" title=\"更为方便的数组声明方式（P101—最后一行）\"></a>更为方便的数组声明方式（P101—最后一行）</h3><p>&emsp;&emsp;书中使用<code>int[] intArray = new int[] &#123;1, 2, 3, 4&#125;</code>创建了数组，其实也可以简写为<code>int[] intArray = &#123;1, 2, 3, 4&#125;</code>。</p>\n<h3 id=\"冗余的对象比较方式（P120—最后一段代码）\"><a href=\"#冗余的对象比较方式（P120—最后一段代码）\" class=\"headerlink\" title=\"冗余的对象比较方式（P120—最后一段代码）\"></a>冗余的对象比较方式（P120—最后一段代码）</h3><p>&emsp;&emsp;虽然这么写比较没有问题，但是可以简写为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Blocks.DIRT.getRegistryName().equals(registryName)<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;或者使用更直白的方式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">Item.getItemFromBlock(Blocks.DIRT) == event.getItemStack().getItem()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"未说明的hashCode-方法（P121）\"><a href=\"#未说明的hashCode-方法（P121）\" class=\"headerlink\" title=\"未说明的hashCode()方法（P121）\"></a>未说明的<code>hashCode()</code>方法（P121）</h3><p>&emsp;&emsp;书中简单叙述了<code>equals(Object)</code>方法，但是却漏掉了<code>hashCode()</code>方法。在开发过程中，如果一个类重写了<code>equals(Object)</code>方法，那么它就应当也重写<code>hashCode()</code>方法，如果只重写其中一个，那么这个类将无法更好的与集合类合作。因为集合类为了优化性能，在比较对象时会优先比较hashCode，如果hashCode不同那么这两个对象一定不相等，如果相同再调用<code>equals(Object)</code>确保对象一致。</p>\n<p>&emsp;&emsp;关于<code>hashCode()</code>方法这里就不详细说明了，读者可以查阅相关文章<a href=\"https://www.cnblogs.com/zhchoutai/p/8676351.html\">(CSND)</a>。</p>\n<h3 id=\"生成器模式（P167）\"><a href=\"#生成器模式（P167）\" class=\"headerlink\" title=\"生成器模式（P167）\"></a>生成器模式（P167）</h3><p>&emsp;&emsp;书中简要叙述了“生成器模式”，不过没有提到其它模式让人感觉有些可惜，读者<a href=\"http://c.biancheng.net/design_pattern/\">可以到这里</a>查阅相关内容，网页中不是所有模式都需要阅读，阅读：单例模式、工厂模式、建造者模式（即生成器模式）、代理模式、观察者模式、访问者模式即可。</p>\n<p>&emsp;&emsp;不过小伙伴Java语言基础不怎么好的话可以先不看，留着以后阅读就好。</p>\n<h3 id=\"漏写的代码（P168）\"><a href=\"#漏写的代码（P168）\" class=\"headerlink\" title=\"漏写的代码（P168）\"></a>漏写的代码（P168）</h3><p>&emsp;&emsp;书中写了<code>FooBuilder.create()</code>这样子的代码，但是每行都忘记在末尾加上<code>.build()</code>了。</p>\n<h3 id=\"装箱与拆箱\"><a href=\"#装箱与拆箱\" class=\"headerlink\" title=\"装箱与拆箱\"></a>装箱与拆箱</h3><p>&emsp;&emsp;关于装箱与拆箱这里做一个补充：在能使用基本类型的时候不要使用包装类型，因为使用包装类型很可能会带来“许多”不必要的装箱与拆箱，会较为严重的影响程序性能。</p>\n<h3 id=\"识别NBT类型（P216）\"><a href=\"#识别NBT类型（P216）\" class=\"headerlink\" title=\"识别NBT类型（P216）\"></a>识别NBT类型（P216）</h3><blockquote>\n<p>nbt instanceof NBTTagByte：检查nbt是否是byte类型的数据</p>\n</blockquote>\n<p>&emsp;&emsp;同样这里只做一个简单的补充：NBT中<code>boolean</code>类型同样是以<code>NBTTagByte</code>的形式存储的。</p>\n<h3 id=\"过于简单的提及meta（P256）\"><a href=\"#过于简单的提及meta（P256）\" class=\"headerlink\" title=\"过于简单的提及meta（P256）\"></a>过于简单的提及meta（P256）</h3><p>&emsp;&emsp;关于meta书中只说明了只能使用4位，却没有提及二进制运算，实在令人感到可惜，读者可以阅读这篇文章了解<a href=\"https://www.cnblogs.com/shuaiding/p/11124974.html\">二进制（位）运算</a>。</p>\n<p>&emsp;&emsp;同时书中给的代码其实是无法正常运行的，在游戏启动时会造成崩溃，应该写为如下形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">EnumFacing facing = EnumFacing.getHorizontal(meta);<br><span class=\"hljs-keyword\">if</span> (facing.getAxis() == EnumFacing.Axis.Y) &#123;<br>\tfacing = EnumFacing.NORTH;<br>&#125;<br><span class=\"hljs-keyword\">return</span> getDefaultState().widthProperty(FACING, facing);<br></code></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"混淆for与for-each（P272）\"><a href=\"#混淆for与for-each（P272）\" class=\"headerlink\" title=\"混淆for与for-each（P272）\"></a>混淆for与for-each（P272）</h3><blockquote>\n<p>以for开头的语句被称为for-each循环语句。</p>\n</blockquote>\n<p>&emsp;&emsp;实际上，只有如下形式的循环成为<code>for-each循环</code>，其他都成为<code>for循环</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//&quot;var&quot;指数据类型，&quot;array&quot;指支持for-each循环的类型</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i : array) &#123;<br>    <span class=\"hljs-comment\">//do something......</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;另外提一点，并非只有数组支持for-each循环，所有实现了<code>Iterable&lt;E&gt;</code>接口的类都可以支持for-each循环。</p>\n<h3 id=\"误用for-each循环（P272）\"><a href=\"#误用for-each循环（P272）\" class=\"headerlink\" title=\"误用for-each循环（P272）\"></a>误用for-each循环（P272）</h3><p>&emsp;&emsp;文中写了下面这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">int</span>[] range = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[] &#123;<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>&#125;;<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i : range) &#123;<br>    <span class=\"hljs-comment\">//do something......</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;但是for-each循环的目的不是为了循环指定次数，而是用于遍历，循环指定次数应当使用如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">8</span>; ++i) &#123;<br>    <span class=\"hljs-comment\">//do something......</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"排版问题\"><a href=\"#排版问题\" class=\"headerlink\" title=\"排版问题\"></a>排版问题</h3><p>&emsp;&emsp;书中代码的排版问题还是很明显的，这里罗列一个（P226）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-meta\">@Override</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onImact</span><span class=\"hljs-params\">(RayTraceResult result)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.world.isRemote)<br>    &#123;<br>        <span class=\"hljs-keyword\">if</span> (result.entityHit != <span class=\"hljs-keyword\">null</span>)<br>        &#123;<br>            <span class=\"hljs-keyword\">float</span> amount = <span class=\"hljs-number\">6.0F</span>;<br>            DamageSource source = DamageSource.causeThrownDamage(<span class=\"hljs-keyword\">this</span>, <span class=\"hljs-keyword\">this</span><br>.getThrower());<br>            <span class=\"hljs-keyword\">if</span> (result.entityHit <span class=\"hljs-keyword\">instanceof</span> EntityLivingBase)<br>            &#123;<br>                EntityLivingBase target = ((EntityLivingBase) result.entityHit);<br>                <span class=\"hljs-keyword\">if</span> (target.isPotionActive(PotionRegistryHandler.POTION_DIRT_<br>PROTECTION))<br>                &#123;<br>                    PotionEffect effect = target.getActivePotionEffect(PotionRegi<br>stryHandler.POTION_DIRT_PROTECTION);<br>                    amount = effect.getAmplifier() &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">0</span> : amount / <span class=\"hljs-number\">2</span>;<br>                &#125;<br>            &#125;<br>            result.entityHit.attackEntityFrom(source, amount);<br>        &#125;<br>        <span class=\"hljs-keyword\">this</span>.setDead();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;这段代码看起来无疑是非常混乱的，那么有没有办法让代码打印出来依然美观呢？答案是有的，有两种方法，第一种简单粗暴，直接贴张截图就可以了；另一种则是修改代码的样式。</p>\n<p>&emsp;&emsp;比如说这段代码，我们可以看到缩进浪费了很多空间，那么我们可以把前两个<code>if</code>改成下面这种形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.world.isRemote) <span class=\"hljs-keyword\">return</span>;<br><span class=\"hljs-keyword\">if</span> (result.entityHit == <span class=\"hljs-keyword\">null</span>)<br>&#123;<br>    <span class=\"hljs-keyword\">this</span>.setDead();<br>    <span class=\"hljs-keyword\">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n<p>&emsp;&emsp;这样子后面的代码就不需要缩进了，并且阅读代码的人看到前面的代码就能非常清楚的知道：这段代码在这两种情况下是不需要执行后面的逻辑的，按照原本的写法，读者还需要继续往下看，直到找到其对应的<code>&#125;</code>然后发现原来这个情况是没有任何代码需要执行的。实际上在开发中，也建议使用后面的写法，会使代码更加的清晰易懂。</p>\n<p>&emsp;&emsp;但是很明显，就算消除了缩进，中间最长的代码依然超出了打印的最大宽度，那么如何解决？很简单，仔细阅读就会发现代码中一个静态常量使用了两次，那么为了缩短打印出来的代码，我们可以使用<code>import static</code>或者直接干脆告诉读者因为印刷原因xxx简写成xxx来完成。同时我们也可以省去<code>this</code>，或者使用“伪代码”来节省版面。</p>\n<p>&emsp;&emsp;经过简单的修改，代码就变成了下面这样，是不是好看了很多：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-comment\">//import static PotionRegistryHandler.POTION_DIRT_PROTECTION</span><br><span class=\"hljs-meta\">@Override</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onImact</span><span class=\"hljs-params\">(RayTraceResult result)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.world.isRemote) <span class=\"hljs-keyword\">return</span>;<br>    <span class=\"hljs-keyword\">if</span> (result.entityHit == <span class=\"hljs-keyword\">null</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">this</span>.setDead();<br>        <span class=\"hljs-keyword\">return</span>;<br>    &#125;<br>    <br>    <span class=\"hljs-keyword\">float</span> amount = <span class=\"hljs-number\">6.0F</span>;<br>    DamageSource source = DamageSource.causeThrownDamage(<span class=\"hljs-keyword\">this</span>, getThrower());<br>    <span class=\"hljs-keyword\">if</span> (result.entityHit <span class=\"hljs-keyword\">instanceof</span> EntityLivingBase)<br>    &#123;<br>    \tEntityLivingBase target = ((EntityLivingBase) result.entityHit);<br>        <span class=\"hljs-keyword\">if</span> (target.isPotionActive(POTION_DIRT_PROTECTION))<br>        &#123;<br>        \tPotionEffect effect = target.getActivePotionEffect(POTION_DIRT_PROTECTION);<br>            amount = effect.getAmplifier() &gt; <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">0</span> : amount / <span class=\"hljs-number\">2</span>;<br>        &#125;<br>\t&#125;<br>    result.entityHit.attackEntityFrom(source, amount);<br>    setDead();<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;我们再举一个栗子，比如说P239的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">mc.ingameGUI.drawTexturedModalRect(width / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">170</span>, height - <span class=\"hljs-number\">35</span>, orange &lt; <span class=\"hljs-number\">4</span> ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">9</span>);<br>mc.ingameGUI.drawTexturedModalRect(width / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">170</span>, height - <span class=\"hljs-number\">24</span>, green &lt; <span class=\"hljs-number\">4</span> ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">9</span>);<br>......<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;首先，我们看到代码中有一个重复出现的量，即：<code>width / 2 - 170</code>，那么我们可以把它保存下来，变成下面这样的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">int</span> x = width / <span class=\"hljs-number\">2</span> - <span class=\"hljs-number\">170</span>;<br>mc.ingameGUI.drawTexturedModalRect(x, height - <span class=\"hljs-number\">35</span>, orange &lt; <span class=\"hljs-number\">4</span> ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">9</span>);<br>mc.ingameGUI.drawTexturedModalRect(x, height - <span class=\"hljs-number\">24</span>, green &lt; <span class=\"hljs-number\">4</span> ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">9</span>);<br>......<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;这里我们假设一个情况，就是已经缩短到最简，无法进行任何缩减了该怎么办？比如P242的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\">\t<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> FMLEventChannel CHANNEL = NetworkRegistry.INSTANCE.<br>newEventDrivenChannel(NAME);<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;虽然可以使用<code>import static</code>进行缩短，但是这里我们换一种方法，就是拆分，把一行代码写成多行：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> FMLEventChannel CHANNEL =<br>    \t\t\tNetworkRegistry.INSTANCE.newEventDrivenChannel(NAME);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"书籍推荐\"><a href=\"#书籍推荐\" class=\"headerlink\" title=\"书籍推荐\"></a>书籍推荐</h3><p>&emsp;&emsp;这里我罗列出一些我看过的感觉还不错的编程书，大家可以根据自己的需求阅读：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">归类</th>\n<th align=\"right\">书籍名称</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">入门</td>\n<td align=\"right\">Java从入门到精通</td>\n</tr>\n<tr>\n<td align=\"center\">入门</td>\n<td align=\"right\">Java编程思想</td>\n</tr>\n<tr>\n<td align=\"center\">提升</td>\n<td align=\"right\">Effective Java</td>\n</tr>\n<tr>\n<td align=\"center\">提升</td>\n<td align=\"right\">Java数据结构与算法</td>\n</tr>\n<tr>\n<td align=\"center\">提升</td>\n<td align=\"right\">重构：改善既有代码的设计</td>\n</tr>\n<tr>\n<td align=\"center\">提升</td>\n<td align=\"right\">Java8 实战</td>\n</tr>\n<tr>\n<td align=\"center\">拔高</td>\n<td align=\"right\">深入理解Java虚拟机：JVM高级特性与最佳实践</td>\n</tr>\n</tbody></table>\n"},{"title":"二进制运算从入门到入坟","date":"2021-09-16T09:36:23.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b7.jpeg","description":"被二进制秀的团团转？来这里寻找二进制的本质。","_content":"\n# 什么是二进制\n\n&emsp;&emsp;在了解二进制前我们要了解“进制”这个概念。进制是进位计数制的一个概念，“N进制”即代表遇到`N`就向前进一位。我们日常中使用的数字通常是十进制数，即逢十进一。通过这个概念以此类推，我们便能得到二进制、三进制……直到N进制。所以说不同进制之间的区别便是一位数上的最大值不同，是对同一个数字的不同表示方式，并且进制并不只有2、8、10、16四种，只是这四种比较常用而已。\n\n&emsp;&emsp;而二进制便是现代计算机中普遍应用的一种进制，原因便是二进制每一位上只有两个数：0或1，这使得二进制数在物理层面上更容易表达以及运算，也为电路中的逻辑运算提供了便利。\n\n# 进制的转换\n\n&emsp;&emsp;初中的时候我们便学习过二进制与十进制的互换。\n\n&emsp;&emsp;十进制转换为二进制的方法称为除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。\n\n&emsp;&emsp;如图所示，十进制的`500`转换为二进制后就变为了`111110100(2)`。十进制转换为其他进制将除数`2`换成其他进制的值即可。\n\n![十进制转二进制图解](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/binary/10t2.jpg)\n\n&emsp;&emsp;二进制转换为十进制则是二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。\n\n![二进制转十进制](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/binary/2t10.jpg)\n\n&emsp;&emsp;其他进制转换为十进制的方法与二进制转十进制类似，只不过将`2^n*m`中的`2`换成对应的进制值就可以了。\n\n## 二进制代码转换的奇技淫巧\n\n&emsp;&emsp;话不多说，直接上代码：\n\n```C\nvoid convert(int n, char str[]) {\n    int index = 0;\n    for (int i = 31; i != -1; --i) {\n        int bit = (n >> i) & 1;\n        if (index != 0) {\n            str[index++] = (char) (bit + '0');\n        } else if (bit != 0) {\n            index = 1;\n            str[0] = '1';\n        }\n    }\n    if (index == 0) str[index++] = '0';\n    str[index] = '\\0';\n}\n```\n\n&emsp;&emsp;这个代码使用位运算的方式将十进制数转换为二进制并存储在字符串中，该方法相比除二取余法更为简单，处理负数也不需要考虑补码的问题。至于性能问题并没有进行测试，有兴趣的小伙伴可以自行测试一下。\n\n&emsp;&emsp;代码的精髓主要在第四行，这句话的原理在了解了位运算后很容易就能想清楚了，这个代码留在这让各位自行品读，就不进行讲解了。\n\n# 不同进制在代码中的表示方法\n\n```\n二进制：0b*****   （例如：0b11001001 -> 201(10)）\n八进制：0******   （例如：0757 -> 495(10)）\n十进制：*******   （例如：551）\n十六进制：0x***   （例如：0xaf58 -> 44888(10)）\n```\n\n\n# 数字运算\n\n&emsp;&emsp;所有进制的运算依然符合小学所学的十进制运算方法，直接套用即可。\n\n```\n数字：         111101\n数字：   ×         110\n-------------------------\n运算：         000000\n运算：        111101\n运算：       111101\n-------------------------\n求解：      101101110\n```\n\n# 数字的二进制表示\n\n## 表示规则\n\n&emsp;&emsp;每一个二进制数被称为一位，这个数字有几个二进制数就占用几位。同时二进制数的最左端为最高位，最右端为最低位，即从右往左数，第一个数下标最小（0）。\n\n&emsp;&emsp;二进制中正负数是怎么区分的呢？重点就在最高位上，当最高位为0时表示这是一个正数，当最高位为1时表示这是一个负数。当然也有例外，就是`unsigned ?`型的数据，这种数据不把最高位当作正负号的判定，而是将其也用来存储数字，这样做将数据的表示范围扩大了2倍，但同时也丧失了表示负数的能力。\n\n## 原码\n\n&emsp;&emsp;顾名思义，原码就是数字原本的码值，任何数的原码就是其本身。\n\n## 反码\n\n&emsp;&emsp;反码比原码复杂一点，正数的反码是它本身，而负数的反码则是将除最高位的数外其它所有数反转，即0变成1，1变成0。比如：`0b10111`的反码便是`0b11000`\n\n## 补码\n\n&emsp;&emsp;正数依旧延续传统，其补码仍是其本身。\n\n### 负数的补码\n\n&emsp;&emsp;负数的补码有很多种求法，这里列出两种：\n\n&emsp;&emsp;1.尾数的第一个‘1’及其右边的‘0’保持不变，左边的各位按位取反，符号位不变。例如：`0b111010`变成反码就是从右往左数第一个1以及其右边的0和符号位保持不变，其它位单独求反，就变成了`0b100110`。\n\n&emsp;&emsp;2.将负数的反码+1。例如：`0b111010`的反码是`0b100101`，加一就变成了`0b100110`。\n\n&emsp;&emsp;为什么这里要列出两个方法呢？因为第二个方法在网上广为流传，甚至被误认为其就是补码的定义，其实这只不过是补码凑巧等于反码+1而非因为反码+1是补码。如果你有兴趣了解这方面的知识，可以阅读《计算机组成原理》，其中更为详细且严谨的方式解释补码。\n\n### 反码与补码的意义\n\n&emsp;&emsp;很多人可能会疑惑：为什么要创造补码这个概念？补码存在的意义是什么？为什么不直接用原码存储负数？\n\n&emsp;&emsp;现在假设只存在原码，很好，现在的概念非常简单，我们来做数学运算吧。\n\n```\n0101 + 0010 + 0101 = 1100 -> (5 + 2 + 5 = 15) //没问题\n0000 + 1000 = 1000 -> (0 + (-0) = -0)         //也没啥问题\n0011 - 0010 = 0001 -> (3 - 2 = 1)             //完全正确\n1001 + 1001 = 0010 -> ((-1) + (-1) = 2)       //啊？\n0010 + 1010 = 1100 -> (2 + (-2) = -4)         //?????\n0011 + 1100 = 1111 -> (3 + (-4) = -7)         //wtf?\n```\n\n&emsp;&emsp;最后几个等式仿佛在逗我们玩一样，甚至我们都不能称之为等式，因为他左右根本就不相等。仔细观察我们会发现，正数运算都很正常，但是一旦牵扯到负数就会出现各式各样的问题。所以原码，虽然直观易懂，易于正值转换。但用来实现加减法的话，运算规则总归是太复杂。于是反码来了。\n\n&emsp;&emsp;反码解决的问题是原码相反数相加不等于0的问题，现在让我们使用反码来进行一波计算。\n\n```\n0101 + 0010 + 0101 = 1100 -> (5 + 2 + 5 = 15) //没问题\n0000 + 1111 = 1111 -> (0 + (-0) = -0)         //也没啥问题\n0011 - 0010 = 0001 -> (3 - 2 = 1)             //完全正确\n1110 + 1110 = 1100 -> ((-1) + (-1) = -3)      //啊？\n0010 + 1101 = 1111 -> (2 + (-2) = -0)         //可以接受\n0011 + 1011 = 1110 -> (3 + (-4) = -1)         //正确\n```\n\n&emsp;&emsp;正负数的加法问题解决了，但是负数与负数的运算依然是错误的。但是实际上，两个负数相加出错其实问题不大。我们的初衷是解决正与负的加法问题，虽然现在负负相加是错误的，但是正负数的差别只有符号位不同，如果想要运算负负相加只需要把两个负数转换为其原码并把符号位变成0，当作正数相加，再把符号位变成1就可以了。\n\n&emsp;&emsp;到这里，我们已经解决了数字运算的问题，但是依然存在一个小问题，就是`0010 + 1101 = 1111`，为什么2 + (-2) 等于`-0`而不是`0`呢？虽然`+0`和`0`都一样，但是在小的问题也是问题，让我们来尝试解决它。\n\n&emsp;&emsp;解决思路很简单，把负数的反码+1，这样就不存在`-0`了，而数字的表达范围也从`[-2^(n-1) + 1, 2^(n-1) - 1]`拓展到了`[-2^(n-1), 2^(n-1) - 1]`。**注意：这里的解决思路是从反码与补码这个巧合的关系推出来的，不是说补码就是由反码+1推出来的。**\n\n### 补码的优点\n\n&emsp;&emsp;补码的存在，可以将符号位和数值域统一处理，同时让计算机可以使用加法运算来解决减法问题，这样硬件层面只需要有加法器就可以了，而不需要添加减法器，简化了电路设计。\n\n# 位运算\n\n## 和（二元）[ & ]\n\n&emsp;&emsp;和运算规则中，同为`1`返回`1`，否则返回`0`。例如`0b1101 & 0b1010 = 0b1000。`\n\n## 或（二元）[ | ]\n\n&emsp;&emsp;或运算规则中，同为`0`返回`0`，否则返回`1`。例如`0b1101 | 0b1010 = 0b1111。`\n\n## 非（一元）[ ! / ~ ]\n\n&emsp;&emsp;非运算规则中，`0`变`1`，`1`变`0`。例如：`~0b1010 = 0b0101。`\n\n&emsp;&emsp;这里注意，布尔类型和数字类型的非运算符号不一样，布尔类型是`!`，数字类型是`~`。\n\n## 异或（二元）[ ^ ]\n\n&emsp;&emsp;异或运算规则中，同为`0`返回`1`，否则返回`0`，简而言之就是不进位的加法。例如：`0b1010 ^ 0b1101 = 0b0111`。\n\n## 左移（二元）[ << ]\n\n&emsp;&emsp;左移运算是将二进制数所有位向左移动指定位数，空位补`0`。例如：`0b1111 << 2 = 0b[11]1100`（括号中的数是被裁掉的数）。\n\n## 右移（二元）[ >> ]\n\n&emsp;&emsp;右移运算是将二进制数所有位向右移动指定位数，正数空位补`0`，负数空位补`1`。例如：`0b01001 >> 2 = 0b00010[01]`、`0b10011 >> 2 = 0b11100[11]`（括号中的数是被裁掉的数）。\n\n## 无符号右移（二元）[ >>> ]\n\n&emsp;**&emsp;无符号右移在C中并不存在，在C中对无符号数进行右移便是无符号右移！**\n\n&emsp;&emsp;无符号右移是将二进制数所有位向右移动指定位数，与右移不同，无符号右移空位永远补`0`。例如：`0b10011 >>> 2 = 0b00100[11]`（括号中的数是被裁掉的数）。\n","source":"_posts/binary.md","raw":"---\ntitle: 二进制运算从入门到入坟\ndate: 2021-09-16 17:36:23\ncategories:\n  - 通用\ntags:\n  - 进制\n  - 教程\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b7.jpeg\ndescription: 被二进制秀的团团转？来这里寻找二进制的本质。\n---\n\n# 什么是二进制\n\n&emsp;&emsp;在了解二进制前我们要了解“进制”这个概念。进制是进位计数制的一个概念，“N进制”即代表遇到`N`就向前进一位。我们日常中使用的数字通常是十进制数，即逢十进一。通过这个概念以此类推，我们便能得到二进制、三进制……直到N进制。所以说不同进制之间的区别便是一位数上的最大值不同，是对同一个数字的不同表示方式，并且进制并不只有2、8、10、16四种，只是这四种比较常用而已。\n\n&emsp;&emsp;而二进制便是现代计算机中普遍应用的一种进制，原因便是二进制每一位上只有两个数：0或1，这使得二进制数在物理层面上更容易表达以及运算，也为电路中的逻辑运算提供了便利。\n\n# 进制的转换\n\n&emsp;&emsp;初中的时候我们便学习过二进制与十进制的互换。\n\n&emsp;&emsp;十进制转换为二进制的方法称为除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。\n\n&emsp;&emsp;如图所示，十进制的`500`转换为二进制后就变为了`111110100(2)`。十进制转换为其他进制将除数`2`换成其他进制的值即可。\n\n![十进制转二进制图解](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/binary/10t2.jpg)\n\n&emsp;&emsp;二进制转换为十进制则是二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。\n\n![二进制转十进制](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/binary/2t10.jpg)\n\n&emsp;&emsp;其他进制转换为十进制的方法与二进制转十进制类似，只不过将`2^n*m`中的`2`换成对应的进制值就可以了。\n\n## 二进制代码转换的奇技淫巧\n\n&emsp;&emsp;话不多说，直接上代码：\n\n```C\nvoid convert(int n, char str[]) {\n    int index = 0;\n    for (int i = 31; i != -1; --i) {\n        int bit = (n >> i) & 1;\n        if (index != 0) {\n            str[index++] = (char) (bit + '0');\n        } else if (bit != 0) {\n            index = 1;\n            str[0] = '1';\n        }\n    }\n    if (index == 0) str[index++] = '0';\n    str[index] = '\\0';\n}\n```\n\n&emsp;&emsp;这个代码使用位运算的方式将十进制数转换为二进制并存储在字符串中，该方法相比除二取余法更为简单，处理负数也不需要考虑补码的问题。至于性能问题并没有进行测试，有兴趣的小伙伴可以自行测试一下。\n\n&emsp;&emsp;代码的精髓主要在第四行，这句话的原理在了解了位运算后很容易就能想清楚了，这个代码留在这让各位自行品读，就不进行讲解了。\n\n# 不同进制在代码中的表示方法\n\n```\n二进制：0b*****   （例如：0b11001001 -> 201(10)）\n八进制：0******   （例如：0757 -> 495(10)）\n十进制：*******   （例如：551）\n十六进制：0x***   （例如：0xaf58 -> 44888(10)）\n```\n\n\n# 数字运算\n\n&emsp;&emsp;所有进制的运算依然符合小学所学的十进制运算方法，直接套用即可。\n\n```\n数字：         111101\n数字：   ×         110\n-------------------------\n运算：         000000\n运算：        111101\n运算：       111101\n-------------------------\n求解：      101101110\n```\n\n# 数字的二进制表示\n\n## 表示规则\n\n&emsp;&emsp;每一个二进制数被称为一位，这个数字有几个二进制数就占用几位。同时二进制数的最左端为最高位，最右端为最低位，即从右往左数，第一个数下标最小（0）。\n\n&emsp;&emsp;二进制中正负数是怎么区分的呢？重点就在最高位上，当最高位为0时表示这是一个正数，当最高位为1时表示这是一个负数。当然也有例外，就是`unsigned ?`型的数据，这种数据不把最高位当作正负号的判定，而是将其也用来存储数字，这样做将数据的表示范围扩大了2倍，但同时也丧失了表示负数的能力。\n\n## 原码\n\n&emsp;&emsp;顾名思义，原码就是数字原本的码值，任何数的原码就是其本身。\n\n## 反码\n\n&emsp;&emsp;反码比原码复杂一点，正数的反码是它本身，而负数的反码则是将除最高位的数外其它所有数反转，即0变成1，1变成0。比如：`0b10111`的反码便是`0b11000`\n\n## 补码\n\n&emsp;&emsp;正数依旧延续传统，其补码仍是其本身。\n\n### 负数的补码\n\n&emsp;&emsp;负数的补码有很多种求法，这里列出两种：\n\n&emsp;&emsp;1.尾数的第一个‘1’及其右边的‘0’保持不变，左边的各位按位取反，符号位不变。例如：`0b111010`变成反码就是从右往左数第一个1以及其右边的0和符号位保持不变，其它位单独求反，就变成了`0b100110`。\n\n&emsp;&emsp;2.将负数的反码+1。例如：`0b111010`的反码是`0b100101`，加一就变成了`0b100110`。\n\n&emsp;&emsp;为什么这里要列出两个方法呢？因为第二个方法在网上广为流传，甚至被误认为其就是补码的定义，其实这只不过是补码凑巧等于反码+1而非因为反码+1是补码。如果你有兴趣了解这方面的知识，可以阅读《计算机组成原理》，其中更为详细且严谨的方式解释补码。\n\n### 反码与补码的意义\n\n&emsp;&emsp;很多人可能会疑惑：为什么要创造补码这个概念？补码存在的意义是什么？为什么不直接用原码存储负数？\n\n&emsp;&emsp;现在假设只存在原码，很好，现在的概念非常简单，我们来做数学运算吧。\n\n```\n0101 + 0010 + 0101 = 1100 -> (5 + 2 + 5 = 15) //没问题\n0000 + 1000 = 1000 -> (0 + (-0) = -0)         //也没啥问题\n0011 - 0010 = 0001 -> (3 - 2 = 1)             //完全正确\n1001 + 1001 = 0010 -> ((-1) + (-1) = 2)       //啊？\n0010 + 1010 = 1100 -> (2 + (-2) = -4)         //?????\n0011 + 1100 = 1111 -> (3 + (-4) = -7)         //wtf?\n```\n\n&emsp;&emsp;最后几个等式仿佛在逗我们玩一样，甚至我们都不能称之为等式，因为他左右根本就不相等。仔细观察我们会发现，正数运算都很正常，但是一旦牵扯到负数就会出现各式各样的问题。所以原码，虽然直观易懂，易于正值转换。但用来实现加减法的话，运算规则总归是太复杂。于是反码来了。\n\n&emsp;&emsp;反码解决的问题是原码相反数相加不等于0的问题，现在让我们使用反码来进行一波计算。\n\n```\n0101 + 0010 + 0101 = 1100 -> (5 + 2 + 5 = 15) //没问题\n0000 + 1111 = 1111 -> (0 + (-0) = -0)         //也没啥问题\n0011 - 0010 = 0001 -> (3 - 2 = 1)             //完全正确\n1110 + 1110 = 1100 -> ((-1) + (-1) = -3)      //啊？\n0010 + 1101 = 1111 -> (2 + (-2) = -0)         //可以接受\n0011 + 1011 = 1110 -> (3 + (-4) = -1)         //正确\n```\n\n&emsp;&emsp;正负数的加法问题解决了，但是负数与负数的运算依然是错误的。但是实际上，两个负数相加出错其实问题不大。我们的初衷是解决正与负的加法问题，虽然现在负负相加是错误的，但是正负数的差别只有符号位不同，如果想要运算负负相加只需要把两个负数转换为其原码并把符号位变成0，当作正数相加，再把符号位变成1就可以了。\n\n&emsp;&emsp;到这里，我们已经解决了数字运算的问题，但是依然存在一个小问题，就是`0010 + 1101 = 1111`，为什么2 + (-2) 等于`-0`而不是`0`呢？虽然`+0`和`0`都一样，但是在小的问题也是问题，让我们来尝试解决它。\n\n&emsp;&emsp;解决思路很简单，把负数的反码+1，这样就不存在`-0`了，而数字的表达范围也从`[-2^(n-1) + 1, 2^(n-1) - 1]`拓展到了`[-2^(n-1), 2^(n-1) - 1]`。**注意：这里的解决思路是从反码与补码这个巧合的关系推出来的，不是说补码就是由反码+1推出来的。**\n\n### 补码的优点\n\n&emsp;&emsp;补码的存在，可以将符号位和数值域统一处理，同时让计算机可以使用加法运算来解决减法问题，这样硬件层面只需要有加法器就可以了，而不需要添加减法器，简化了电路设计。\n\n# 位运算\n\n## 和（二元）[ & ]\n\n&emsp;&emsp;和运算规则中，同为`1`返回`1`，否则返回`0`。例如`0b1101 & 0b1010 = 0b1000。`\n\n## 或（二元）[ | ]\n\n&emsp;&emsp;或运算规则中，同为`0`返回`0`，否则返回`1`。例如`0b1101 | 0b1010 = 0b1111。`\n\n## 非（一元）[ ! / ~ ]\n\n&emsp;&emsp;非运算规则中，`0`变`1`，`1`变`0`。例如：`~0b1010 = 0b0101。`\n\n&emsp;&emsp;这里注意，布尔类型和数字类型的非运算符号不一样，布尔类型是`!`，数字类型是`~`。\n\n## 异或（二元）[ ^ ]\n\n&emsp;&emsp;异或运算规则中，同为`0`返回`1`，否则返回`0`，简而言之就是不进位的加法。例如：`0b1010 ^ 0b1101 = 0b0111`。\n\n## 左移（二元）[ << ]\n\n&emsp;&emsp;左移运算是将二进制数所有位向左移动指定位数，空位补`0`。例如：`0b1111 << 2 = 0b[11]1100`（括号中的数是被裁掉的数）。\n\n## 右移（二元）[ >> ]\n\n&emsp;&emsp;右移运算是将二进制数所有位向右移动指定位数，正数空位补`0`，负数空位补`1`。例如：`0b01001 >> 2 = 0b00010[01]`、`0b10011 >> 2 = 0b11100[11]`（括号中的数是被裁掉的数）。\n\n## 无符号右移（二元）[ >>> ]\n\n&emsp;**&emsp;无符号右移在C中并不存在，在C中对无符号数进行右移便是无符号右移！**\n\n&emsp;&emsp;无符号右移是将二进制数所有位向右移动指定位数，与右移不同，无符号右移空位永远补`0`。例如：`0b10011 >>> 2 = 0b00100[11]`（括号中的数是被裁掉的数）。\n","slug":"binary","published":1,"updated":"2021-10-20T14:08:54.578Z","_id":"cku22zp2v00077kwqgq5aeaai","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"什么是二进制\"><a href=\"#什么是二进制\" class=\"headerlink\" title=\"什么是二进制\"></a>什么是二进制</h1><p>&emsp;&emsp;在了解二进制前我们要了解“进制”这个概念。进制是进位计数制的一个概念，“N进制”即代表遇到<code>N</code>就向前进一位。我们日常中使用的数字通常是十进制数，即逢十进一。通过这个概念以此类推，我们便能得到二进制、三进制……直到N进制。所以说不同进制之间的区别便是一位数上的最大值不同，是对同一个数字的不同表示方式，并且进制并不只有2、8、10、16四种，只是这四种比较常用而已。</p>\n<p>&emsp;&emsp;而二进制便是现代计算机中普遍应用的一种进制，原因便是二进制每一位上只有两个数：0或1，这使得二进制数在物理层面上更容易表达以及运算，也为电路中的逻辑运算提供了便利。</p>\n<h1 id=\"进制的转换\"><a href=\"#进制的转换\" class=\"headerlink\" title=\"进制的转换\"></a>进制的转换</h1><p>&emsp;&emsp;初中的时候我们便学习过二进制与十进制的互换。</p>\n<p>&emsp;&emsp;十进制转换为二进制的方法称为除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。</p>\n<p>&emsp;&emsp;如图所示，十进制的<code>500</code>转换为二进制后就变为了<code>111110100(2)</code>。十进制转换为其他进制将除数<code>2</code>换成其他进制的值即可。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/binary/10t2.jpg\" alt=\"十进制转二进制图解\"></p>\n<p>&emsp;&emsp;二进制转换为十进制则是二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/binary/2t10.jpg\" alt=\"二进制转十进制\"></p>\n<p>&emsp;&emsp;其他进制转换为十进制的方法与二进制转十进制类似，只不过将<code>2^n*m</code>中的<code>2</code>换成对应的进制值就可以了。</p>\n<h2 id=\"二进制代码转换的奇技淫巧\"><a href=\"#二进制代码转换的奇技淫巧\" class=\"headerlink\" title=\"二进制代码转换的奇技淫巧\"></a>二进制代码转换的奇技淫巧</h2><p>&emsp;&emsp;话不多说，直接上代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">convert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">char</span> str[])</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> index = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">31</span>; i != <span class=\"hljs-number\">-1</span>; --i) &#123;<br>        <span class=\"hljs-keyword\">int</span> bit = (n &gt;&gt; i) &amp; <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">if</span> (index != <span class=\"hljs-number\">0</span>) &#123;<br>            str[index++] = (<span class=\"hljs-keyword\">char</span>) (bit + <span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (bit != <span class=\"hljs-number\">0</span>) &#123;<br>            index = <span class=\"hljs-number\">1</span>;<br>            str[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&#x27;1&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (index == <span class=\"hljs-number\">0</span>) str[index++] = <span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>    str[index] = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这个代码使用位运算的方式将十进制数转换为二进制并存储在字符串中，该方法相比除二取余法更为简单，处理负数也不需要考虑补码的问题。至于性能问题并没有进行测试，有兴趣的小伙伴可以自行测试一下。</p>\n<p>&emsp;&emsp;代码的精髓主要在第四行，这句话的原理在了解了位运算后很容易就能想清楚了，这个代码留在这让各位自行品读，就不进行讲解了。</p>\n<h1 id=\"不同进制在代码中的表示方法\"><a href=\"#不同进制在代码中的表示方法\" class=\"headerlink\" title=\"不同进制在代码中的表示方法\"></a>不同进制在代码中的表示方法</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">二进制：0b*****   （例如：0b11001001 -&gt; 201(10)）<br>八进制：0******   （例如：0757 -&gt; 495(10)）<br>十进制：*******   （例如：551）<br>十六进制：0x***   （例如：0xaf58 -&gt; 44888(10)）<br></code></pre></td></tr></table></figure>\n<h1 id=\"数字运算\"><a href=\"#数字运算\" class=\"headerlink\" title=\"数字运算\"></a>数字运算</h1><p>&emsp;&emsp;所有进制的运算依然符合小学所学的十进制运算方法，直接套用即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">数字：         111101<br>数字：   ×         110<br>-------------------------<br>运算：         000000<br>运算：        111101<br>运算：       111101<br>-------------------------<br>求解：      101101110<br></code></pre></td></tr></table></figure>\n<h1 id=\"数字的二进制表示\"><a href=\"#数字的二进制表示\" class=\"headerlink\" title=\"数字的二进制表示\"></a>数字的二进制表示</h1><h2 id=\"表示规则\"><a href=\"#表示规则\" class=\"headerlink\" title=\"表示规则\"></a>表示规则</h2><p>&emsp;&emsp;每一个二进制数被称为一位，这个数字有几个二进制数就占用几位。同时二进制数的最左端为最高位，最右端为最低位，即从右往左数，第一个数下标最小（0）。</p>\n<p>&emsp;&emsp;二进制中正负数是怎么区分的呢？重点就在最高位上，当最高位为0时表示这是一个正数，当最高位为1时表示这是一个负数。当然也有例外，就是<code>unsigned ?</code>型的数据，这种数据不把最高位当作正负号的判定，而是将其也用来存储数字，这样做将数据的表示范围扩大了2倍，但同时也丧失了表示负数的能力。</p>\n<h2 id=\"原码\"><a href=\"#原码\" class=\"headerlink\" title=\"原码\"></a>原码</h2><p>&emsp;&emsp;顾名思义，原码就是数字原本的码值，任何数的原码就是其本身。</p>\n<h2 id=\"反码\"><a href=\"#反码\" class=\"headerlink\" title=\"反码\"></a>反码</h2><p>&emsp;&emsp;反码比原码复杂一点，正数的反码是它本身，而负数的反码则是将除最高位的数外其它所有数反转，即0变成1，1变成0。比如：<code>0b10111</code>的反码便是<code>0b11000</code></p>\n<h2 id=\"补码\"><a href=\"#补码\" class=\"headerlink\" title=\"补码\"></a>补码</h2><p>&emsp;&emsp;正数依旧延续传统，其补码仍是其本身。</p>\n<h3 id=\"负数的补码\"><a href=\"#负数的补码\" class=\"headerlink\" title=\"负数的补码\"></a>负数的补码</h3><p>&emsp;&emsp;负数的补码有很多种求法，这里列出两种：</p>\n<p>&emsp;&emsp;1.尾数的第一个‘1’及其右边的‘0’保持不变，左边的各位按位取反，符号位不变。例如：<code>0b111010</code>变成反码就是从右往左数第一个1以及其右边的0和符号位保持不变，其它位单独求反，就变成了<code>0b100110</code>。</p>\n<p>&emsp;&emsp;2.将负数的反码+1。例如：<code>0b111010</code>的反码是<code>0b100101</code>，加一就变成了<code>0b100110</code>。</p>\n<p>&emsp;&emsp;为什么这里要列出两个方法呢？因为第二个方法在网上广为流传，甚至被误认为其就是补码的定义，其实这只不过是补码凑巧等于反码+1而非因为反码+1是补码。如果你有兴趣了解这方面的知识，可以阅读《计算机组成原理》，其中更为详细且严谨的方式解释补码。</p>\n<h3 id=\"反码与补码的意义\"><a href=\"#反码与补码的意义\" class=\"headerlink\" title=\"反码与补码的意义\"></a>反码与补码的意义</h3><p>&emsp;&emsp;很多人可能会疑惑：为什么要创造补码这个概念？补码存在的意义是什么？为什么不直接用原码存储负数？</p>\n<p>&emsp;&emsp;现在假设只存在原码，很好，现在的概念非常简单，我们来做数学运算吧。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">0101 + 0010 + 0101 = 1100 -&gt; (5 + 2 + 5 = 15) //没问题<br>0000 + 1000 = 1000 -&gt; (0 + (-0) = -0)         //也没啥问题<br>0011 - 0010 = 0001 -&gt; (3 - 2 = 1)             //完全正确<br>1001 + 1001 = 0010 -&gt; ((-1) + (-1) = 2)       //啊？<br>0010 + 1010 = 1100 -&gt; (2 + (-2) = -4)         //?????<br>0011 + 1100 = 1111 -&gt; (3 + (-4) = -7)         //wtf?<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;最后几个等式仿佛在逗我们玩一样，甚至我们都不能称之为等式，因为他左右根本就不相等。仔细观察我们会发现，正数运算都很正常，但是一旦牵扯到负数就会出现各式各样的问题。所以原码，虽然直观易懂，易于正值转换。但用来实现加减法的话，运算规则总归是太复杂。于是反码来了。</p>\n<p>&emsp;&emsp;反码解决的问题是原码相反数相加不等于0的问题，现在让我们使用反码来进行一波计算。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">0101 + 0010 + 0101 = 1100 -&gt; (5 + 2 + 5 = 15) //没问题<br>0000 + 1111 = 1111 -&gt; (0 + (-0) = -0)         //也没啥问题<br>0011 - 0010 = 0001 -&gt; (3 - 2 = 1)             //完全正确<br>1110 + 1110 = 1100 -&gt; ((-1) + (-1) = -3)      //啊？<br>0010 + 1101 = 1111 -&gt; (2 + (-2) = -0)         //可以接受<br>0011 + 1011 = 1110 -&gt; (3 + (-4) = -1)         //正确<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;正负数的加法问题解决了，但是负数与负数的运算依然是错误的。但是实际上，两个负数相加出错其实问题不大。我们的初衷是解决正与负的加法问题，虽然现在负负相加是错误的，但是正负数的差别只有符号位不同，如果想要运算负负相加只需要把两个负数转换为其原码并把符号位变成0，当作正数相加，再把符号位变成1就可以了。</p>\n<p>&emsp;&emsp;到这里，我们已经解决了数字运算的问题，但是依然存在一个小问题，就是<code>0010 + 1101 = 1111</code>，为什么2 + (-2) 等于<code>-0</code>而不是<code>0</code>呢？虽然<code>+0</code>和<code>0</code>都一样，但是在小的问题也是问题，让我们来尝试解决它。</p>\n<p>&emsp;&emsp;解决思路很简单，把负数的反码+1，这样就不存在<code>-0</code>了，而数字的表达范围也从<code>[-2^(n-1) + 1, 2^(n-1) - 1]</code>拓展到了<code>[-2^(n-1), 2^(n-1) - 1]</code>。<strong>注意：这里的解决思路是从反码与补码这个巧合的关系推出来的，不是说补码就是由反码+1推出来的。</strong></p>\n<h3 id=\"补码的优点\"><a href=\"#补码的优点\" class=\"headerlink\" title=\"补码的优点\"></a>补码的优点</h3><p>&emsp;&emsp;补码的存在，可以将符号位和数值域统一处理，同时让计算机可以使用加法运算来解决减法问题，这样硬件层面只需要有加法器就可以了，而不需要添加减法器，简化了电路设计。</p>\n<h1 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h1><h2 id=\"和（二元）-amp\"><a href=\"#和（二元）-amp\" class=\"headerlink\" title=\"和（二元）[ &amp; ]\"></a>和（二元）[ &amp; ]</h2><p>&emsp;&emsp;和运算规则中，同为<code>1</code>返回<code>1</code>，否则返回<code>0</code>。例如<code>0b1101 &amp; 0b1010 = 0b1000。</code></p>\n<h2 id=\"或（二元）\"><a href=\"#或（二元）\" class=\"headerlink\" title=\"或（二元）[ | ]\"></a>或（二元）[ | ]</h2><p>&emsp;&emsp;或运算规则中，同为<code>0</code>返回<code>0</code>，否则返回<code>1</code>。例如<code>0b1101 | 0b1010 = 0b1111。</code></p>\n<h2 id=\"非（一元）\"><a href=\"#非（一元）\" class=\"headerlink\" title=\"非（一元）[ ! / ~ ]\"></a>非（一元）[ ! / ~ ]</h2><p>&emsp;&emsp;非运算规则中，<code>0</code>变<code>1</code>，<code>1</code>变<code>0</code>。例如：<code>~0b1010 = 0b0101。</code></p>\n<p>&emsp;&emsp;这里注意，布尔类型和数字类型的非运算符号不一样，布尔类型是<code>!</code>，数字类型是<code>~</code>。</p>\n<h2 id=\"异或（二元）\"><a href=\"#异或（二元）\" class=\"headerlink\" title=\"异或（二元）[ ^ ]\"></a>异或（二元）[ ^ ]</h2><p>&emsp;&emsp;异或运算规则中，同为<code>0</code>返回<code>1</code>，否则返回<code>0</code>，简而言之就是不进位的加法。例如：<code>0b1010 ^ 0b1101 = 0b0111</code>。</p>\n<h2 id=\"左移（二元）-lt-lt\"><a href=\"#左移（二元）-lt-lt\" class=\"headerlink\" title=\"左移（二元）[ &lt;&lt; ]\"></a>左移（二元）[ &lt;&lt; ]</h2><p>&emsp;&emsp;左移运算是将二进制数所有位向左移动指定位数，空位补<code>0</code>。例如：<code>0b1111 &lt;&lt; 2 = 0b[11]1100</code>（括号中的数是被裁掉的数）。</p>\n<h2 id=\"右移（二元）-gt-gt\"><a href=\"#右移（二元）-gt-gt\" class=\"headerlink\" title=\"右移（二元）[ &gt;&gt; ]\"></a>右移（二元）[ &gt;&gt; ]</h2><p>&emsp;&emsp;右移运算是将二进制数所有位向右移动指定位数，正数空位补<code>0</code>，负数空位补<code>1</code>。例如：<code>0b01001 &gt;&gt; 2 = 0b00010[01]</code>、<code>0b10011 &gt;&gt; 2 = 0b11100[11]</code>（括号中的数是被裁掉的数）。</p>\n<h2 id=\"无符号右移（二元）-gt-gt-gt\"><a href=\"#无符号右移（二元）-gt-gt-gt\" class=\"headerlink\" title=\"无符号右移（二元）[ &gt;&gt;&gt; ]\"></a>无符号右移（二元）[ &gt;&gt;&gt; ]</h2><p>&emsp;<strong>&emsp;无符号右移在C中并不存在，在C中对无符号数进行右移便是无符号右移！</strong></p>\n<p>&emsp;&emsp;无符号右移是将二进制数所有位向右移动指定位数，与右移不同，无符号右移空位永远补<code>0</code>。例如：<code>0b10011 &gt;&gt;&gt; 2 = 0b00100[11]</code>（括号中的数是被裁掉的数）。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"},{"name":"Akilar店长","link":"https://akilar.top","avatar":"https://akilar.top/img/siteicon/favicon.png","descr":"欢迎光临糖果屋","siteshot":"https://cdn.jsdelivr.net/gh/Akilarlxh/ScreenShot@gh-pages/akilar.top.jpg"}]}]}},"excerpt":"","more":"<h1 id=\"什么是二进制\"><a href=\"#什么是二进制\" class=\"headerlink\" title=\"什么是二进制\"></a>什么是二进制</h1><p>&emsp;&emsp;在了解二进制前我们要了解“进制”这个概念。进制是进位计数制的一个概念，“N进制”即代表遇到<code>N</code>就向前进一位。我们日常中使用的数字通常是十进制数，即逢十进一。通过这个概念以此类推，我们便能得到二进制、三进制……直到N进制。所以说不同进制之间的区别便是一位数上的最大值不同，是对同一个数字的不同表示方式，并且进制并不只有2、8、10、16四种，只是这四种比较常用而已。</p>\n<p>&emsp;&emsp;而二进制便是现代计算机中普遍应用的一种进制，原因便是二进制每一位上只有两个数：0或1，这使得二进制数在物理层面上更容易表达以及运算，也为电路中的逻辑运算提供了便利。</p>\n<h1 id=\"进制的转换\"><a href=\"#进制的转换\" class=\"headerlink\" title=\"进制的转换\"></a>进制的转换</h1><p>&emsp;&emsp;初中的时候我们便学习过二进制与十进制的互换。</p>\n<p>&emsp;&emsp;十进制转换为二进制的方法称为除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。</p>\n<p>&emsp;&emsp;如图所示，十进制的<code>500</code>转换为二进制后就变为了<code>111110100(2)</code>。十进制转换为其他进制将除数<code>2</code>换成其他进制的值即可。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/binary/10t2.jpg\" alt=\"十进制转二进制图解\"></p>\n<p>&emsp;&emsp;二进制转换为十进制则是二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/binary/2t10.jpg\" alt=\"二进制转十进制\"></p>\n<p>&emsp;&emsp;其他进制转换为十进制的方法与二进制转十进制类似，只不过将<code>2^n*m</code>中的<code>2</code>换成对应的进制值就可以了。</p>\n<h2 id=\"二进制代码转换的奇技淫巧\"><a href=\"#二进制代码转换的奇技淫巧\" class=\"headerlink\" title=\"二进制代码转换的奇技淫巧\"></a>二进制代码转换的奇技淫巧</h2><p>&emsp;&emsp;话不多说，直接上代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">convert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">char</span> str[])</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> index = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">31</span>; i != <span class=\"hljs-number\">-1</span>; --i) &#123;<br>        <span class=\"hljs-keyword\">int</span> bit = (n &gt;&gt; i) &amp; <span class=\"hljs-number\">1</span>;<br>        <span class=\"hljs-keyword\">if</span> (index != <span class=\"hljs-number\">0</span>) &#123;<br>            str[index++] = (<span class=\"hljs-keyword\">char</span>) (bit + <span class=\"hljs-string\">&#x27;0&#x27;</span>);<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (bit != <span class=\"hljs-number\">0</span>) &#123;<br>            index = <span class=\"hljs-number\">1</span>;<br>            str[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-string\">&#x27;1&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (index == <span class=\"hljs-number\">0</span>) str[index++] = <span class=\"hljs-string\">&#x27;0&#x27;</span>;<br>    str[index] = <span class=\"hljs-string\">&#x27;\\0&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这个代码使用位运算的方式将十进制数转换为二进制并存储在字符串中，该方法相比除二取余法更为简单，处理负数也不需要考虑补码的问题。至于性能问题并没有进行测试，有兴趣的小伙伴可以自行测试一下。</p>\n<p>&emsp;&emsp;代码的精髓主要在第四行，这句话的原理在了解了位运算后很容易就能想清楚了，这个代码留在这让各位自行品读，就不进行讲解了。</p>\n<h1 id=\"不同进制在代码中的表示方法\"><a href=\"#不同进制在代码中的表示方法\" class=\"headerlink\" title=\"不同进制在代码中的表示方法\"></a>不同进制在代码中的表示方法</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">二进制：0b*****   （例如：0b11001001 -&gt; 201(10)）<br>八进制：0******   （例如：0757 -&gt; 495(10)）<br>十进制：*******   （例如：551）<br>十六进制：0x***   （例如：0xaf58 -&gt; 44888(10)）<br></code></pre></td></tr></table></figure>\n<h1 id=\"数字运算\"><a href=\"#数字运算\" class=\"headerlink\" title=\"数字运算\"></a>数字运算</h1><p>&emsp;&emsp;所有进制的运算依然符合小学所学的十进制运算方法，直接套用即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">数字：         111101<br>数字：   ×         110<br>-------------------------<br>运算：         000000<br>运算：        111101<br>运算：       111101<br>-------------------------<br>求解：      101101110<br></code></pre></td></tr></table></figure>\n<h1 id=\"数字的二进制表示\"><a href=\"#数字的二进制表示\" class=\"headerlink\" title=\"数字的二进制表示\"></a>数字的二进制表示</h1><h2 id=\"表示规则\"><a href=\"#表示规则\" class=\"headerlink\" title=\"表示规则\"></a>表示规则</h2><p>&emsp;&emsp;每一个二进制数被称为一位，这个数字有几个二进制数就占用几位。同时二进制数的最左端为最高位，最右端为最低位，即从右往左数，第一个数下标最小（0）。</p>\n<p>&emsp;&emsp;二进制中正负数是怎么区分的呢？重点就在最高位上，当最高位为0时表示这是一个正数，当最高位为1时表示这是一个负数。当然也有例外，就是<code>unsigned ?</code>型的数据，这种数据不把最高位当作正负号的判定，而是将其也用来存储数字，这样做将数据的表示范围扩大了2倍，但同时也丧失了表示负数的能力。</p>\n<h2 id=\"原码\"><a href=\"#原码\" class=\"headerlink\" title=\"原码\"></a>原码</h2><p>&emsp;&emsp;顾名思义，原码就是数字原本的码值，任何数的原码就是其本身。</p>\n<h2 id=\"反码\"><a href=\"#反码\" class=\"headerlink\" title=\"反码\"></a>反码</h2><p>&emsp;&emsp;反码比原码复杂一点，正数的反码是它本身，而负数的反码则是将除最高位的数外其它所有数反转，即0变成1，1变成0。比如：<code>0b10111</code>的反码便是<code>0b11000</code></p>\n<h2 id=\"补码\"><a href=\"#补码\" class=\"headerlink\" title=\"补码\"></a>补码</h2><p>&emsp;&emsp;正数依旧延续传统，其补码仍是其本身。</p>\n<h3 id=\"负数的补码\"><a href=\"#负数的补码\" class=\"headerlink\" title=\"负数的补码\"></a>负数的补码</h3><p>&emsp;&emsp;负数的补码有很多种求法，这里列出两种：</p>\n<p>&emsp;&emsp;1.尾数的第一个‘1’及其右边的‘0’保持不变，左边的各位按位取反，符号位不变。例如：<code>0b111010</code>变成反码就是从右往左数第一个1以及其右边的0和符号位保持不变，其它位单独求反，就变成了<code>0b100110</code>。</p>\n<p>&emsp;&emsp;2.将负数的反码+1。例如：<code>0b111010</code>的反码是<code>0b100101</code>，加一就变成了<code>0b100110</code>。</p>\n<p>&emsp;&emsp;为什么这里要列出两个方法呢？因为第二个方法在网上广为流传，甚至被误认为其就是补码的定义，其实这只不过是补码凑巧等于反码+1而非因为反码+1是补码。如果你有兴趣了解这方面的知识，可以阅读《计算机组成原理》，其中更为详细且严谨的方式解释补码。</p>\n<h3 id=\"反码与补码的意义\"><a href=\"#反码与补码的意义\" class=\"headerlink\" title=\"反码与补码的意义\"></a>反码与补码的意义</h3><p>&emsp;&emsp;很多人可能会疑惑：为什么要创造补码这个概念？补码存在的意义是什么？为什么不直接用原码存储负数？</p>\n<p>&emsp;&emsp;现在假设只存在原码，很好，现在的概念非常简单，我们来做数学运算吧。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">0101 + 0010 + 0101 = 1100 -&gt; (5 + 2 + 5 = 15) //没问题<br>0000 + 1000 = 1000 -&gt; (0 + (-0) = -0)         //也没啥问题<br>0011 - 0010 = 0001 -&gt; (3 - 2 = 1)             //完全正确<br>1001 + 1001 = 0010 -&gt; ((-1) + (-1) = 2)       //啊？<br>0010 + 1010 = 1100 -&gt; (2 + (-2) = -4)         //?????<br>0011 + 1100 = 1111 -&gt; (3 + (-4) = -7)         //wtf?<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;最后几个等式仿佛在逗我们玩一样，甚至我们都不能称之为等式，因为他左右根本就不相等。仔细观察我们会发现，正数运算都很正常，但是一旦牵扯到负数就会出现各式各样的问题。所以原码，虽然直观易懂，易于正值转换。但用来实现加减法的话，运算规则总归是太复杂。于是反码来了。</p>\n<p>&emsp;&emsp;反码解决的问题是原码相反数相加不等于0的问题，现在让我们使用反码来进行一波计算。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">0101 + 0010 + 0101 = 1100 -&gt; (5 + 2 + 5 = 15) //没问题<br>0000 + 1111 = 1111 -&gt; (0 + (-0) = -0)         //也没啥问题<br>0011 - 0010 = 0001 -&gt; (3 - 2 = 1)             //完全正确<br>1110 + 1110 = 1100 -&gt; ((-1) + (-1) = -3)      //啊？<br>0010 + 1101 = 1111 -&gt; (2 + (-2) = -0)         //可以接受<br>0011 + 1011 = 1110 -&gt; (3 + (-4) = -1)         //正确<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;正负数的加法问题解决了，但是负数与负数的运算依然是错误的。但是实际上，两个负数相加出错其实问题不大。我们的初衷是解决正与负的加法问题，虽然现在负负相加是错误的，但是正负数的差别只有符号位不同，如果想要运算负负相加只需要把两个负数转换为其原码并把符号位变成0，当作正数相加，再把符号位变成1就可以了。</p>\n<p>&emsp;&emsp;到这里，我们已经解决了数字运算的问题，但是依然存在一个小问题，就是<code>0010 + 1101 = 1111</code>，为什么2 + (-2) 等于<code>-0</code>而不是<code>0</code>呢？虽然<code>+0</code>和<code>0</code>都一样，但是在小的问题也是问题，让我们来尝试解决它。</p>\n<p>&emsp;&emsp;解决思路很简单，把负数的反码+1，这样就不存在<code>-0</code>了，而数字的表达范围也从<code>[-2^(n-1) + 1, 2^(n-1) - 1]</code>拓展到了<code>[-2^(n-1), 2^(n-1) - 1]</code>。<strong>注意：这里的解决思路是从反码与补码这个巧合的关系推出来的，不是说补码就是由反码+1推出来的。</strong></p>\n<h3 id=\"补码的优点\"><a href=\"#补码的优点\" class=\"headerlink\" title=\"补码的优点\"></a>补码的优点</h3><p>&emsp;&emsp;补码的存在，可以将符号位和数值域统一处理，同时让计算机可以使用加法运算来解决减法问题，这样硬件层面只需要有加法器就可以了，而不需要添加减法器，简化了电路设计。</p>\n<h1 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h1><h2 id=\"和（二元）-amp\"><a href=\"#和（二元）-amp\" class=\"headerlink\" title=\"和（二元）[ &amp; ]\"></a>和（二元）[ &amp; ]</h2><p>&emsp;&emsp;和运算规则中，同为<code>1</code>返回<code>1</code>，否则返回<code>0</code>。例如<code>0b1101 &amp; 0b1010 = 0b1000。</code></p>\n<h2 id=\"或（二元）\"><a href=\"#或（二元）\" class=\"headerlink\" title=\"或（二元）[ | ]\"></a>或（二元）[ | ]</h2><p>&emsp;&emsp;或运算规则中，同为<code>0</code>返回<code>0</code>，否则返回<code>1</code>。例如<code>0b1101 | 0b1010 = 0b1111。</code></p>\n<h2 id=\"非（一元）\"><a href=\"#非（一元）\" class=\"headerlink\" title=\"非（一元）[ ! / ~ ]\"></a>非（一元）[ ! / ~ ]</h2><p>&emsp;&emsp;非运算规则中，<code>0</code>变<code>1</code>，<code>1</code>变<code>0</code>。例如：<code>~0b1010 = 0b0101。</code></p>\n<p>&emsp;&emsp;这里注意，布尔类型和数字类型的非运算符号不一样，布尔类型是<code>!</code>，数字类型是<code>~</code>。</p>\n<h2 id=\"异或（二元）\"><a href=\"#异或（二元）\" class=\"headerlink\" title=\"异或（二元）[ ^ ]\"></a>异或（二元）[ ^ ]</h2><p>&emsp;&emsp;异或运算规则中，同为<code>0</code>返回<code>1</code>，否则返回<code>0</code>，简而言之就是不进位的加法。例如：<code>0b1010 ^ 0b1101 = 0b0111</code>。</p>\n<h2 id=\"左移（二元）-lt-lt\"><a href=\"#左移（二元）-lt-lt\" class=\"headerlink\" title=\"左移（二元）[ &lt;&lt; ]\"></a>左移（二元）[ &lt;&lt; ]</h2><p>&emsp;&emsp;左移运算是将二进制数所有位向左移动指定位数，空位补<code>0</code>。例如：<code>0b1111 &lt;&lt; 2 = 0b[11]1100</code>（括号中的数是被裁掉的数）。</p>\n<h2 id=\"右移（二元）-gt-gt\"><a href=\"#右移（二元）-gt-gt\" class=\"headerlink\" title=\"右移（二元）[ &gt;&gt; ]\"></a>右移（二元）[ &gt;&gt; ]</h2><p>&emsp;&emsp;右移运算是将二进制数所有位向右移动指定位数，正数空位补<code>0</code>，负数空位补<code>1</code>。例如：<code>0b01001 &gt;&gt; 2 = 0b00010[01]</code>、<code>0b10011 &gt;&gt; 2 = 0b11100[11]</code>（括号中的数是被裁掉的数）。</p>\n<h2 id=\"无符号右移（二元）-gt-gt-gt\"><a href=\"#无符号右移（二元）-gt-gt-gt\" class=\"headerlink\" title=\"无符号右移（二元）[ &gt;&gt;&gt; ]\"></a>无符号右移（二元）[ &gt;&gt;&gt; ]</h2><p>&emsp;<strong>&emsp;无符号右移在C中并不存在，在C中对无符号数进行右移便是无符号右移！</strong></p>\n<p>&emsp;&emsp;无符号右移是将二进制数所有位向右移动指定位数，与右移不同，无符号右移空位永远补<code>0</code>。例如：<code>0b10011 &gt;&gt;&gt; 2 = 0b00100[11]</code>（括号中的数是被裁掉的数）。</p>\n"},{"title":"MC模组开发漏洞修复指南","date":"2021-08-03T09:12:54.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b4.jpg","description":"这里会写一些我开发模组时遇到的问题以及解决方法，遇到问题的小伙伴可以尝试在这里寻找解决方案。","_content":"\n\n\n# 前言\n\n&emsp;&emsp;笔者开发环境为forge-1.12.2-**14.23.5.2768**，如果版本号不一样，笔者不能保证该指南的内容对你仍然准确。\n\n&emsp;&emsp;如果你发现指南中有错误、不足之处或其它任何问题，都可以发送邮件到minedreams_ed@outlook.com。\n\n&emsp;&emsp;我会尽量为指南中的问题进行分类，如果你无法从分类中找到你要的问题，请善用浏览器的搜索功能（ctrl + F）。如果指南中没有你的问题，日后如果你自行解决了问题，也欢迎发送邮件给我，帮助我完善指南，同时也帮助其他人开发模组。\n\n&emsp;&emsp;指南中使用`☼`表示大分类，使用`☽`表示小分类，更小的分类不使用特殊符号。\n\n---\n\n# ☼&ensp;JSON\n\n## ☽ &ensp;BlockStates\n\n### 模型旋转问题\n\n&emsp;&emsp;笔者开发模组时一开始尝试使用`\"x\": *, \"y\": *, \"z\": *`表示模型的旋转角度，但是测试时却发现模型显示异常。后经过更细致的测试，发现blockstates中的json无法绕Z轴旋转模型，只可以通过X Y轴的旋转组合来旋转模型。开始时笔者怀疑是否是因为万向节死锁导致该问题的出现，但是事实证明只旋转Z轴任意角度（45/90/180/270）依然不会有任何效果，所以大概率无法旋转Z轴。\n\n&emsp;&emsp;另外，经测试，旋转模型时不论书写顺序如何，都会按照先X后Y的顺序旋转模型。所以笔者建议书写json文件时也按照先写X轴后写Y轴的顺序，防止错误的发生。\n\n&emsp;&emsp;为了方便开发，这里再说一下旋转轴的位置以及方向：\n\n<ul>\n    <li><b>Y轴</b>：Y轴再竖直方向上，从上向下看顺时针为正方向</li>\n    <li><b>X轴</b>：X轴在东西方向上，从东看向西顺时针为正方向</li>\n</ul>\n\n# ☼ &ensp;双端问题\n\n## ☽&ensp;客户端IBlockState数据异常\n\n&emsp;&emsp;笔者在开发模组时遇到了一个特别奇怪的情况：在游戏执行一段时间后我的方块的`IBlockState`在客户端的数据就变成了默认值，从而导致获取选择框时返回值错误。经过检查，`TileEntity`和服务端数据均正常，后我又检查了我的所有代码，并在`World#setBlockState`、`Chunk#setBlcokState`以及`ExtendedBlockStorage#set`中均打了断点，发现并没有代码触发这些方法。随后我检查了可能更改Chunk数据的位置，最终发现是`Chunk#read`方法将客户端数据错误的修改了。\n\n&emsp;&emsp;后来我又测试了其他方块有没有这种情况，发现我写的方块大部分都有这种情况。经过一番联想，我突然意识到这可能不是一个BUG，而是MC自身工作原理导致的。随即我又对原版方块进行了测试，发现部分原版方块也有该情况，同时还有一个规律，数据多的方块会有这种情况而数据少的不会。\n\n&emsp;&emsp;最后基本可以得出结论，如果一个方块没有使用`meta`存储方块数据，那么在Chunk进行数据同步时，客户端便无法获取到正确的IBlockState。所以如果自己写的方块没有使用`meta`， 那么客户端在进行处理时就不能直接使用方法（指`Block`类中的方法）传入的`IBlockState`对象，必须直接从TileEntity中读取所需数据。\n","source":"_posts/bugfix.md","raw":"---\ntitle: MC模组开发漏洞修复指南\ndate: 2021-08-03 17:12:54\ncategories:\n  - Java\ntags:\n  - MC\n  - 教程\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b4.jpg\ndescription: 这里会写一些我开发模组时遇到的问题以及解决方法，遇到问题的小伙伴可以尝试在这里寻找解决方案。\n---\n\n\n\n# 前言\n\n&emsp;&emsp;笔者开发环境为forge-1.12.2-**14.23.5.2768**，如果版本号不一样，笔者不能保证该指南的内容对你仍然准确。\n\n&emsp;&emsp;如果你发现指南中有错误、不足之处或其它任何问题，都可以发送邮件到minedreams_ed@outlook.com。\n\n&emsp;&emsp;我会尽量为指南中的问题进行分类，如果你无法从分类中找到你要的问题，请善用浏览器的搜索功能（ctrl + F）。如果指南中没有你的问题，日后如果你自行解决了问题，也欢迎发送邮件给我，帮助我完善指南，同时也帮助其他人开发模组。\n\n&emsp;&emsp;指南中使用`☼`表示大分类，使用`☽`表示小分类，更小的分类不使用特殊符号。\n\n---\n\n# ☼&ensp;JSON\n\n## ☽ &ensp;BlockStates\n\n### 模型旋转问题\n\n&emsp;&emsp;笔者开发模组时一开始尝试使用`\"x\": *, \"y\": *, \"z\": *`表示模型的旋转角度，但是测试时却发现模型显示异常。后经过更细致的测试，发现blockstates中的json无法绕Z轴旋转模型，只可以通过X Y轴的旋转组合来旋转模型。开始时笔者怀疑是否是因为万向节死锁导致该问题的出现，但是事实证明只旋转Z轴任意角度（45/90/180/270）依然不会有任何效果，所以大概率无法旋转Z轴。\n\n&emsp;&emsp;另外，经测试，旋转模型时不论书写顺序如何，都会按照先X后Y的顺序旋转模型。所以笔者建议书写json文件时也按照先写X轴后写Y轴的顺序，防止错误的发生。\n\n&emsp;&emsp;为了方便开发，这里再说一下旋转轴的位置以及方向：\n\n<ul>\n    <li><b>Y轴</b>：Y轴再竖直方向上，从上向下看顺时针为正方向</li>\n    <li><b>X轴</b>：X轴在东西方向上，从东看向西顺时针为正方向</li>\n</ul>\n\n# ☼ &ensp;双端问题\n\n## ☽&ensp;客户端IBlockState数据异常\n\n&emsp;&emsp;笔者在开发模组时遇到了一个特别奇怪的情况：在游戏执行一段时间后我的方块的`IBlockState`在客户端的数据就变成了默认值，从而导致获取选择框时返回值错误。经过检查，`TileEntity`和服务端数据均正常，后我又检查了我的所有代码，并在`World#setBlockState`、`Chunk#setBlcokState`以及`ExtendedBlockStorage#set`中均打了断点，发现并没有代码触发这些方法。随后我检查了可能更改Chunk数据的位置，最终发现是`Chunk#read`方法将客户端数据错误的修改了。\n\n&emsp;&emsp;后来我又测试了其他方块有没有这种情况，发现我写的方块大部分都有这种情况。经过一番联想，我突然意识到这可能不是一个BUG，而是MC自身工作原理导致的。随即我又对原版方块进行了测试，发现部分原版方块也有该情况，同时还有一个规律，数据多的方块会有这种情况而数据少的不会。\n\n&emsp;&emsp;最后基本可以得出结论，如果一个方块没有使用`meta`存储方块数据，那么在Chunk进行数据同步时，客户端便无法获取到正确的IBlockState。所以如果自己写的方块没有使用`meta`， 那么客户端在进行处理时就不能直接使用方法（指`Block`类中的方法）传入的`IBlockState`对象，必须直接从TileEntity中读取所需数据。\n","slug":"bugfix","published":1,"updated":"2021-09-27T13:18:32.888Z","_id":"cku22zp2y00097kwqhf9r168u","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>&emsp;&emsp;笔者开发环境为forge-1.12.2-<strong>14.23.5.2768</strong>，如果版本号不一样，笔者不能保证该指南的内容对你仍然准确。</p>\n<p>&emsp;&emsp;如果你发现指南中有错误、不足之处或其它任何问题，都可以发送邮件到<a href=\"mailto:minedreams_ed@outlook.com\">minedreams_ed@outlook.com</a>。</p>\n<p>&emsp;&emsp;我会尽量为指南中的问题进行分类，如果你无法从分类中找到你要的问题，请善用浏览器的搜索功能（ctrl + F）。如果指南中没有你的问题，日后如果你自行解决了问题，也欢迎发送邮件给我，帮助我完善指南，同时也帮助其他人开发模组。</p>\n<p>&emsp;&emsp;指南中使用<code>☼</code>表示大分类，使用<code>☽</code>表示小分类，更小的分类不使用特殊符号。</p>\n<hr>\n<h1 id=\"☼-ensp-JSON\"><a href=\"#☼-ensp-JSON\" class=\"headerlink\" title=\"☼&ensp;JSON\"></a>☼&ensp;JSON</h1><h2 id=\"☽-ensp-BlockStates\"><a href=\"#☽-ensp-BlockStates\" class=\"headerlink\" title=\"☽ &ensp;BlockStates\"></a>☽ &ensp;BlockStates</h2><h3 id=\"模型旋转问题\"><a href=\"#模型旋转问题\" class=\"headerlink\" title=\"模型旋转问题\"></a>模型旋转问题</h3><p>&emsp;&emsp;笔者开发模组时一开始尝试使用<code>&quot;x&quot;: *, &quot;y&quot;: *, &quot;z&quot;: *</code>表示模型的旋转角度，但是测试时却发现模型显示异常。后经过更细致的测试，发现blockstates中的json无法绕Z轴旋转模型，只可以通过X Y轴的旋转组合来旋转模型。开始时笔者怀疑是否是因为万向节死锁导致该问题的出现，但是事实证明只旋转Z轴任意角度（45/90/180/270）依然不会有任何效果，所以大概率无法旋转Z轴。</p>\n<p>&emsp;&emsp;另外，经测试，旋转模型时不论书写顺序如何，都会按照先X后Y的顺序旋转模型。所以笔者建议书写json文件时也按照先写X轴后写Y轴的顺序，防止错误的发生。</p>\n<p>&emsp;&emsp;为了方便开发，这里再说一下旋转轴的位置以及方向：</p>\n<ul>\n    <li><b>Y轴</b>：Y轴再竖直方向上，从上向下看顺时针为正方向</li>\n    <li><b>X轴</b>：X轴在东西方向上，从东看向西顺时针为正方向</li>\n</ul>\n\n<h1 id=\"☼-ensp-双端问题\"><a href=\"#☼-ensp-双端问题\" class=\"headerlink\" title=\"☼ &ensp;双端问题\"></a>☼ &ensp;双端问题</h1><h2 id=\"☽-ensp-客户端IBlockState数据异常\"><a href=\"#☽-ensp-客户端IBlockState数据异常\" class=\"headerlink\" title=\"☽&ensp;客户端IBlockState数据异常\"></a>☽&ensp;客户端IBlockState数据异常</h2><p>&emsp;&emsp;笔者在开发模组时遇到了一个特别奇怪的情况：在游戏执行一段时间后我的方块的<code>IBlockState</code>在客户端的数据就变成了默认值，从而导致获取选择框时返回值错误。经过检查，<code>TileEntity</code>和服务端数据均正常，后我又检查了我的所有代码，并在<code>World#setBlockState</code>、<code>Chunk#setBlcokState</code>以及<code>ExtendedBlockStorage#set</code>中均打了断点，发现并没有代码触发这些方法。随后我检查了可能更改Chunk数据的位置，最终发现是<code>Chunk#read</code>方法将客户端数据错误的修改了。</p>\n<p>&emsp;&emsp;后来我又测试了其他方块有没有这种情况，发现我写的方块大部分都有这种情况。经过一番联想，我突然意识到这可能不是一个BUG，而是MC自身工作原理导致的。随即我又对原版方块进行了测试，发现部分原版方块也有该情况，同时还有一个规律，数据多的方块会有这种情况而数据少的不会。</p>\n<p>&emsp;&emsp;最后基本可以得出结论，如果一个方块没有使用<code>meta</code>存储方块数据，那么在Chunk进行数据同步时，客户端便无法获取到正确的IBlockState。所以如果自己写的方块没有使用<code>meta</code>， 那么客户端在进行处理时就不能直接使用方法（指<code>Block</code>类中的方法）传入的<code>IBlockState</code>对象，必须直接从TileEntity中读取所需数据。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>&emsp;&emsp;笔者开发环境为forge-1.12.2-<strong>14.23.5.2768</strong>，如果版本号不一样，笔者不能保证该指南的内容对你仍然准确。</p>\n<p>&emsp;&emsp;如果你发现指南中有错误、不足之处或其它任何问题，都可以发送邮件到<a href=\"mailto:minedreams_ed@outlook.com\">minedreams_ed@outlook.com</a>。</p>\n<p>&emsp;&emsp;我会尽量为指南中的问题进行分类，如果你无法从分类中找到你要的问题，请善用浏览器的搜索功能（ctrl + F）。如果指南中没有你的问题，日后如果你自行解决了问题，也欢迎发送邮件给我，帮助我完善指南，同时也帮助其他人开发模组。</p>\n<p>&emsp;&emsp;指南中使用<code>☼</code>表示大分类，使用<code>☽</code>表示小分类，更小的分类不使用特殊符号。</p>\n<hr>\n<h1 id=\"☼-ensp-JSON\"><a href=\"#☼-ensp-JSON\" class=\"headerlink\" title=\"☼&ensp;JSON\"></a>☼&ensp;JSON</h1><h2 id=\"☽-ensp-BlockStates\"><a href=\"#☽-ensp-BlockStates\" class=\"headerlink\" title=\"☽ &ensp;BlockStates\"></a>☽ &ensp;BlockStates</h2><h3 id=\"模型旋转问题\"><a href=\"#模型旋转问题\" class=\"headerlink\" title=\"模型旋转问题\"></a>模型旋转问题</h3><p>&emsp;&emsp;笔者开发模组时一开始尝试使用<code>&quot;x&quot;: *, &quot;y&quot;: *, &quot;z&quot;: *</code>表示模型的旋转角度，但是测试时却发现模型显示异常。后经过更细致的测试，发现blockstates中的json无法绕Z轴旋转模型，只可以通过X Y轴的旋转组合来旋转模型。开始时笔者怀疑是否是因为万向节死锁导致该问题的出现，但是事实证明只旋转Z轴任意角度（45/90/180/270）依然不会有任何效果，所以大概率无法旋转Z轴。</p>\n<p>&emsp;&emsp;另外，经测试，旋转模型时不论书写顺序如何，都会按照先X后Y的顺序旋转模型。所以笔者建议书写json文件时也按照先写X轴后写Y轴的顺序，防止错误的发生。</p>\n<p>&emsp;&emsp;为了方便开发，这里再说一下旋转轴的位置以及方向：</p>\n<ul>\n    <li><b>Y轴</b>：Y轴再竖直方向上，从上向下看顺时针为正方向</li>\n    <li><b>X轴</b>：X轴在东西方向上，从东看向西顺时针为正方向</li>\n</ul>\n\n<h1 id=\"☼-ensp-双端问题\"><a href=\"#☼-ensp-双端问题\" class=\"headerlink\" title=\"☼ &ensp;双端问题\"></a>☼ &ensp;双端问题</h1><h2 id=\"☽-ensp-客户端IBlockState数据异常\"><a href=\"#☽-ensp-客户端IBlockState数据异常\" class=\"headerlink\" title=\"☽&ensp;客户端IBlockState数据异常\"></a>☽&ensp;客户端IBlockState数据异常</h2><p>&emsp;&emsp;笔者在开发模组时遇到了一个特别奇怪的情况：在游戏执行一段时间后我的方块的<code>IBlockState</code>在客户端的数据就变成了默认值，从而导致获取选择框时返回值错误。经过检查，<code>TileEntity</code>和服务端数据均正常，后我又检查了我的所有代码，并在<code>World#setBlockState</code>、<code>Chunk#setBlcokState</code>以及<code>ExtendedBlockStorage#set</code>中均打了断点，发现并没有代码触发这些方法。随后我检查了可能更改Chunk数据的位置，最终发现是<code>Chunk#read</code>方法将客户端数据错误的修改了。</p>\n<p>&emsp;&emsp;后来我又测试了其他方块有没有这种情况，发现我写的方块大部分都有这种情况。经过一番联想，我突然意识到这可能不是一个BUG，而是MC自身工作原理导致的。随即我又对原版方块进行了测试，发现部分原版方块也有该情况，同时还有一个规律，数据多的方块会有这种情况而数据少的不会。</p>\n<p>&emsp;&emsp;最后基本可以得出结论，如果一个方块没有使用<code>meta</code>存储方块数据，那么在Chunk进行数据同步时，客户端便无法获取到正确的IBlockState。所以如果自己写的方块没有使用<code>meta</code>， 那么客户端在进行处理时就不能直接使用方法（指<code>Block</code>类中的方法）传入的<code>IBlockState</code>对象，必须直接从TileEntity中读取所需数据。</p>\n"},{"title":"浅读C语言代码规范","date":"2021-09-05T08:49:06.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b6.jpg","description":"这里简单描述了C语言的代码规范，部分规则其他语言也可参考。","_content":"\n# 前言\n\n&emsp;&emsp;在编写程序的过程中如果不遵守编译器的规定，编译器在编译时就会报错，这个规定叫作规则。但是有一种规定，它是一种约定成俗的规则，即使不按照那种规定也不会出错，这种规定就叫作规范。虽然在编写代码的过程中不遵守规范不会影响代码的运行结果，但会影响自己以及他人阅读代码，从而增加错误排查、理解代码的难度（极端例子可见[我之前写的文章](https://www.bilibili.com/read/cv4389953)）。并且在未来步入职场的时候，不良的代码书写习惯也可能会使你丢掉一个工作。\n\n&emsp;&emsp;代码规范写出来内容很多，可能有些人会抱怨：“这么多怎么记得住？！”。但实际上，代码规范并不需要背记。我们要首先理解代码规范的目的是什么？是让代码更整洁、更易懂。所以有些时候只要能保证代码整洁，就算不严格遵守代码规范依然没有问题。同时这也代表着我们不需要完全将规范背下来，只需要知道一些最基本的内容，然后加以练习、养成习惯，就能自然而然的写出整洁有效的代码。而日后再回顾以前的练习，你也会庆幸自己注意了这方面的内容。\n\n---\n\n# 正文\n\n---\n\n## 排版\n\n&emsp;&emsp;排版是规范中最为重要的部分，正确的排版可以让代码更加清晰。\n\n### 缩进\n\n&emsp;&emsp;如同写文章每个自然段前要加两个空格一般，写代码同样需要在一些部分添加空格来对齐代码。比如：\n\n<ul>\n    <li>顶层元素不空格</li>\n    <li>每遇到一个<b>{</b>，下面的代码缩进就要多一段</li>\n    <li>如果一个字符串被拆成了多行，那么应该使用空格将字符串开头对齐</li>\n    <li>如果一行代码被拆成了多行，应添加空格表明这几行代码的包含关系</li>\n</ul>\n\n&emsp;&emsp;一段缩进一般为4格或者5格。同时应避免使用制表符（tab）进行缩进，因为使用制表符在不同的编辑器中显示效果可能不同（如果你的IDE会将tab键自动转换为空格进行缩进可以无视这个）。\n\n### 每个函数前后加空行\n\n```c\nunsigned int mult(int start, int end) {\n    unsigned int result = 1;\n    for (int i = start; i <= end; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nunsigned int cnm(int n, int m) {\n    if (n- m < m + 1)\n        return mult(m + 1, n) / mult(1, n - m);\n    else\n        return mult(n - m + 1, n) / mult(1, m);\n}\n```\n\n### 同一个函数中功能差别较大的代码块之间添加空行\n\n&emsp;&emsp;比如上面几行代码完成的是一个功能，下面几行代码完成的是另一个功能，那么它们中间就要加空行。这样看起来更清晰。因为C语言的例子我没有找到，这里拿Java写的一个例子来充个数。\n\n![](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/standard/dmk.jpg)\n\n### 集中的变量声明后添加空行\n\n&emsp;&emsp;如果你把函数中的变量全部写到了函数头（数量较多），那么应在声明后添加空行，如果数量不多可以不添加空行。\n\n```c\nint amount,\t\t//...\n    year,\t\t//...\n    month,\t\t//...\n    day,\t\t//...\n    min,\t\t//...\n    wula,\t\t//...\n    oula,\t\t//...\n    muda;\t\t//...\n\n//do something\n```\n\n\n\n### 善用空格\n\n&emsp;&emsp;除`.`、`!`、`~`、`++`、`--`、'('、'['、`->`等与前（或后）文密切相关的操作符外，所有操作符前后都应添加空格，同时关键字后也应添加空格。\n\n&emsp;&emsp;**注意：一个空格足矣，不要连续敲一堆空格（除非你在对齐代码）。**\n\n```c\nint sum = a + b;\nbool canPrint = sum > 0;\nbool continueRun = sum >= 10;\nif (canPaint) printf(\"%d\", sum);\nif (!continueRun) return false;\n```\n\n\n\n### 一条语句不要过长\n\n&emsp;&emsp;某些情况下我们可能需要写一行非常长的代码（比如包含超长字符串），这时候我们应当将这一行代码拆分为多行，避免代码长度超过屏幕显示宽度。一般情况下代码宽度标准为80，读者也可根据自己屏幕的宽度适当增加这个宽度。\n\n```c\nprintf(\"乌拉乌拉阿斯蒂芬卢卡斯的的规划区内我发噶卫生间而她却尔雅如附件阿斯顿佛为日投标文件拷入按时灯笼裤能否勾起我i而后体哦我石达开你发给i哦请问然后那天给他\");\n//这里上下两段代码效果是一样的，显然后者更加符合规范\nprintf(\"乌拉乌拉阿斯蒂芬卢卡斯的的规划区内我发噶卫生间\"\n       \"而她却尔雅如附件阿斯顿佛为日投标文件拷入按时灯笼裤能否\"\n       \"勾起我i而后体哦我石达开你发给i哦请问然后那天给他\");\n```\n\n\n\n### 一行仅包含一个变量声明（特殊情况例外）\n\n&emsp;&emsp;正常情况下，一行仅包含一条变量声明，这样子也方便为变量添加注释。\n\n```c\ndouble pi = 3.1415;\t //π\nint r;\t\t\t\t//原半径\nint c;\t\t\t\t//周长\nint s;\t\t\t\t//面积\n```\n\n\n\n### 控制语句语句独占一行\n\n&emsp;&emsp;正常情况下，if 、for 、 while 、case 、switch 、default 等语句独自占用一行，但如果后续代码非常短也可以共同占用一行。\n\n```c\n//变量赋值这里省略\nint min;\nbool con;\nswitch (min) {\n    case 0:\n        //do something...\n        break;\n    case 1:\n        for (int i = 0; i < min; ++i) {\n            //do something...\n        }\n        break;\n    case 2:\n        while (min != 0) {\n            //do something...\n        }\n        break;\n    case 3: return 0;\n    default: return con ? 1 : 2;\n}\n```\n\n### 大括号的位置\n\n&emsp;&emsp;大括号书写的位置有两种写法，读者选择一种使用即可，不要多种混用。\n\n```c\n//第一种\nint main() {\n}\n//第二种\nint main()\n{\n}\n```\n\n## 函数\n\n### 一个函数不要过长\n\n&emsp;&emsp;一个函数的行数尽量维持在50（或80）以下（非空非注释行）。\n\n&emsp;&emsp;但有些函数例外，这些函数可能集成了非常庞大的单个功能，同时由于算法的复杂性无法进行有效的拆分（即拆分可能使代码变得更加复杂难懂）。\n\n### 重复的代码提取为一个函数\n\n&emsp;&emsp;如果有一个功能在多个地方被使用，那么应该这个功能提炼成一个独立的函数，这样使用这个功能的时候直接调用这个函数就可以了，有效减少了重复代码。\n\n### 一个函数仅对应一个功能\n\n&emsp;&emsp;一个函数完成多个任务是书写代码的大忌，这样不仅会让函数命名变得复杂，同时会让函数的职责变得不明确，增大了后期维护、修改以及理解的难度。\n\n### 对参数的合法性检查应有明确的规定\n\n&emsp;&emsp;通常情况下，应当对输入函数的参数进行检查，避免出现意外的情况。但是谁检查是一个普遍存在的问题。有两个极端的情况：一是调用者与被调用者都检查了，二是调用者与被调用者都没有检查。前者虽不会带来运行结果错误，但会出现代码冗余、运行效率降低的情况，后者则可能会导致莫名其妙的问题出现。\n\n&emsp;&emsp;故写代码时应明确规定默认情况下应由谁来对参数进行检查，例外的函数也应在注释中指明情况。\n\n## 命名规范\n\n> 标识符的命名规则历来是一个敏感话题，典型的命名风格如unix风格、windows风格等，从来无法达成共识。实际上，各种风格都有其优势也有其劣势，而且往往和个人的审美观有关。我们对标识符定义主要是为了让团队的代码看起来尽可能统一，有利于代码的后续阅读和修改，产品可以根据自己的实际需要指定命名风格，规范中不再做统一的规定。\n>\n> 复制自：https://blog.csdn.net/m0_38106923/article/details/105042594\n\n### 大分类\n\n#### 一、驼峰式命名\n\n&emsp;&emsp;第一个单词首字母小写，后面其他单词首字母大写(又称小驼峰式)。我在本文列出的所有代码均遵循该命名方式，这里就不单独举例了。\n\n#### 二、帕斯卡命名\n\n&emsp;&emsp;和驼峰式命名类似，只不过将首字母小写改为了首字母大写（故也被称为大驼峰式），也不单独举例。\n\n#### 三、下划线命名\n\n&emsp;&emsp;所有字母小写，每个单词之间使用单下划线隔开。（PS：这个命名方法的名字是我瞎取的。）\n\n```c\nint data_list;\ndouble sum_result;\n```\n\n#### 四、匈牙利命名\n\n&emsp;&emsp;该命名方法不推荐使用，因为其最终使得代码更加难懂，远离了规范的本意，如果想要了解请自行百度。\n\n### 补充\n\n#### 常量命名方法\n\n&emsp;&emsp;常量（包括枚举常量）命名建议同意采用全部字母大写，单词之间采用单下划线分割的命名格式。这样子有利于一眼识别出该字段指向一个常量。\n\n```c\n#define PI_ROUNDED 3.1415926\n```\n\n#### 函数命名\n\n&emsp;&emsp;函数命名一般采用&ensp;动词&ensp;+&ensp;名词&ensp;的命名方式，因为函数大都是用来执行某一个动作的，没有动作的函数是无意义的。\n\n```c\ndouble getPI();\nint getData();\nint max(int a, int b);\nint min(int a, int b);\n```\n\n#### 注意事项\n\n&emsp;&emsp;除了头文件或编译开关等特殊定义，所有常量变量不要用下划线（不论几个）开头，因为下划线开头的常量都是一些内部的定义。\n\n&emsp;&emsp;禁止使用单字节命名变量，但 允许 定义i 、j、k作为局部循环变量\n\n&emsp;&emsp;不建议使用匈牙利命名法\n\n&emsp;&emsp;全局变量应增加`g_`前缀，静态变量应增加`s_`\n\n&emsp;&emsp;尽量避免名字中出现数字编号，除非逻辑上的确需要编号\n\n&emsp;&emsp;除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音\n\n## 变量\n\n### 一个变量对应一个用途\n\n&emsp;&emsp;一个变量只用来表示一个特定功能，不能把一个变量作多种用途，即同一变量取值不同时，其代表的意义也不同。\n\n### 尽量使用 const 定义代替宏\n\n&emsp;&emsp;一下内容复制自：https://blog.csdn.net/m0_38106923/article/details/105042594\n\n&emsp;&emsp;“尽量用编译器而不用预处理”，因为#define经常被认为好象不是语言本身的一部分。看下面的语句：\n\n```c\n#define ASPECT_RATIO 1.653\n```\n\n&emsp;&emsp;编译器会永远也看不到ASPECT_RATIO这个符号名，因为在源码进入编译器之前，它会被预处理程序去掉，于是ASPECT_RATIO不会加入到符号列表中。如果涉及到这个常量的代码在编译时报错，就会很令人费解，因为报错信息指的是1.653，而不是ASPECT_RATIO。如果ASPECT_RATIO不是在你自己写的头文件中定义的，你就会奇怪1.653是从哪里来的，甚至会花时间跟踪下去。这个问题也会出现在符号调试器中，因为同样地，你所写的符号名不会出现在符号列表中。\n解决这个问题的方案很简单：不用预处理宏，定义一个常量：\n\n```c\nconst double ASPECT_RATIO = 1.653;\n```\n\n## 表达式\n\n### 函数调用不要作为另一个函数的参数使用\n\n&emsp;&emsp;不要将一个函数的返回值当作另一个函数的参数，这样子既不利于调试和阅读，也有可能导致意想不到的运算结果，例如：\n\n```c\n//该代码摘自：https://blog.csdn.net/m0_38106923/article/details/105042594\nint g_var;\n \nint fun1()\n{\n    g_var += 10;\n    return g_var;\n}\n \nint fun2()\n{\n    g_var += 100;\n    return g_var;\n}\n \nint main(int argc, char *argv[], char *envp[])\n{\n    g_var = 1;\n    printf(\"func1: %d, func2: %d\\n\", fun1(), fun2());\n    g_var = 1;\n    printf(\"func2: %d, func1: %d\\n\", fun2(), fun1());\n}\n```\n\n### 赋值语句不要写在if等语句中\n\n&emsp;&emsp;永远不要将赋值语句写在`if`中，因为这样会导致后期错误排查时无法明确判断到底是写错了还是故意要在`if`里面给这个值赋值。\n\n### 不要过分依赖运算符优先级\n\n&emsp;&emsp;在一段代码中包含多许多运算符时，使用括号表明执行顺序，不要使用优先级确保执行顺序，否则会导致代码阅读困难，也很容易出错。\n\n## 注释\n\n### 学会书写优秀的代码\n\n&emsp;&emsp;优秀的代码可以做到自解释，即不需要书写注释也能让人明白代码的含义。\n\n### 不要过多的使用注释\n\n&emsp;&emsp;注释的本意是帮助人理解代码，过多的注释会让代码变得杂乱无章，起到反作用。\n\n### 注释的语言\n\n&emsp;&emsp;注释使用何种语言并没有硬性要求，但是考虑到生活环境应该优先使用中文，不要为了撞壁写出自己都读不懂的英文注释。\n\n### 注释的位置\n\n&emsp;&emsp;注释应放在被注释目标的上方或右方，不要放到下方。\n\n## 补充\n\n### 编译器警告\n\n&emsp;&emsp;尽量将编译器警告调到最高级别，这样你更容易发现自己代码的问题。\n\n### 参考资料：\n\n&emsp;&emsp;按参考程度排序，程度越深越靠前。\n\n<ul>\n    <li>https://blog.csdn.net/m0_38106923/article/details/105042594</li>\n    <li>http://c.biancheng.net/view/158.html</li>\n    <li>https://zhuanlan.zhihu.com/p/54121195</li>\n    <li>http://www.360doc.com/content/18/0830/08/11881101_782310615.shtml</li>\n</ul>\n\n\n","source":"_posts/c_standard.md","raw":"---\ntitle: 浅读C语言代码规范\ndate: 2021-09-05 16:49:06\ncategories:\n  - C/C++\ntags:\n  - 规范\n  - 教程\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b6.jpg\ndescription: 这里简单描述了C语言的代码规范，部分规则其他语言也可参考。\n---\n\n# 前言\n\n&emsp;&emsp;在编写程序的过程中如果不遵守编译器的规定，编译器在编译时就会报错，这个规定叫作规则。但是有一种规定，它是一种约定成俗的规则，即使不按照那种规定也不会出错，这种规定就叫作规范。虽然在编写代码的过程中不遵守规范不会影响代码的运行结果，但会影响自己以及他人阅读代码，从而增加错误排查、理解代码的难度（极端例子可见[我之前写的文章](https://www.bilibili.com/read/cv4389953)）。并且在未来步入职场的时候，不良的代码书写习惯也可能会使你丢掉一个工作。\n\n&emsp;&emsp;代码规范写出来内容很多，可能有些人会抱怨：“这么多怎么记得住？！”。但实际上，代码规范并不需要背记。我们要首先理解代码规范的目的是什么？是让代码更整洁、更易懂。所以有些时候只要能保证代码整洁，就算不严格遵守代码规范依然没有问题。同时这也代表着我们不需要完全将规范背下来，只需要知道一些最基本的内容，然后加以练习、养成习惯，就能自然而然的写出整洁有效的代码。而日后再回顾以前的练习，你也会庆幸自己注意了这方面的内容。\n\n---\n\n# 正文\n\n---\n\n## 排版\n\n&emsp;&emsp;排版是规范中最为重要的部分，正确的排版可以让代码更加清晰。\n\n### 缩进\n\n&emsp;&emsp;如同写文章每个自然段前要加两个空格一般，写代码同样需要在一些部分添加空格来对齐代码。比如：\n\n<ul>\n    <li>顶层元素不空格</li>\n    <li>每遇到一个<b>{</b>，下面的代码缩进就要多一段</li>\n    <li>如果一个字符串被拆成了多行，那么应该使用空格将字符串开头对齐</li>\n    <li>如果一行代码被拆成了多行，应添加空格表明这几行代码的包含关系</li>\n</ul>\n\n&emsp;&emsp;一段缩进一般为4格或者5格。同时应避免使用制表符（tab）进行缩进，因为使用制表符在不同的编辑器中显示效果可能不同（如果你的IDE会将tab键自动转换为空格进行缩进可以无视这个）。\n\n### 每个函数前后加空行\n\n```c\nunsigned int mult(int start, int end) {\n    unsigned int result = 1;\n    for (int i = start; i <= end; ++i) {\n        result *= i;\n    }\n    return result;\n}\n\nunsigned int cnm(int n, int m) {\n    if (n- m < m + 1)\n        return mult(m + 1, n) / mult(1, n - m);\n    else\n        return mult(n - m + 1, n) / mult(1, m);\n}\n```\n\n### 同一个函数中功能差别较大的代码块之间添加空行\n\n&emsp;&emsp;比如上面几行代码完成的是一个功能，下面几行代码完成的是另一个功能，那么它们中间就要加空行。这样看起来更清晰。因为C语言的例子我没有找到，这里拿Java写的一个例子来充个数。\n\n![](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/standard/dmk.jpg)\n\n### 集中的变量声明后添加空行\n\n&emsp;&emsp;如果你把函数中的变量全部写到了函数头（数量较多），那么应在声明后添加空行，如果数量不多可以不添加空行。\n\n```c\nint amount,\t\t//...\n    year,\t\t//...\n    month,\t\t//...\n    day,\t\t//...\n    min,\t\t//...\n    wula,\t\t//...\n    oula,\t\t//...\n    muda;\t\t//...\n\n//do something\n```\n\n\n\n### 善用空格\n\n&emsp;&emsp;除`.`、`!`、`~`、`++`、`--`、'('、'['、`->`等与前（或后）文密切相关的操作符外，所有操作符前后都应添加空格，同时关键字后也应添加空格。\n\n&emsp;&emsp;**注意：一个空格足矣，不要连续敲一堆空格（除非你在对齐代码）。**\n\n```c\nint sum = a + b;\nbool canPrint = sum > 0;\nbool continueRun = sum >= 10;\nif (canPaint) printf(\"%d\", sum);\nif (!continueRun) return false;\n```\n\n\n\n### 一条语句不要过长\n\n&emsp;&emsp;某些情况下我们可能需要写一行非常长的代码（比如包含超长字符串），这时候我们应当将这一行代码拆分为多行，避免代码长度超过屏幕显示宽度。一般情况下代码宽度标准为80，读者也可根据自己屏幕的宽度适当增加这个宽度。\n\n```c\nprintf(\"乌拉乌拉阿斯蒂芬卢卡斯的的规划区内我发噶卫生间而她却尔雅如附件阿斯顿佛为日投标文件拷入按时灯笼裤能否勾起我i而后体哦我石达开你发给i哦请问然后那天给他\");\n//这里上下两段代码效果是一样的，显然后者更加符合规范\nprintf(\"乌拉乌拉阿斯蒂芬卢卡斯的的规划区内我发噶卫生间\"\n       \"而她却尔雅如附件阿斯顿佛为日投标文件拷入按时灯笼裤能否\"\n       \"勾起我i而后体哦我石达开你发给i哦请问然后那天给他\");\n```\n\n\n\n### 一行仅包含一个变量声明（特殊情况例外）\n\n&emsp;&emsp;正常情况下，一行仅包含一条变量声明，这样子也方便为变量添加注释。\n\n```c\ndouble pi = 3.1415;\t //π\nint r;\t\t\t\t//原半径\nint c;\t\t\t\t//周长\nint s;\t\t\t\t//面积\n```\n\n\n\n### 控制语句语句独占一行\n\n&emsp;&emsp;正常情况下，if 、for 、 while 、case 、switch 、default 等语句独自占用一行，但如果后续代码非常短也可以共同占用一行。\n\n```c\n//变量赋值这里省略\nint min;\nbool con;\nswitch (min) {\n    case 0:\n        //do something...\n        break;\n    case 1:\n        for (int i = 0; i < min; ++i) {\n            //do something...\n        }\n        break;\n    case 2:\n        while (min != 0) {\n            //do something...\n        }\n        break;\n    case 3: return 0;\n    default: return con ? 1 : 2;\n}\n```\n\n### 大括号的位置\n\n&emsp;&emsp;大括号书写的位置有两种写法，读者选择一种使用即可，不要多种混用。\n\n```c\n//第一种\nint main() {\n}\n//第二种\nint main()\n{\n}\n```\n\n## 函数\n\n### 一个函数不要过长\n\n&emsp;&emsp;一个函数的行数尽量维持在50（或80）以下（非空非注释行）。\n\n&emsp;&emsp;但有些函数例外，这些函数可能集成了非常庞大的单个功能，同时由于算法的复杂性无法进行有效的拆分（即拆分可能使代码变得更加复杂难懂）。\n\n### 重复的代码提取为一个函数\n\n&emsp;&emsp;如果有一个功能在多个地方被使用，那么应该这个功能提炼成一个独立的函数，这样使用这个功能的时候直接调用这个函数就可以了，有效减少了重复代码。\n\n### 一个函数仅对应一个功能\n\n&emsp;&emsp;一个函数完成多个任务是书写代码的大忌，这样不仅会让函数命名变得复杂，同时会让函数的职责变得不明确，增大了后期维护、修改以及理解的难度。\n\n### 对参数的合法性检查应有明确的规定\n\n&emsp;&emsp;通常情况下，应当对输入函数的参数进行检查，避免出现意外的情况。但是谁检查是一个普遍存在的问题。有两个极端的情况：一是调用者与被调用者都检查了，二是调用者与被调用者都没有检查。前者虽不会带来运行结果错误，但会出现代码冗余、运行效率降低的情况，后者则可能会导致莫名其妙的问题出现。\n\n&emsp;&emsp;故写代码时应明确规定默认情况下应由谁来对参数进行检查，例外的函数也应在注释中指明情况。\n\n## 命名规范\n\n> 标识符的命名规则历来是一个敏感话题，典型的命名风格如unix风格、windows风格等，从来无法达成共识。实际上，各种风格都有其优势也有其劣势，而且往往和个人的审美观有关。我们对标识符定义主要是为了让团队的代码看起来尽可能统一，有利于代码的后续阅读和修改，产品可以根据自己的实际需要指定命名风格，规范中不再做统一的规定。\n>\n> 复制自：https://blog.csdn.net/m0_38106923/article/details/105042594\n\n### 大分类\n\n#### 一、驼峰式命名\n\n&emsp;&emsp;第一个单词首字母小写，后面其他单词首字母大写(又称小驼峰式)。我在本文列出的所有代码均遵循该命名方式，这里就不单独举例了。\n\n#### 二、帕斯卡命名\n\n&emsp;&emsp;和驼峰式命名类似，只不过将首字母小写改为了首字母大写（故也被称为大驼峰式），也不单独举例。\n\n#### 三、下划线命名\n\n&emsp;&emsp;所有字母小写，每个单词之间使用单下划线隔开。（PS：这个命名方法的名字是我瞎取的。）\n\n```c\nint data_list;\ndouble sum_result;\n```\n\n#### 四、匈牙利命名\n\n&emsp;&emsp;该命名方法不推荐使用，因为其最终使得代码更加难懂，远离了规范的本意，如果想要了解请自行百度。\n\n### 补充\n\n#### 常量命名方法\n\n&emsp;&emsp;常量（包括枚举常量）命名建议同意采用全部字母大写，单词之间采用单下划线分割的命名格式。这样子有利于一眼识别出该字段指向一个常量。\n\n```c\n#define PI_ROUNDED 3.1415926\n```\n\n#### 函数命名\n\n&emsp;&emsp;函数命名一般采用&ensp;动词&ensp;+&ensp;名词&ensp;的命名方式，因为函数大都是用来执行某一个动作的，没有动作的函数是无意义的。\n\n```c\ndouble getPI();\nint getData();\nint max(int a, int b);\nint min(int a, int b);\n```\n\n#### 注意事项\n\n&emsp;&emsp;除了头文件或编译开关等特殊定义，所有常量变量不要用下划线（不论几个）开头，因为下划线开头的常量都是一些内部的定义。\n\n&emsp;&emsp;禁止使用单字节命名变量，但 允许 定义i 、j、k作为局部循环变量\n\n&emsp;&emsp;不建议使用匈牙利命名法\n\n&emsp;&emsp;全局变量应增加`g_`前缀，静态变量应增加`s_`\n\n&emsp;&emsp;尽量避免名字中出现数字编号，除非逻辑上的确需要编号\n\n&emsp;&emsp;除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音\n\n## 变量\n\n### 一个变量对应一个用途\n\n&emsp;&emsp;一个变量只用来表示一个特定功能，不能把一个变量作多种用途，即同一变量取值不同时，其代表的意义也不同。\n\n### 尽量使用 const 定义代替宏\n\n&emsp;&emsp;一下内容复制自：https://blog.csdn.net/m0_38106923/article/details/105042594\n\n&emsp;&emsp;“尽量用编译器而不用预处理”，因为#define经常被认为好象不是语言本身的一部分。看下面的语句：\n\n```c\n#define ASPECT_RATIO 1.653\n```\n\n&emsp;&emsp;编译器会永远也看不到ASPECT_RATIO这个符号名，因为在源码进入编译器之前，它会被预处理程序去掉，于是ASPECT_RATIO不会加入到符号列表中。如果涉及到这个常量的代码在编译时报错，就会很令人费解，因为报错信息指的是1.653，而不是ASPECT_RATIO。如果ASPECT_RATIO不是在你自己写的头文件中定义的，你就会奇怪1.653是从哪里来的，甚至会花时间跟踪下去。这个问题也会出现在符号调试器中，因为同样地，你所写的符号名不会出现在符号列表中。\n解决这个问题的方案很简单：不用预处理宏，定义一个常量：\n\n```c\nconst double ASPECT_RATIO = 1.653;\n```\n\n## 表达式\n\n### 函数调用不要作为另一个函数的参数使用\n\n&emsp;&emsp;不要将一个函数的返回值当作另一个函数的参数，这样子既不利于调试和阅读，也有可能导致意想不到的运算结果，例如：\n\n```c\n//该代码摘自：https://blog.csdn.net/m0_38106923/article/details/105042594\nint g_var;\n \nint fun1()\n{\n    g_var += 10;\n    return g_var;\n}\n \nint fun2()\n{\n    g_var += 100;\n    return g_var;\n}\n \nint main(int argc, char *argv[], char *envp[])\n{\n    g_var = 1;\n    printf(\"func1: %d, func2: %d\\n\", fun1(), fun2());\n    g_var = 1;\n    printf(\"func2: %d, func1: %d\\n\", fun2(), fun1());\n}\n```\n\n### 赋值语句不要写在if等语句中\n\n&emsp;&emsp;永远不要将赋值语句写在`if`中，因为这样会导致后期错误排查时无法明确判断到底是写错了还是故意要在`if`里面给这个值赋值。\n\n### 不要过分依赖运算符优先级\n\n&emsp;&emsp;在一段代码中包含多许多运算符时，使用括号表明执行顺序，不要使用优先级确保执行顺序，否则会导致代码阅读困难，也很容易出错。\n\n## 注释\n\n### 学会书写优秀的代码\n\n&emsp;&emsp;优秀的代码可以做到自解释，即不需要书写注释也能让人明白代码的含义。\n\n### 不要过多的使用注释\n\n&emsp;&emsp;注释的本意是帮助人理解代码，过多的注释会让代码变得杂乱无章，起到反作用。\n\n### 注释的语言\n\n&emsp;&emsp;注释使用何种语言并没有硬性要求，但是考虑到生活环境应该优先使用中文，不要为了撞壁写出自己都读不懂的英文注释。\n\n### 注释的位置\n\n&emsp;&emsp;注释应放在被注释目标的上方或右方，不要放到下方。\n\n## 补充\n\n### 编译器警告\n\n&emsp;&emsp;尽量将编译器警告调到最高级别，这样你更容易发现自己代码的问题。\n\n### 参考资料：\n\n&emsp;&emsp;按参考程度排序，程度越深越靠前。\n\n<ul>\n    <li>https://blog.csdn.net/m0_38106923/article/details/105042594</li>\n    <li>http://c.biancheng.net/view/158.html</li>\n    <li>https://zhuanlan.zhihu.com/p/54121195</li>\n    <li>http://www.360doc.com/content/18/0830/08/11881101_782310615.shtml</li>\n</ul>\n\n\n","slug":"c_standard","published":1,"updated":"2021-10-12T12:15:49.524Z","_id":"cku22zp34000b7kwq48tv5xps","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>&emsp;&emsp;在编写程序的过程中如果不遵守编译器的规定，编译器在编译时就会报错，这个规定叫作规则。但是有一种规定，它是一种约定成俗的规则，即使不按照那种规定也不会出错，这种规定就叫作规范。虽然在编写代码的过程中不遵守规范不会影响代码的运行结果，但会影响自己以及他人阅读代码，从而增加错误排查、理解代码的难度（极端例子可见<a href=\"https://www.bilibili.com/read/cv4389953\">我之前写的文章</a>）。并且在未来步入职场的时候，不良的代码书写习惯也可能会使你丢掉一个工作。</p>\n<p>&emsp;&emsp;代码规范写出来内容很多，可能有些人会抱怨：“这么多怎么记得住？！”。但实际上，代码规范并不需要背记。我们要首先理解代码规范的目的是什么？是让代码更整洁、更易懂。所以有些时候只要能保证代码整洁，就算不严格遵守代码规范依然没有问题。同时这也代表着我们不需要完全将规范背下来，只需要知道一些最基本的内容，然后加以练习、养成习惯，就能自然而然的写出整洁有效的代码。而日后再回顾以前的练习，你也会庆幸自己注意了这方面的内容。</p>\n<hr>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><hr>\n<h2 id=\"排版\"><a href=\"#排版\" class=\"headerlink\" title=\"排版\"></a>排版</h2><p>&emsp;&emsp;排版是规范中最为重要的部分，正确的排版可以让代码更加清晰。</p>\n<h3 id=\"缩进\"><a href=\"#缩进\" class=\"headerlink\" title=\"缩进\"></a>缩进</h3><p>&emsp;&emsp;如同写文章每个自然段前要加两个空格一般，写代码同样需要在一些部分添加空格来对齐代码。比如：</p>\n<ul>\n    <li>顶层元素不空格</li>\n    <li>每遇到一个<b>{</b>，下面的代码缩进就要多一段</li>\n    <li>如果一个字符串被拆成了多行，那么应该使用空格将字符串开头对齐</li>\n    <li>如果一行代码被拆成了多行，应添加空格表明这几行代码的包含关系</li>\n</ul>\n\n<p>&emsp;&emsp;一段缩进一般为4格或者5格。同时应避免使用制表符（tab）进行缩进，因为使用制表符在不同的编辑器中显示效果可能不同（如果你的IDE会将tab键自动转换为空格进行缩进可以无视这个）。</p>\n<h3 id=\"每个函数前后加空行\"><a href=\"#每个函数前后加空行\" class=\"headerlink\" title=\"每个函数前后加空行\"></a>每个函数前后加空行</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">mult</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> start, <span class=\"hljs-keyword\">int</span> end)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> result = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = start; i &lt;= end; ++i) &#123;<br>        result *= i;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">cnm</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">int</span> m)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (n- m &lt; m + <span class=\"hljs-number\">1</span>)<br>        <span class=\"hljs-keyword\">return</span> mult(m + <span class=\"hljs-number\">1</span>, n) / mult(<span class=\"hljs-number\">1</span>, n - m);<br>    <span class=\"hljs-keyword\">else</span><br>        <span class=\"hljs-keyword\">return</span> mult(n - m + <span class=\"hljs-number\">1</span>, n) / mult(<span class=\"hljs-number\">1</span>, m);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"同一个函数中功能差别较大的代码块之间添加空行\"><a href=\"#同一个函数中功能差别较大的代码块之间添加空行\" class=\"headerlink\" title=\"同一个函数中功能差别较大的代码块之间添加空行\"></a>同一个函数中功能差别较大的代码块之间添加空行</h3><p>&emsp;&emsp;比如上面几行代码完成的是一个功能，下面几行代码完成的是另一个功能，那么它们中间就要加空行。这样看起来更清晰。因为C语言的例子我没有找到，这里拿Java写的一个例子来充个数。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/standard/dmk.jpg\" alt></p>\n<h3 id=\"集中的变量声明后添加空行\"><a href=\"#集中的变量声明后添加空行\" class=\"headerlink\" title=\"集中的变量声明后添加空行\"></a>集中的变量声明后添加空行</h3><p>&emsp;&emsp;如果你把函数中的变量全部写到了函数头（数量较多），那么应在声明后添加空行，如果数量不多可以不添加空行。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">int</span> amount,\t\t<span class=\"hljs-comment\">//...</span><br>    year,\t\t<span class=\"hljs-comment\">//...</span><br>    month,\t\t<span class=\"hljs-comment\">//...</span><br>    day,\t\t<span class=\"hljs-comment\">//...</span><br>    min,\t\t<span class=\"hljs-comment\">//...</span><br>    wula,\t\t<span class=\"hljs-comment\">//...</span><br>    oula,\t\t<span class=\"hljs-comment\">//...</span><br>    muda;\t\t<span class=\"hljs-comment\">//...</span><br><br><span class=\"hljs-comment\">//do something</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"善用空格\"><a href=\"#善用空格\" class=\"headerlink\" title=\"善用空格\"></a>善用空格</h3><p>&emsp;&emsp;除<code>.</code>、<code>!</code>、<code>~</code>、<code>++</code>、<code>--</code>、’(‘、’[‘、<code>-&gt;</code>等与前（或后）文密切相关的操作符外，所有操作符前后都应添加空格，同时关键字后也应添加空格。</p>\n<p>&emsp;&emsp;<strong>注意：一个空格足矣，不要连续敲一堆空格（除非你在对齐代码）。</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">int</span> sum = a + b;<br><span class=\"hljs-keyword\">bool</span> canPrint = sum &gt; <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">bool</span> continueRun = sum &gt;= <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-keyword\">if</span> (canPaint) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, sum);<br><span class=\"hljs-keyword\">if</span> (!continueRun) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"一条语句不要过长\"><a href=\"#一条语句不要过长\" class=\"headerlink\" title=\"一条语句不要过长\"></a>一条语句不要过长</h3><p>&emsp;&emsp;某些情况下我们可能需要写一行非常长的代码（比如包含超长字符串），这时候我们应当将这一行代码拆分为多行，避免代码长度超过屏幕显示宽度。一般情况下代码宽度标准为80，读者也可根据自己屏幕的宽度适当增加这个宽度。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;乌拉乌拉阿斯蒂芬卢卡斯的的规划区内我发噶卫生间而她却尔雅如附件阿斯顿佛为日投标文件拷入按时灯笼裤能否勾起我i而后体哦我石达开你发给i哦请问然后那天给他&quot;</span>);<br><span class=\"hljs-comment\">//这里上下两段代码效果是一样的，显然后者更加符合规范</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;乌拉乌拉阿斯蒂芬卢卡斯的的规划区内我发噶卫生间&quot;</span><br>       <span class=\"hljs-string\">&quot;而她却尔雅如附件阿斯顿佛为日投标文件拷入按时灯笼裤能否&quot;</span><br>       <span class=\"hljs-string\">&quot;勾起我i而后体哦我石达开你发给i哦请问然后那天给他&quot;</span>);<br></code></pre></td></tr></table></figure>\n<h3 id=\"一行仅包含一个变量声明（特殊情况例外）\"><a href=\"#一行仅包含一个变量声明（特殊情况例外）\" class=\"headerlink\" title=\"一行仅包含一个变量声明（特殊情况例外）\"></a>一行仅包含一个变量声明（特殊情况例外）</h3><p>&emsp;&emsp;正常情况下，一行仅包含一条变量声明，这样子也方便为变量添加注释。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">double</span> pi = <span class=\"hljs-number\">3.1415</span>;\t <span class=\"hljs-comment\">//π</span><br><span class=\"hljs-keyword\">int</span> r;\t\t\t\t<span class=\"hljs-comment\">//原半径</span><br><span class=\"hljs-keyword\">int</span> c;\t\t\t\t<span class=\"hljs-comment\">//周长</span><br><span class=\"hljs-keyword\">int</span> s;\t\t\t\t<span class=\"hljs-comment\">//面积</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"控制语句语句独占一行\"><a href=\"#控制语句语句独占一行\" class=\"headerlink\" title=\"控制语句语句独占一行\"></a>控制语句语句独占一行</h3><p>&emsp;&emsp;正常情况下，if 、for 、 while 、case 、switch 、default 等语句独自占用一行，但如果后续代码非常短也可以共同占用一行。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//变量赋值这里省略</span><br><span class=\"hljs-keyword\">int</span> min;<br><span class=\"hljs-keyword\">bool</span> con;<br><span class=\"hljs-keyword\">switch</span> (min) &#123;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-comment\">//do something...</span><br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; min; ++i) &#123;<br>            <span class=\"hljs-comment\">//do something...</span><br>        &#125;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:<br>        <span class=\"hljs-keyword\">while</span> (min != <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-comment\">//do something...</span><br>        &#125;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">default</span>: <span class=\"hljs-keyword\">return</span> con ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"大括号的位置\"><a href=\"#大括号的位置\" class=\"headerlink\" title=\"大括号的位置\"></a>大括号的位置</h3><p>&emsp;&emsp;大括号书写的位置有两种写法，读者选择一种使用即可，不要多种混用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//第一种</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>&#125;<br><span class=\"hljs-comment\">//第二种</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"一个函数不要过长\"><a href=\"#一个函数不要过长\" class=\"headerlink\" title=\"一个函数不要过长\"></a>一个函数不要过长</h3><p>&emsp;&emsp;一个函数的行数尽量维持在50（或80）以下（非空非注释行）。</p>\n<p>&emsp;&emsp;但有些函数例外，这些函数可能集成了非常庞大的单个功能，同时由于算法的复杂性无法进行有效的拆分（即拆分可能使代码变得更加复杂难懂）。</p>\n<h3 id=\"重复的代码提取为一个函数\"><a href=\"#重复的代码提取为一个函数\" class=\"headerlink\" title=\"重复的代码提取为一个函数\"></a>重复的代码提取为一个函数</h3><p>&emsp;&emsp;如果有一个功能在多个地方被使用，那么应该这个功能提炼成一个独立的函数，这样使用这个功能的时候直接调用这个函数就可以了，有效减少了重复代码。</p>\n<h3 id=\"一个函数仅对应一个功能\"><a href=\"#一个函数仅对应一个功能\" class=\"headerlink\" title=\"一个函数仅对应一个功能\"></a>一个函数仅对应一个功能</h3><p>&emsp;&emsp;一个函数完成多个任务是书写代码的大忌，这样不仅会让函数命名变得复杂，同时会让函数的职责变得不明确，增大了后期维护、修改以及理解的难度。</p>\n<h3 id=\"对参数的合法性检查应有明确的规定\"><a href=\"#对参数的合法性检查应有明确的规定\" class=\"headerlink\" title=\"对参数的合法性检查应有明确的规定\"></a>对参数的合法性检查应有明确的规定</h3><p>&emsp;&emsp;通常情况下，应当对输入函数的参数进行检查，避免出现意外的情况。但是谁检查是一个普遍存在的问题。有两个极端的情况：一是调用者与被调用者都检查了，二是调用者与被调用者都没有检查。前者虽不会带来运行结果错误，但会出现代码冗余、运行效率降低的情况，后者则可能会导致莫名其妙的问题出现。</p>\n<p>&emsp;&emsp;故写代码时应明确规定默认情况下应由谁来对参数进行检查，例外的函数也应在注释中指明情况。</p>\n<h2 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h2><blockquote>\n<p>标识符的命名规则历来是一个敏感话题，典型的命名风格如unix风格、windows风格等，从来无法达成共识。实际上，各种风格都有其优势也有其劣势，而且往往和个人的审美观有关。我们对标识符定义主要是为了让团队的代码看起来尽可能统一，有利于代码的后续阅读和修改，产品可以根据自己的实际需要指定命名风格，规范中不再做统一的规定。</p>\n<p>复制自：<a href=\"https://blog.csdn.net/m0_38106923/article/details/105042594\">https://blog.csdn.net/m0_38106923/article/details/105042594</a></p>\n</blockquote>\n<h3 id=\"大分类\"><a href=\"#大分类\" class=\"headerlink\" title=\"大分类\"></a>大分类</h3><h4 id=\"一、驼峰式命名\"><a href=\"#一、驼峰式命名\" class=\"headerlink\" title=\"一、驼峰式命名\"></a>一、驼峰式命名</h4><p>&emsp;&emsp;第一个单词首字母小写，后面其他单词首字母大写(又称小驼峰式)。我在本文列出的所有代码均遵循该命名方式，这里就不单独举例了。</p>\n<h4 id=\"二、帕斯卡命名\"><a href=\"#二、帕斯卡命名\" class=\"headerlink\" title=\"二、帕斯卡命名\"></a>二、帕斯卡命名</h4><p>&emsp;&emsp;和驼峰式命名类似，只不过将首字母小写改为了首字母大写（故也被称为大驼峰式），也不单独举例。</p>\n<h4 id=\"三、下划线命名\"><a href=\"#三、下划线命名\" class=\"headerlink\" title=\"三、下划线命名\"></a>三、下划线命名</h4><p>&emsp;&emsp;所有字母小写，每个单词之间使用单下划线隔开。（PS：这个命名方法的名字是我瞎取的。）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">int</span> data_list;<br><span class=\"hljs-keyword\">double</span> sum_result;<br></code></pre></td></tr></table></figure>\n<h4 id=\"四、匈牙利命名\"><a href=\"#四、匈牙利命名\" class=\"headerlink\" title=\"四、匈牙利命名\"></a>四、匈牙利命名</h4><p>&emsp;&emsp;该命名方法不推荐使用，因为其最终使得代码更加难懂，远离了规范的本意，如果想要了解请自行百度。</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><h4 id=\"常量命名方法\"><a href=\"#常量命名方法\" class=\"headerlink\" title=\"常量命名方法\"></a>常量命名方法</h4><p>&emsp;&emsp;常量（包括枚举常量）命名建议同意采用全部字母大写，单词之间采用单下划线分割的命名格式。这样子有利于一眼识别出该字段指向一个常量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> PI_ROUNDED 3.1415926</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"函数命名\"><a href=\"#函数命名\" class=\"headerlink\" title=\"函数命名\"></a>函数命名</h4><p>&emsp;&emsp;函数命名一般采用&ensp;动词&ensp;+&ensp;名词&ensp;的命名方式，因为函数大都是用来执行某一个动作的，没有动作的函数是无意义的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">getPI</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getData</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>;<br></code></pre></td></tr></table></figure>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><p>&emsp;&emsp;除了头文件或编译开关等特殊定义，所有常量变量不要用下划线（不论几个）开头，因为下划线开头的常量都是一些内部的定义。</p>\n<p>&emsp;&emsp;禁止使用单字节命名变量，但 允许 定义i 、j、k作为局部循环变量</p>\n<p>&emsp;&emsp;不建议使用匈牙利命名法</p>\n<p>&emsp;&emsp;全局变量应增加<code>g_</code>前缀，静态变量应增加<code>s_</code></p>\n<p>&emsp;&emsp;尽量避免名字中出现数字编号，除非逻辑上的确需要编号</p>\n<p>&emsp;&emsp;除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"一个变量对应一个用途\"><a href=\"#一个变量对应一个用途\" class=\"headerlink\" title=\"一个变量对应一个用途\"></a>一个变量对应一个用途</h3><p>&emsp;&emsp;一个变量只用来表示一个特定功能，不能把一个变量作多种用途，即同一变量取值不同时，其代表的意义也不同。</p>\n<h3 id=\"尽量使用-const-定义代替宏\"><a href=\"#尽量使用-const-定义代替宏\" class=\"headerlink\" title=\"尽量使用 const 定义代替宏\"></a>尽量使用 const 定义代替宏</h3><p>&emsp;&emsp;一下内容复制自：<a href=\"https://blog.csdn.net/m0_38106923/article/details/105042594\">https://blog.csdn.net/m0_38106923/article/details/105042594</a></p>\n<p>&emsp;&emsp;“尽量用编译器而不用预处理”，因为#define经常被认为好象不是语言本身的一部分。看下面的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> ASPECT_RATIO 1.653</span><br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;编译器会永远也看不到ASPECT_RATIO这个符号名，因为在源码进入编译器之前，它会被预处理程序去掉，于是ASPECT_RATIO不会加入到符号列表中。如果涉及到这个常量的代码在编译时报错，就会很令人费解，因为报错信息指的是1.653，而不是ASPECT_RATIO。如果ASPECT_RATIO不是在你自己写的头文件中定义的，你就会奇怪1.653是从哪里来的，甚至会花时间跟踪下去。这个问题也会出现在符号调试器中，因为同样地，你所写的符号名不会出现在符号列表中。<br>解决这个问题的方案很简单：不用预处理宏，定义一个常量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">double</span> ASPECT_RATIO = <span class=\"hljs-number\">1.653</span>;<br></code></pre></td></tr></table></figure>\n<h2 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h2><h3 id=\"函数调用不要作为另一个函数的参数使用\"><a href=\"#函数调用不要作为另一个函数的参数使用\" class=\"headerlink\" title=\"函数调用不要作为另一个函数的参数使用\"></a>函数调用不要作为另一个函数的参数使用</h3><p>&emsp;&emsp;不要将一个函数的返回值当作另一个函数的参数，这样子既不利于调试和阅读，也有可能导致意想不到的运算结果，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//该代码摘自：https://blog.csdn.net/m0_38106923/article/details/105042594</span><br><span class=\"hljs-keyword\">int</span> g_var;<br> <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">fun1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    g_var += <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">return</span> g_var;<br>&#125;<br> <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">fun2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    g_var += <span class=\"hljs-number\">100</span>;<br>    <span class=\"hljs-keyword\">return</span> g_var;<br>&#125;<br> <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[], <span class=\"hljs-keyword\">char</span> *envp[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    g_var = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;func1: %d, func2: %d\\n&quot;</span>, fun1(), fun2());<br>    g_var = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;func2: %d, func1: %d\\n&quot;</span>, fun2(), fun1());<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"赋值语句不要写在if等语句中\"><a href=\"#赋值语句不要写在if等语句中\" class=\"headerlink\" title=\"赋值语句不要写在if等语句中\"></a>赋值语句不要写在if等语句中</h3><p>&emsp;&emsp;永远不要将赋值语句写在<code>if</code>中，因为这样会导致后期错误排查时无法明确判断到底是写错了还是故意要在<code>if</code>里面给这个值赋值。</p>\n<h3 id=\"不要过分依赖运算符优先级\"><a href=\"#不要过分依赖运算符优先级\" class=\"headerlink\" title=\"不要过分依赖运算符优先级\"></a>不要过分依赖运算符优先级</h3><p>&emsp;&emsp;在一段代码中包含多许多运算符时，使用括号表明执行顺序，不要使用优先级确保执行顺序，否则会导致代码阅读困难，也很容易出错。</p>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><h3 id=\"学会书写优秀的代码\"><a href=\"#学会书写优秀的代码\" class=\"headerlink\" title=\"学会书写优秀的代码\"></a>学会书写优秀的代码</h3><p>&emsp;&emsp;优秀的代码可以做到自解释，即不需要书写注释也能让人明白代码的含义。</p>\n<h3 id=\"不要过多的使用注释\"><a href=\"#不要过多的使用注释\" class=\"headerlink\" title=\"不要过多的使用注释\"></a>不要过多的使用注释</h3><p>&emsp;&emsp;注释的本意是帮助人理解代码，过多的注释会让代码变得杂乱无章，起到反作用。</p>\n<h3 id=\"注释的语言\"><a href=\"#注释的语言\" class=\"headerlink\" title=\"注释的语言\"></a>注释的语言</h3><p>&emsp;&emsp;注释使用何种语言并没有硬性要求，但是考虑到生活环境应该优先使用中文，不要为了撞壁写出自己都读不懂的英文注释。</p>\n<h3 id=\"注释的位置\"><a href=\"#注释的位置\" class=\"headerlink\" title=\"注释的位置\"></a>注释的位置</h3><p>&emsp;&emsp;注释应放在被注释目标的上方或右方，不要放到下方。</p>\n<h2 id=\"补充-1\"><a href=\"#补充-1\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"编译器警告\"><a href=\"#编译器警告\" class=\"headerlink\" title=\"编译器警告\"></a>编译器警告</h3><p>&emsp;&emsp;尽量将编译器警告调到最高级别，这样你更容易发现自己代码的问题。</p>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p>&emsp;&emsp;按参考程度排序，程度越深越靠前。</p>\n<ul>\n    <li>https://blog.csdn.net/m0_38106923/article/details/105042594</li>\n    <li>http://c.biancheng.net/view/158.html</li>\n    <li>https://zhuanlan.zhihu.com/p/54121195</li>\n    <li>http://www.360doc.com/content/18/0830/08/11881101_782310615.shtml</li>\n</ul>\n\n\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"},{"name":"Akilar店长","link":"https://akilar.top","avatar":"https://akilar.top/img/siteicon/favicon.png","descr":"欢迎光临糖果屋","siteshot":"https://cdn.jsdelivr.net/gh/Akilarlxh/ScreenShot@gh-pages/akilar.top.jpg"}]}]}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>&emsp;&emsp;在编写程序的过程中如果不遵守编译器的规定，编译器在编译时就会报错，这个规定叫作规则。但是有一种规定，它是一种约定成俗的规则，即使不按照那种规定也不会出错，这种规定就叫作规范。虽然在编写代码的过程中不遵守规范不会影响代码的运行结果，但会影响自己以及他人阅读代码，从而增加错误排查、理解代码的难度（极端例子可见<a href=\"https://www.bilibili.com/read/cv4389953\">我之前写的文章</a>）。并且在未来步入职场的时候，不良的代码书写习惯也可能会使你丢掉一个工作。</p>\n<p>&emsp;&emsp;代码规范写出来内容很多，可能有些人会抱怨：“这么多怎么记得住？！”。但实际上，代码规范并不需要背记。我们要首先理解代码规范的目的是什么？是让代码更整洁、更易懂。所以有些时候只要能保证代码整洁，就算不严格遵守代码规范依然没有问题。同时这也代表着我们不需要完全将规范背下来，只需要知道一些最基本的内容，然后加以练习、养成习惯，就能自然而然的写出整洁有效的代码。而日后再回顾以前的练习，你也会庆幸自己注意了这方面的内容。</p>\n<hr>\n<h1 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h1><hr>\n<h2 id=\"排版\"><a href=\"#排版\" class=\"headerlink\" title=\"排版\"></a>排版</h2><p>&emsp;&emsp;排版是规范中最为重要的部分，正确的排版可以让代码更加清晰。</p>\n<h3 id=\"缩进\"><a href=\"#缩进\" class=\"headerlink\" title=\"缩进\"></a>缩进</h3><p>&emsp;&emsp;如同写文章每个自然段前要加两个空格一般，写代码同样需要在一些部分添加空格来对齐代码。比如：</p>\n<ul>\n    <li>顶层元素不空格</li>\n    <li>每遇到一个<b>{</b>，下面的代码缩进就要多一段</li>\n    <li>如果一个字符串被拆成了多行，那么应该使用空格将字符串开头对齐</li>\n    <li>如果一行代码被拆成了多行，应添加空格表明这几行代码的包含关系</li>\n</ul>\n\n<p>&emsp;&emsp;一段缩进一般为4格或者5格。同时应避免使用制表符（tab）进行缩进，因为使用制表符在不同的编辑器中显示效果可能不同（如果你的IDE会将tab键自动转换为空格进行缩进可以无视这个）。</p>\n<h3 id=\"每个函数前后加空行\"><a href=\"#每个函数前后加空行\" class=\"headerlink\" title=\"每个函数前后加空行\"></a>每个函数前后加空行</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">mult</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> start, <span class=\"hljs-keyword\">int</span> end)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> result = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = start; i &lt;= end; ++i) &#123;<br>        result *= i;<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> result;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">unsigned</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">cnm</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n, <span class=\"hljs-keyword\">int</span> m)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (n- m &lt; m + <span class=\"hljs-number\">1</span>)<br>        <span class=\"hljs-keyword\">return</span> mult(m + <span class=\"hljs-number\">1</span>, n) / mult(<span class=\"hljs-number\">1</span>, n - m);<br>    <span class=\"hljs-keyword\">else</span><br>        <span class=\"hljs-keyword\">return</span> mult(n - m + <span class=\"hljs-number\">1</span>, n) / mult(<span class=\"hljs-number\">1</span>, m);<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"同一个函数中功能差别较大的代码块之间添加空行\"><a href=\"#同一个函数中功能差别较大的代码块之间添加空行\" class=\"headerlink\" title=\"同一个函数中功能差别较大的代码块之间添加空行\"></a>同一个函数中功能差别较大的代码块之间添加空行</h3><p>&emsp;&emsp;比如上面几行代码完成的是一个功能，下面几行代码完成的是另一个功能，那么它们中间就要加空行。这样看起来更清晰。因为C语言的例子我没有找到，这里拿Java写的一个例子来充个数。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/standard/dmk.jpg\" alt></p>\n<h3 id=\"集中的变量声明后添加空行\"><a href=\"#集中的变量声明后添加空行\" class=\"headerlink\" title=\"集中的变量声明后添加空行\"></a>集中的变量声明后添加空行</h3><p>&emsp;&emsp;如果你把函数中的变量全部写到了函数头（数量较多），那么应在声明后添加空行，如果数量不多可以不添加空行。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">int</span> amount,\t\t<span class=\"hljs-comment\">//...</span><br>    year,\t\t<span class=\"hljs-comment\">//...</span><br>    month,\t\t<span class=\"hljs-comment\">//...</span><br>    day,\t\t<span class=\"hljs-comment\">//...</span><br>    min,\t\t<span class=\"hljs-comment\">//...</span><br>    wula,\t\t<span class=\"hljs-comment\">//...</span><br>    oula,\t\t<span class=\"hljs-comment\">//...</span><br>    muda;\t\t<span class=\"hljs-comment\">//...</span><br><br><span class=\"hljs-comment\">//do something</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"善用空格\"><a href=\"#善用空格\" class=\"headerlink\" title=\"善用空格\"></a>善用空格</h3><p>&emsp;&emsp;除<code>.</code>、<code>!</code>、<code>~</code>、<code>++</code>、<code>--</code>、’(‘、’[‘、<code>-&gt;</code>等与前（或后）文密切相关的操作符外，所有操作符前后都应添加空格，同时关键字后也应添加空格。</p>\n<p>&emsp;&emsp;<strong>注意：一个空格足矣，不要连续敲一堆空格（除非你在对齐代码）。</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">int</span> sum = a + b;<br><span class=\"hljs-keyword\">bool</span> canPrint = sum &gt; <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">bool</span> continueRun = sum &gt;= <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-keyword\">if</span> (canPaint) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, sum);<br><span class=\"hljs-keyword\">if</span> (!continueRun) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br></code></pre></td></tr></table></figure>\n<h3 id=\"一条语句不要过长\"><a href=\"#一条语句不要过长\" class=\"headerlink\" title=\"一条语句不要过长\"></a>一条语句不要过长</h3><p>&emsp;&emsp;某些情况下我们可能需要写一行非常长的代码（比如包含超长字符串），这时候我们应当将这一行代码拆分为多行，避免代码长度超过屏幕显示宽度。一般情况下代码宽度标准为80，读者也可根据自己屏幕的宽度适当增加这个宽度。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;乌拉乌拉阿斯蒂芬卢卡斯的的规划区内我发噶卫生间而她却尔雅如附件阿斯顿佛为日投标文件拷入按时灯笼裤能否勾起我i而后体哦我石达开你发给i哦请问然后那天给他&quot;</span>);<br><span class=\"hljs-comment\">//这里上下两段代码效果是一样的，显然后者更加符合规范</span><br><span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;乌拉乌拉阿斯蒂芬卢卡斯的的规划区内我发噶卫生间&quot;</span><br>       <span class=\"hljs-string\">&quot;而她却尔雅如附件阿斯顿佛为日投标文件拷入按时灯笼裤能否&quot;</span><br>       <span class=\"hljs-string\">&quot;勾起我i而后体哦我石达开你发给i哦请问然后那天给他&quot;</span>);<br></code></pre></td></tr></table></figure>\n<h3 id=\"一行仅包含一个变量声明（特殊情况例外）\"><a href=\"#一行仅包含一个变量声明（特殊情况例外）\" class=\"headerlink\" title=\"一行仅包含一个变量声明（特殊情况例外）\"></a>一行仅包含一个变量声明（特殊情况例外）</h3><p>&emsp;&emsp;正常情况下，一行仅包含一条变量声明，这样子也方便为变量添加注释。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">double</span> pi = <span class=\"hljs-number\">3.1415</span>;\t <span class=\"hljs-comment\">//π</span><br><span class=\"hljs-keyword\">int</span> r;\t\t\t\t<span class=\"hljs-comment\">//原半径</span><br><span class=\"hljs-keyword\">int</span> c;\t\t\t\t<span class=\"hljs-comment\">//周长</span><br><span class=\"hljs-keyword\">int</span> s;\t\t\t\t<span class=\"hljs-comment\">//面积</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"控制语句语句独占一行\"><a href=\"#控制语句语句独占一行\" class=\"headerlink\" title=\"控制语句语句独占一行\"></a>控制语句语句独占一行</h3><p>&emsp;&emsp;正常情况下，if 、for 、 while 、case 、switch 、default 等语句独自占用一行，但如果后续代码非常短也可以共同占用一行。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//变量赋值这里省略</span><br><span class=\"hljs-keyword\">int</span> min;<br><span class=\"hljs-keyword\">bool</span> con;<br><span class=\"hljs-keyword\">switch</span> (min) &#123;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-comment\">//do something...</span><br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; min; ++i) &#123;<br>            <span class=\"hljs-comment\">//do something...</span><br>        &#125;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:<br>        <span class=\"hljs-keyword\">while</span> (min != <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-comment\">//do something...</span><br>        &#125;<br>        <span class=\"hljs-keyword\">break</span>;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>: <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">default</span>: <span class=\"hljs-keyword\">return</span> con ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"大括号的位置\"><a href=\"#大括号的位置\" class=\"headerlink\" title=\"大括号的位置\"></a>大括号的位置</h3><p>&emsp;&emsp;大括号书写的位置有两种写法，读者选择一种使用即可，不要多种混用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//第一种</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>&#125;<br><span class=\"hljs-comment\">//第二种</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"一个函数不要过长\"><a href=\"#一个函数不要过长\" class=\"headerlink\" title=\"一个函数不要过长\"></a>一个函数不要过长</h3><p>&emsp;&emsp;一个函数的行数尽量维持在50（或80）以下（非空非注释行）。</p>\n<p>&emsp;&emsp;但有些函数例外，这些函数可能集成了非常庞大的单个功能，同时由于算法的复杂性无法进行有效的拆分（即拆分可能使代码变得更加复杂难懂）。</p>\n<h3 id=\"重复的代码提取为一个函数\"><a href=\"#重复的代码提取为一个函数\" class=\"headerlink\" title=\"重复的代码提取为一个函数\"></a>重复的代码提取为一个函数</h3><p>&emsp;&emsp;如果有一个功能在多个地方被使用，那么应该这个功能提炼成一个独立的函数，这样使用这个功能的时候直接调用这个函数就可以了，有效减少了重复代码。</p>\n<h3 id=\"一个函数仅对应一个功能\"><a href=\"#一个函数仅对应一个功能\" class=\"headerlink\" title=\"一个函数仅对应一个功能\"></a>一个函数仅对应一个功能</h3><p>&emsp;&emsp;一个函数完成多个任务是书写代码的大忌，这样不仅会让函数命名变得复杂，同时会让函数的职责变得不明确，增大了后期维护、修改以及理解的难度。</p>\n<h3 id=\"对参数的合法性检查应有明确的规定\"><a href=\"#对参数的合法性检查应有明确的规定\" class=\"headerlink\" title=\"对参数的合法性检查应有明确的规定\"></a>对参数的合法性检查应有明确的规定</h3><p>&emsp;&emsp;通常情况下，应当对输入函数的参数进行检查，避免出现意外的情况。但是谁检查是一个普遍存在的问题。有两个极端的情况：一是调用者与被调用者都检查了，二是调用者与被调用者都没有检查。前者虽不会带来运行结果错误，但会出现代码冗余、运行效率降低的情况，后者则可能会导致莫名其妙的问题出现。</p>\n<p>&emsp;&emsp;故写代码时应明确规定默认情况下应由谁来对参数进行检查，例外的函数也应在注释中指明情况。</p>\n<h2 id=\"命名规范\"><a href=\"#命名规范\" class=\"headerlink\" title=\"命名规范\"></a>命名规范</h2><blockquote>\n<p>标识符的命名规则历来是一个敏感话题，典型的命名风格如unix风格、windows风格等，从来无法达成共识。实际上，各种风格都有其优势也有其劣势，而且往往和个人的审美观有关。我们对标识符定义主要是为了让团队的代码看起来尽可能统一，有利于代码的后续阅读和修改，产品可以根据自己的实际需要指定命名风格，规范中不再做统一的规定。</p>\n<p>复制自：<a href=\"https://blog.csdn.net/m0_38106923/article/details/105042594\">https://blog.csdn.net/m0_38106923/article/details/105042594</a></p>\n</blockquote>\n<h3 id=\"大分类\"><a href=\"#大分类\" class=\"headerlink\" title=\"大分类\"></a>大分类</h3><h4 id=\"一、驼峰式命名\"><a href=\"#一、驼峰式命名\" class=\"headerlink\" title=\"一、驼峰式命名\"></a>一、驼峰式命名</h4><p>&emsp;&emsp;第一个单词首字母小写，后面其他单词首字母大写(又称小驼峰式)。我在本文列出的所有代码均遵循该命名方式，这里就不单独举例了。</p>\n<h4 id=\"二、帕斯卡命名\"><a href=\"#二、帕斯卡命名\" class=\"headerlink\" title=\"二、帕斯卡命名\"></a>二、帕斯卡命名</h4><p>&emsp;&emsp;和驼峰式命名类似，只不过将首字母小写改为了首字母大写（故也被称为大驼峰式），也不单独举例。</p>\n<h4 id=\"三、下划线命名\"><a href=\"#三、下划线命名\" class=\"headerlink\" title=\"三、下划线命名\"></a>三、下划线命名</h4><p>&emsp;&emsp;所有字母小写，每个单词之间使用单下划线隔开。（PS：这个命名方法的名字是我瞎取的。）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">int</span> data_list;<br><span class=\"hljs-keyword\">double</span> sum_result;<br></code></pre></td></tr></table></figure>\n<h4 id=\"四、匈牙利命名\"><a href=\"#四、匈牙利命名\" class=\"headerlink\" title=\"四、匈牙利命名\"></a>四、匈牙利命名</h4><p>&emsp;&emsp;该命名方法不推荐使用，因为其最终使得代码更加难懂，远离了规范的本意，如果想要了解请自行百度。</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><h4 id=\"常量命名方法\"><a href=\"#常量命名方法\" class=\"headerlink\" title=\"常量命名方法\"></a>常量命名方法</h4><p>&emsp;&emsp;常量（包括枚举常量）命名建议同意采用全部字母大写，单词之间采用单下划线分割的命名格式。这样子有利于一眼识别出该字段指向一个常量。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> PI_ROUNDED 3.1415926</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"函数命名\"><a href=\"#函数命名\" class=\"headerlink\" title=\"函数命名\"></a>函数命名</h4><p>&emsp;&emsp;函数命名一般采用&ensp;动词&ensp;+&ensp;名词&ensp;的命名方式，因为函数大都是用来执行某一个动作的，没有动作的函数是无意义的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">double</span> <span class=\"hljs-title\">getPI</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getData</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">max</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">min</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> a, <span class=\"hljs-keyword\">int</span> b)</span></span>;<br></code></pre></td></tr></table></figure>\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><p>&emsp;&emsp;除了头文件或编译开关等特殊定义，所有常量变量不要用下划线（不论几个）开头，因为下划线开头的常量都是一些内部的定义。</p>\n<p>&emsp;&emsp;禁止使用单字节命名变量，但 允许 定义i 、j、k作为局部循环变量</p>\n<p>&emsp;&emsp;不建议使用匈牙利命名法</p>\n<p>&emsp;&emsp;全局变量应增加<code>g_</code>前缀，静态变量应增加<code>s_</code></p>\n<p>&emsp;&emsp;尽量避免名字中出现数字编号，除非逻辑上的确需要编号</p>\n<p>&emsp;&emsp;除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"一个变量对应一个用途\"><a href=\"#一个变量对应一个用途\" class=\"headerlink\" title=\"一个变量对应一个用途\"></a>一个变量对应一个用途</h3><p>&emsp;&emsp;一个变量只用来表示一个特定功能，不能把一个变量作多种用途，即同一变量取值不同时，其代表的意义也不同。</p>\n<h3 id=\"尽量使用-const-定义代替宏\"><a href=\"#尽量使用-const-定义代替宏\" class=\"headerlink\" title=\"尽量使用 const 定义代替宏\"></a>尽量使用 const 定义代替宏</h3><p>&emsp;&emsp;一下内容复制自：<a href=\"https://blog.csdn.net/m0_38106923/article/details/105042594\">https://blog.csdn.net/m0_38106923/article/details/105042594</a></p>\n<p>&emsp;&emsp;“尽量用编译器而不用预处理”，因为#define经常被认为好象不是语言本身的一部分。看下面的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> ASPECT_RATIO 1.653</span><br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;编译器会永远也看不到ASPECT_RATIO这个符号名，因为在源码进入编译器之前，它会被预处理程序去掉，于是ASPECT_RATIO不会加入到符号列表中。如果涉及到这个常量的代码在编译时报错，就会很令人费解，因为报错信息指的是1.653，而不是ASPECT_RATIO。如果ASPECT_RATIO不是在你自己写的头文件中定义的，你就会奇怪1.653是从哪里来的，甚至会花时间跟踪下去。这个问题也会出现在符号调试器中，因为同样地，你所写的符号名不会出现在符号列表中。<br>解决这个问题的方案很简单：不用预处理宏，定义一个常量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">double</span> ASPECT_RATIO = <span class=\"hljs-number\">1.653</span>;<br></code></pre></td></tr></table></figure>\n<h2 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h2><h3 id=\"函数调用不要作为另一个函数的参数使用\"><a href=\"#函数调用不要作为另一个函数的参数使用\" class=\"headerlink\" title=\"函数调用不要作为另一个函数的参数使用\"></a>函数调用不要作为另一个函数的参数使用</h3><p>&emsp;&emsp;不要将一个函数的返回值当作另一个函数的参数，这样子既不利于调试和阅读，也有可能导致意想不到的运算结果，例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">//该代码摘自：https://blog.csdn.net/m0_38106923/article/details/105042594</span><br><span class=\"hljs-keyword\">int</span> g_var;<br> <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">fun1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    g_var += <span class=\"hljs-number\">10</span>;<br>    <span class=\"hljs-keyword\">return</span> g_var;<br>&#125;<br> <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">fun2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    g_var += <span class=\"hljs-number\">100</span>;<br>    <span class=\"hljs-keyword\">return</span> g_var;<br>&#125;<br> <br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> argc, <span class=\"hljs-keyword\">char</span> *argv[], <span class=\"hljs-keyword\">char</span> *envp[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    g_var = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;func1: %d, func2: %d\\n&quot;</span>, fun1(), fun2());<br>    g_var = <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;func2: %d, func1: %d\\n&quot;</span>, fun2(), fun1());<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"赋值语句不要写在if等语句中\"><a href=\"#赋值语句不要写在if等语句中\" class=\"headerlink\" title=\"赋值语句不要写在if等语句中\"></a>赋值语句不要写在if等语句中</h3><p>&emsp;&emsp;永远不要将赋值语句写在<code>if</code>中，因为这样会导致后期错误排查时无法明确判断到底是写错了还是故意要在<code>if</code>里面给这个值赋值。</p>\n<h3 id=\"不要过分依赖运算符优先级\"><a href=\"#不要过分依赖运算符优先级\" class=\"headerlink\" title=\"不要过分依赖运算符优先级\"></a>不要过分依赖运算符优先级</h3><p>&emsp;&emsp;在一段代码中包含多许多运算符时，使用括号表明执行顺序，不要使用优先级确保执行顺序，否则会导致代码阅读困难，也很容易出错。</p>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><h3 id=\"学会书写优秀的代码\"><a href=\"#学会书写优秀的代码\" class=\"headerlink\" title=\"学会书写优秀的代码\"></a>学会书写优秀的代码</h3><p>&emsp;&emsp;优秀的代码可以做到自解释，即不需要书写注释也能让人明白代码的含义。</p>\n<h3 id=\"不要过多的使用注释\"><a href=\"#不要过多的使用注释\" class=\"headerlink\" title=\"不要过多的使用注释\"></a>不要过多的使用注释</h3><p>&emsp;&emsp;注释的本意是帮助人理解代码，过多的注释会让代码变得杂乱无章，起到反作用。</p>\n<h3 id=\"注释的语言\"><a href=\"#注释的语言\" class=\"headerlink\" title=\"注释的语言\"></a>注释的语言</h3><p>&emsp;&emsp;注释使用何种语言并没有硬性要求，但是考虑到生活环境应该优先使用中文，不要为了撞壁写出自己都读不懂的英文注释。</p>\n<h3 id=\"注释的位置\"><a href=\"#注释的位置\" class=\"headerlink\" title=\"注释的位置\"></a>注释的位置</h3><p>&emsp;&emsp;注释应放在被注释目标的上方或右方，不要放到下方。</p>\n<h2 id=\"补充-1\"><a href=\"#补充-1\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"编译器警告\"><a href=\"#编译器警告\" class=\"headerlink\" title=\"编译器警告\"></a>编译器警告</h3><p>&emsp;&emsp;尽量将编译器警告调到最高级别，这样你更容易发现自己代码的问题。</p>\n<h3 id=\"参考资料：\"><a href=\"#参考资料：\" class=\"headerlink\" title=\"参考资料：\"></a>参考资料：</h3><p>&emsp;&emsp;按参考程度排序，程度越深越靠前。</p>\n<ul>\n    <li>https://blog.csdn.net/m0_38106923/article/details/105042594</li>\n    <li>http://c.biancheng.net/view/158.html</li>\n    <li>https://zhuanlan.zhihu.com/p/54121195</li>\n    <li>http://www.360doc.com/content/18/0830/08/11881101_782310615.shtml</li>\n</ul>\n\n\n"},{"title":"简单概述自加操作","date":"2021-09-24T07:43:59.000Z","toc_number":false,"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b8.jpeg","_content":"\n\n\n\n\n&emsp;&emsp;自加操作有两种，`++i`和`i++`，很多新手都分不清这两个的区别，这里简单说一下这两个写法有什么不同。\n\n# 普通解法\n\n&emsp;&emsp;`++i`和`i++`都是自加操作，两者的区别就在于前者是先自加再使用，后者是先使用再自加，下面用一段简短的代码来解释这个问题：\n\n```c\nint main() {\n    int n = 0;\n    printf(\"%d\\n\", ++n);\n    printf(\"%d\\n\", n++);\n    printf(\"%d\\n\", n);\n    return 0;\n}\n```\n\n&emsp;&emsp;这段代码的输出结果是什么呢？显而易见，是`1 1 2`，接下来咱们来讲解为什么会是这个结果。\n\n<ul>\n    <li><code>++n</code> 先将n的值加一并赋值给n，然后再传递给printf | 此时n=1，传值1</li>\n    <li><code>n++</code> 先保存n的副本，然后将n加一并赋值给n，然后再将副本传递给printf | 此时n=2，传值1</li>\n    <li>传值2</li>\n</ul>\n\n&emsp;&emsp;由此可见，上面的代码还能写成下面的样子，效果是一样的：\n\n```c\nint main() {\n    int n = 0;\n    n += 1;\n    printf(\"%d \", n);\n    int temp = n;\n    n += 1;\n    printf(\"%d %d\", temp, n);\n    return 0;\n}\n```\n\n# 函数&指针解法\n\n&emsp;&emsp;**没学过相关内容的小伙伴可以跳过这个部分**\n\n&emsp;&emsp;接下来我们用函数的形式再次把上面的代码写一遍，为了节省篇幅就把函数写在上面了：\n\n```c\n/* ++i */\nint increaseAndReturn(int *value) {\n    *value += 1;\n    return *value;\n}\n\n/* i++ */\nint returnAndIncrease(int *value) {\n    int temp = *value;\n    *value += 1;\n    return temp;\n}\n\nint main() {\n    int n = 0;\n    printf(\"%d %d %d\", increaseAndReturn(&n);\n    printf(\"%d\\n\", returnAndIncrease(&n));\n    printf(\"%d\\n\", n)\n    return 0;\n}\n```\n\n\n\n\n\n","source":"_posts/operation.md","raw":"---\ntitle: 简单概述自加操作\ndate: 2021-09-24 15:43:59\ntoc_number: false\ncategories:\n  - 通用\ntags:\n  - 教程\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b8.jpeg\n---\n\n\n\n\n\n&emsp;&emsp;自加操作有两种，`++i`和`i++`，很多新手都分不清这两个的区别，这里简单说一下这两个写法有什么不同。\n\n# 普通解法\n\n&emsp;&emsp;`++i`和`i++`都是自加操作，两者的区别就在于前者是先自加再使用，后者是先使用再自加，下面用一段简短的代码来解释这个问题：\n\n```c\nint main() {\n    int n = 0;\n    printf(\"%d\\n\", ++n);\n    printf(\"%d\\n\", n++);\n    printf(\"%d\\n\", n);\n    return 0;\n}\n```\n\n&emsp;&emsp;这段代码的输出结果是什么呢？显而易见，是`1 1 2`，接下来咱们来讲解为什么会是这个结果。\n\n<ul>\n    <li><code>++n</code> 先将n的值加一并赋值给n，然后再传递给printf | 此时n=1，传值1</li>\n    <li><code>n++</code> 先保存n的副本，然后将n加一并赋值给n，然后再将副本传递给printf | 此时n=2，传值1</li>\n    <li>传值2</li>\n</ul>\n\n&emsp;&emsp;由此可见，上面的代码还能写成下面的样子，效果是一样的：\n\n```c\nint main() {\n    int n = 0;\n    n += 1;\n    printf(\"%d \", n);\n    int temp = n;\n    n += 1;\n    printf(\"%d %d\", temp, n);\n    return 0;\n}\n```\n\n# 函数&指针解法\n\n&emsp;&emsp;**没学过相关内容的小伙伴可以跳过这个部分**\n\n&emsp;&emsp;接下来我们用函数的形式再次把上面的代码写一遍，为了节省篇幅就把函数写在上面了：\n\n```c\n/* ++i */\nint increaseAndReturn(int *value) {\n    *value += 1;\n    return *value;\n}\n\n/* i++ */\nint returnAndIncrease(int *value) {\n    int temp = *value;\n    *value += 1;\n    return temp;\n}\n\nint main() {\n    int n = 0;\n    printf(\"%d %d %d\", increaseAndReturn(&n);\n    printf(\"%d\\n\", returnAndIncrease(&n));\n    printf(\"%d\\n\", n)\n    return 0;\n}\n```\n\n\n\n\n\n","slug":"operation","published":1,"updated":"2021-09-27T13:18:03.706Z","_id":"cku22zp37000g7kwq22o52j7w","comments":1,"layout":"post","photos":[],"link":"","content":"<p>&emsp;&emsp;自加操作有两种，<code>++i</code>和<code>i++</code>，很多新手都分不清这两个的区别，这里简单说一下这两个写法有什么不同。</p>\n<h1 id=\"普通解法\"><a href=\"#普通解法\" class=\"headerlink\" title=\"普通解法\"></a>普通解法</h1><p>&emsp;&emsp;<code>++i</code>和<code>i++</code>都是自加操作，两者的区别就在于前者是先自加再使用，后者是先使用再自加，下面用一段简短的代码来解释这个问题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, ++n);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, n++);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, n);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;这段代码的输出结果是什么呢？显而易见，是<code>1 1 2</code>，接下来咱们来讲解为什么会是这个结果。</p>\n<ul>\n    <li><code>++n</code> 先将n的值加一并赋值给n，然后再传递给printf | 此时n=1，传值1</li>\n    <li><code>n++</code> 先保存n的副本，然后将n加一并赋值给n，然后再将副本传递给printf | 此时n=2，传值1</li>\n    <li>传值2</li>\n</ul>\n\n<p>&emsp;&emsp;由此可见，上面的代码还能写成下面的样子，效果是一样的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;<br>    n += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>, n);<br>    <span class=\"hljs-keyword\">int</span> temp = n;<br>    n += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d %d&quot;</span>, temp, n);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"函数-amp-指针解法\"><a href=\"#函数-amp-指针解法\" class=\"headerlink\" title=\"函数&amp;指针解法\"></a>函数&amp;指针解法</h1><p>&emsp;&emsp;<strong>没学过相关内容的小伙伴可以跳过这个部分</strong></p>\n<p>&emsp;&emsp;接下来我们用函数的形式再次把上面的代码写一遍，为了节省篇幅就把函数写在上面了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* ++i */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">increaseAndReturn</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> *value)</span> </span>&#123;<br>    *value += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> *value;<br>&#125;<br><br><span class=\"hljs-comment\">/* i++ */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">returnAndIncrease</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> *value)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> temp = *value;<br>    *value += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> temp;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d %d %d&quot;</span>, increaseAndReturn(&amp;n);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, returnAndIncrease(&amp;n));<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, n)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"excerpt":"","more":"<p>&emsp;&emsp;自加操作有两种，<code>++i</code>和<code>i++</code>，很多新手都分不清这两个的区别，这里简单说一下这两个写法有什么不同。</p>\n<h1 id=\"普通解法\"><a href=\"#普通解法\" class=\"headerlink\" title=\"普通解法\"></a>普通解法</h1><p>&emsp;&emsp;<code>++i</code>和<code>i++</code>都是自加操作，两者的区别就在于前者是先自加再使用，后者是先使用再自加，下面用一段简短的代码来解释这个问题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, ++n);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, n++);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, n);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>&emsp;&emsp;这段代码的输出结果是什么呢？显而易见，是<code>1 1 2</code>，接下来咱们来讲解为什么会是这个结果。</p>\n<ul>\n    <li><code>++n</code> 先将n的值加一并赋值给n，然后再传递给printf | 此时n=1，传值1</li>\n    <li><code>n++</code> 先保存n的副本，然后将n加一并赋值给n，然后再将副本传递给printf | 此时n=2，传值1</li>\n    <li>传值2</li>\n</ul>\n\n<p>&emsp;&emsp;由此可见，上面的代码还能写成下面的样子，效果是一样的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;<br>    n += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>, n);<br>    <span class=\"hljs-keyword\">int</span> temp = n;<br>    n += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d %d&quot;</span>, temp, n);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"函数-amp-指针解法\"><a href=\"#函数-amp-指针解法\" class=\"headerlink\" title=\"函数&amp;指针解法\"></a>函数&amp;指针解法</h1><p>&emsp;&emsp;<strong>没学过相关内容的小伙伴可以跳过这个部分</strong></p>\n<p>&emsp;&emsp;接下来我们用函数的形式再次把上面的代码写一遍，为了节省篇幅就把函数写在上面了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/* ++i */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">increaseAndReturn</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> *value)</span> </span>&#123;<br>    *value += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> *value;<br>&#125;<br><br><span class=\"hljs-comment\">/* i++ */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">returnAndIncrease</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> *value)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> temp = *value;<br>    *value += <span class=\"hljs-number\">1</span>;<br>    <span class=\"hljs-keyword\">return</span> temp;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d %d %d&quot;</span>, increaseAndReturn(&amp;n);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, returnAndIncrease(&amp;n));<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, n)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n\n\n\n\n"},{"title":"Anaconda3&PyCharm安装配置教程","date":"2021-09-05T05:58:13.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b5.png","description":"新手不知道如何安装Anaconda3和PyCharm？来这里寻找答案吧。","_content":"\n# 下载\n\n&emsp;&emsp;首先，我们需要下载Anaconda3和PyCharm的安装包，班群的小伙伴可以直接在群文件里面下载，其他人可以去官网下载，这里列出下载链接：[Anaconda3](https://www.anaconda.com/products/individual)、[PyCharm](https://www.jetbrains.com/zh-cn/pycharm/download/#section=windows)\n\n&emsp;&emsp;温馨提示：PyCharm下载社区版（Community）就够用了，安装Anaconda3就不需要手动安装Python了。\n\n# 安装\n\n**声明：本章所有图片均来源于网络，若有侵权可以联系我删除。因为来源与网络，可能图片中的信息会与文字描述有部分不相符的内容，如果两者不一样则优先听从文字内容。**\n\n## Anaconda3\n\n&emsp;&emsp;打开安装包，可以看到下图所示的界面\n\n<img src=\"https://pic1.zhimg.com/v2-1a95c6756d90ce6dd74a9f08f6dd50a8_r.jpg\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;然后可以看到下面的界面，这里两个选项区别不大，如果你想让电脑上所有用户都能使用Anaconda3就选2，否则默认即可。\n\n<img src=\"https://pic2.zhimg.com/v2-29778a46617e491adb554ac5fa5823b1_r.jpg\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;接下来是安装路径的选择，这里以`E:\\Anaconda\\`为例。\n\n&emsp;&emsp;**注意：安装目录必须是空的，即Anaconda文件夹内不能有任何文件！如果Anaconda文件夹不存在安装程序会自动创建，不需要手动新建文件夹！**\n\n<img src=\"https://pic2.zhimg.com/v2-64590b21362f65132f54d1a597f0c809_r.jpg\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;点击next即可进入下面的界面，新版本的安装界面第二个选项写的是3.8，这个不用管，保持默认即可。\n\n<img src=\"https://pic1.zhimg.com/v2-118a4d294002f24f36b86cb6250b2594_r.jpg\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;点击`Install`后一路`Next`就能进入最终的这个界面，两个选项都取消，点击`Finish`就完成安装了。\n\n<img src=\"https://pic2.zhimg.com/v2-6ed983e8cedf48dc0c0870d3de2c620d_r.jpg\" style=\"zoom:67%;\" />\n\n## Pycharm\n\n&emsp;&emsp;打开安装包，进入修改安装路径的界面，这里随意选择自己想要的安装路径即可。\n\n&emsp;&emsp;**注意：这里目标文件夹同样要是空的！**\n\n<img src=\"https://pic4.zhimg.com/80/v2-8fa2ab72964bc9a979b31d562012e45b_720w.jpg\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;接下来这个界面是让很多人迷惑的界面，你们的界面跟这个应该有一点不太一样，没有32位的选项，也没有最下面安装JRE的选项，不影响安装。\n\n<img src=\"https://pic2.zhimg.com/80/v2-4adeead66fe9a9ac358d2ef6e1984b2d_720w.jpg\" style=\"zoom: 67%;\" />\n\n&emsp;&emsp;进入最后一个界面的时候可以先把`Run PyCharm`取消掉，点击`Finish`就完成安装了\n\n# 配置Anaconda环境变量\n\n&emsp;&emsp;此电脑——属性——高级系统设置——环境变量——系统变量——[双击Path]\n\n&emsp;&emsp;然后在里面添加一下内容：（**注意：`E:\\Tools\\Anaconda`需要替换成你的Anaconda3的安装目录！**）\n\n> E:\\Tools\\Anaconda3（Python需要）\n> E:\\Tools\\Anaconda3\\Scripts（conda自带脚本）\n> E:\\Tools\\Anaconda3\\Library\\mingw-w64\\bin（使用C with python的时候） E:\\Anaconda\\Library\\usr\\bin\n> E:\\Tools\\Anaconda3\\Library\\bin（jupyter notebook动态库）\n\n&emsp;&emsp;修改完之后就是下图中的效果：\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/path.png\" style=\"zoom:73%;\" />\n\n&emsp;&emsp;保存并退出打开的这些界面，然后`Win + R`打开运行，输入`cmd`回车打开命令提示符，输入`python`回车，若出现类似于下图中的效果则说明你py的环境配置成功：\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/check.png\" style=\"zoom:67%;\" />\n\n# 添加Anaconda中国镜像\n\n<ol>\n    <li>打开命令提示符，执行“conda config --set show_channel_urls yes”指令</li>\n    <li>打开C:\\用户\\[你的用户名]文件夹，找到.condarc文件，用记事本打开</li>\n    <li>修改文件内容</li>\n    <li>命令提示符中执行“conda clean -i ”指令</li>\n</ol>\n\n\n&emsp;&emsp;修改后的`.condarc`应该长下面这个样子：\n\n```\nchannels:\n  - defaults\nshow_channel_urls: true\ndefault_channels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\ncustom_channels:\n  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n```\n\n# PyCharm的汉化\n\n**注意：本章中所有图片均来源于网络，侵删！若图片信息与文本描述不相符，则优先听从文本指令。**\n\n&emsp;&emsp;打开PyCharm可以看到下面的界面：\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/25389123-349af93c05042b76.webp\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;点击左侧的`Plugins`按钮，接着点击`Marketplace`，在搜索栏内填入`chinese`可以看到下面的样子：\n\n<img src=\"https://img-blog.csdnimg.cn/20210304214811945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTExODA1,size_16,color_FFFFFF,t_70#pic_center\" style=\"zoom:59%;\" />\n\n&emsp;&emsp;然后按照图中所示，点击`Install`，等待安装完毕后重启PyCharm，你就会发现界面变成中文了。\n\n# PyCharm插件推荐\n\n<ul>\n    <li>Key Promoter X: 快捷键提示插件，如果你的鼠标操作可以用快捷键替代则会在右下角提醒你</li>\n    <li>Material Theme UI: 界面美化插件（名字后面带个Lite的是免费版，不带的是付费版）</li>\n    <li>Translation: 翻译插件</li>\n</ul>\n\n\n# PyCharm优化\n\n**注意：本章仅针对16G内存的电脑，若你的电脑内存比较小，请自己抉择最大内存设置。**\n\n&emsp;&emsp;点击界面左下角的设置按钮，然后点击`编辑自定义VM选项`，进入图示界面：\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/edit.png\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;在列表最后面添加如下语句，这里就不解释具体原因了：\n\n>-Dfile.encoding=UTF-8\n>-XX:-UseCounterDecay\n>-XX:+DoEscapeAnalysis\n\n&emsp;&emsp;列表头有两行语句，分别是：`-Xms***`、`-Xmx***`。这两个语句分别用于设置最小内存和最大内存限制，这里修改为：`-Xms512m`、`-Xmx2048m`。","source":"_posts/py.md","raw":"---\ntitle: Anaconda3&PyCharm安装配置教程\ndate: 2021-09-05 13:58:13\ncategories:\n  - Python\ntags:\n  - 教程\n  - 环境\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b5.png\ndescription: 新手不知道如何安装Anaconda3和PyCharm？来这里寻找答案吧。\n\n---\n\n# 下载\n\n&emsp;&emsp;首先，我们需要下载Anaconda3和PyCharm的安装包，班群的小伙伴可以直接在群文件里面下载，其他人可以去官网下载，这里列出下载链接：[Anaconda3](https://www.anaconda.com/products/individual)、[PyCharm](https://www.jetbrains.com/zh-cn/pycharm/download/#section=windows)\n\n&emsp;&emsp;温馨提示：PyCharm下载社区版（Community）就够用了，安装Anaconda3就不需要手动安装Python了。\n\n# 安装\n\n**声明：本章所有图片均来源于网络，若有侵权可以联系我删除。因为来源与网络，可能图片中的信息会与文字描述有部分不相符的内容，如果两者不一样则优先听从文字内容。**\n\n## Anaconda3\n\n&emsp;&emsp;打开安装包，可以看到下图所示的界面\n\n<img src=\"https://pic1.zhimg.com/v2-1a95c6756d90ce6dd74a9f08f6dd50a8_r.jpg\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;然后可以看到下面的界面，这里两个选项区别不大，如果你想让电脑上所有用户都能使用Anaconda3就选2，否则默认即可。\n\n<img src=\"https://pic2.zhimg.com/v2-29778a46617e491adb554ac5fa5823b1_r.jpg\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;接下来是安装路径的选择，这里以`E:\\Anaconda\\`为例。\n\n&emsp;&emsp;**注意：安装目录必须是空的，即Anaconda文件夹内不能有任何文件！如果Anaconda文件夹不存在安装程序会自动创建，不需要手动新建文件夹！**\n\n<img src=\"https://pic2.zhimg.com/v2-64590b21362f65132f54d1a597f0c809_r.jpg\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;点击next即可进入下面的界面，新版本的安装界面第二个选项写的是3.8，这个不用管，保持默认即可。\n\n<img src=\"https://pic1.zhimg.com/v2-118a4d294002f24f36b86cb6250b2594_r.jpg\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;点击`Install`后一路`Next`就能进入最终的这个界面，两个选项都取消，点击`Finish`就完成安装了。\n\n<img src=\"https://pic2.zhimg.com/v2-6ed983e8cedf48dc0c0870d3de2c620d_r.jpg\" style=\"zoom:67%;\" />\n\n## Pycharm\n\n&emsp;&emsp;打开安装包，进入修改安装路径的界面，这里随意选择自己想要的安装路径即可。\n\n&emsp;&emsp;**注意：这里目标文件夹同样要是空的！**\n\n<img src=\"https://pic4.zhimg.com/80/v2-8fa2ab72964bc9a979b31d562012e45b_720w.jpg\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;接下来这个界面是让很多人迷惑的界面，你们的界面跟这个应该有一点不太一样，没有32位的选项，也没有最下面安装JRE的选项，不影响安装。\n\n<img src=\"https://pic2.zhimg.com/80/v2-4adeead66fe9a9ac358d2ef6e1984b2d_720w.jpg\" style=\"zoom: 67%;\" />\n\n&emsp;&emsp;进入最后一个界面的时候可以先把`Run PyCharm`取消掉，点击`Finish`就完成安装了\n\n# 配置Anaconda环境变量\n\n&emsp;&emsp;此电脑——属性——高级系统设置——环境变量——系统变量——[双击Path]\n\n&emsp;&emsp;然后在里面添加一下内容：（**注意：`E:\\Tools\\Anaconda`需要替换成你的Anaconda3的安装目录！**）\n\n> E:\\Tools\\Anaconda3（Python需要）\n> E:\\Tools\\Anaconda3\\Scripts（conda自带脚本）\n> E:\\Tools\\Anaconda3\\Library\\mingw-w64\\bin（使用C with python的时候） E:\\Anaconda\\Library\\usr\\bin\n> E:\\Tools\\Anaconda3\\Library\\bin（jupyter notebook动态库）\n\n&emsp;&emsp;修改完之后就是下图中的效果：\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/path.png\" style=\"zoom:73%;\" />\n\n&emsp;&emsp;保存并退出打开的这些界面，然后`Win + R`打开运行，输入`cmd`回车打开命令提示符，输入`python`回车，若出现类似于下图中的效果则说明你py的环境配置成功：\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/check.png\" style=\"zoom:67%;\" />\n\n# 添加Anaconda中国镜像\n\n<ol>\n    <li>打开命令提示符，执行“conda config --set show_channel_urls yes”指令</li>\n    <li>打开C:\\用户\\[你的用户名]文件夹，找到.condarc文件，用记事本打开</li>\n    <li>修改文件内容</li>\n    <li>命令提示符中执行“conda clean -i ”指令</li>\n</ol>\n\n\n&emsp;&emsp;修改后的`.condarc`应该长下面这个样子：\n\n```\nchannels:\n  - defaults\nshow_channel_urls: true\ndefault_channels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\ncustom_channels:\n  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n```\n\n# PyCharm的汉化\n\n**注意：本章中所有图片均来源于网络，侵删！若图片信息与文本描述不相符，则优先听从文本指令。**\n\n&emsp;&emsp;打开PyCharm可以看到下面的界面：\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/25389123-349af93c05042b76.webp\" style=\"zoom:80%;\" />\n\n&emsp;&emsp;点击左侧的`Plugins`按钮，接着点击`Marketplace`，在搜索栏内填入`chinese`可以看到下面的样子：\n\n<img src=\"https://img-blog.csdnimg.cn/20210304214811945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTExODA1,size_16,color_FFFFFF,t_70#pic_center\" style=\"zoom:59%;\" />\n\n&emsp;&emsp;然后按照图中所示，点击`Install`，等待安装完毕后重启PyCharm，你就会发现界面变成中文了。\n\n# PyCharm插件推荐\n\n<ul>\n    <li>Key Promoter X: 快捷键提示插件，如果你的鼠标操作可以用快捷键替代则会在右下角提醒你</li>\n    <li>Material Theme UI: 界面美化插件（名字后面带个Lite的是免费版，不带的是付费版）</li>\n    <li>Translation: 翻译插件</li>\n</ul>\n\n\n# PyCharm优化\n\n**注意：本章仅针对16G内存的电脑，若你的电脑内存比较小，请自己抉择最大内存设置。**\n\n&emsp;&emsp;点击界面左下角的设置按钮，然后点击`编辑自定义VM选项`，进入图示界面：\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/edit.png\" style=\"zoom:67%;\" />\n\n&emsp;&emsp;在列表最后面添加如下语句，这里就不解释具体原因了：\n\n>-Dfile.encoding=UTF-8\n>-XX:-UseCounterDecay\n>-XX:+DoEscapeAnalysis\n\n&emsp;&emsp;列表头有两行语句，分别是：`-Xms***`、`-Xmx***`。这两个语句分别用于设置最小内存和最大内存限制，这里修改为：`-Xms512m`、`-Xmx2048m`。","slug":"py","published":1,"updated":"2021-09-27T13:37:02.797Z","_id":"cku22zp38000i7kwq6ihffqmw","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h1><p>&emsp;&emsp;首先，我们需要下载Anaconda3和PyCharm的安装包，班群的小伙伴可以直接在群文件里面下载，其他人可以去官网下载，这里列出下载链接：<a href=\"https://www.anaconda.com/products/individual\">Anaconda3</a>、<a href=\"https://www.jetbrains.com/zh-cn/pycharm/download/#section=windows\">PyCharm</a></p>\n<p>&emsp;&emsp;温馨提示：PyCharm下载社区版（Community）就够用了，安装Anaconda3就不需要手动安装Python了。</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p><strong>声明：本章所有图片均来源于网络，若有侵权可以联系我删除。因为来源与网络，可能图片中的信息会与文字描述有部分不相符的内容，如果两者不一样则优先听从文字内容。</strong></p>\n<h2 id=\"Anaconda3\"><a href=\"#Anaconda3\" class=\"headerlink\" title=\"Anaconda3\"></a>Anaconda3</h2><p>&emsp;&emsp;打开安装包，可以看到下图所示的界面</p>\n<img src=\"https://pic1.zhimg.com/v2-1a95c6756d90ce6dd74a9f08f6dd50a8_r.jpg\" style=\"zoom:67%;\">\n\n<p>&emsp;&emsp;然后可以看到下面的界面，这里两个选项区别不大，如果你想让电脑上所有用户都能使用Anaconda3就选2，否则默认即可。</p>\n<img src=\"https://pic2.zhimg.com/v2-29778a46617e491adb554ac5fa5823b1_r.jpg\" style=\"zoom:67%;\">\n\n<p>&emsp;&emsp;接下来是安装路径的选择，这里以<code>E:\\Anaconda\\</code>为例。</p>\n<p>&emsp;&emsp;<strong>注意：安装目录必须是空的，即Anaconda文件夹内不能有任何文件！如果Anaconda文件夹不存在安装程序会自动创建，不需要手动新建文件夹！</strong></p>\n<img src=\"https://pic2.zhimg.com/v2-64590b21362f65132f54d1a597f0c809_r.jpg\" style=\"zoom:67%;\">\n\n<p>&emsp;&emsp;点击next即可进入下面的界面，新版本的安装界面第二个选项写的是3.8，这个不用管，保持默认即可。</p>\n<img src=\"https://pic1.zhimg.com/v2-118a4d294002f24f36b86cb6250b2594_r.jpg\" style=\"zoom:67%;\">\n\n<p>&emsp;&emsp;点击<code>Install</code>后一路<code>Next</code>就能进入最终的这个界面，两个选项都取消，点击<code>Finish</code>就完成安装了。</p>\n<img src=\"https://pic2.zhimg.com/v2-6ed983e8cedf48dc0c0870d3de2c620d_r.jpg\" style=\"zoom:67%;\">\n\n<h2 id=\"Pycharm\"><a href=\"#Pycharm\" class=\"headerlink\" title=\"Pycharm\"></a>Pycharm</h2><p>&emsp;&emsp;打开安装包，进入修改安装路径的界面，这里随意选择自己想要的安装路径即可。</p>\n<p>&emsp;&emsp;<strong>注意：这里目标文件夹同样要是空的！</strong></p>\n<img src=\"https://pic4.zhimg.com/80/v2-8fa2ab72964bc9a979b31d562012e45b_720w.jpg\" style=\"zoom:67%;\">\n\n<p>&emsp;&emsp;接下来这个界面是让很多人迷惑的界面，你们的界面跟这个应该有一点不太一样，没有32位的选项，也没有最下面安装JRE的选项，不影响安装。</p>\n<img src=\"https://pic2.zhimg.com/80/v2-4adeead66fe9a9ac358d2ef6e1984b2d_720w.jpg\" style=\"zoom: 67%;\">\n\n<p>&emsp;&emsp;进入最后一个界面的时候可以先把<code>Run PyCharm</code>取消掉，点击<code>Finish</code>就完成安装了</p>\n<h1 id=\"配置Anaconda环境变量\"><a href=\"#配置Anaconda环境变量\" class=\"headerlink\" title=\"配置Anaconda环境变量\"></a>配置Anaconda环境变量</h1><p>&emsp;&emsp;此电脑——属性——高级系统设置——环境变量——系统变量——[双击Path]</p>\n<p>&emsp;&emsp;然后在里面添加一下内容：（<strong>注意：<code>E:\\Tools\\Anaconda</code>需要替换成你的Anaconda3的安装目录！</strong>）</p>\n<blockquote>\n<p>E:\\Tools\\Anaconda3（Python需要）<br>E:\\Tools\\Anaconda3\\Scripts（conda自带脚本）<br>E:\\Tools\\Anaconda3\\Library\\mingw-w64\\bin（使用C with python的时候） E:\\Anaconda\\Library\\usr\\bin<br>E:\\Tools\\Anaconda3\\Library\\bin（jupyter notebook动态库）</p>\n</blockquote>\n<p>&emsp;&emsp;修改完之后就是下图中的效果：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/path.png\" style=\"zoom:73%;\">\n\n<p>&emsp;&emsp;保存并退出打开的这些界面，然后<code>Win + R</code>打开运行，输入<code>cmd</code>回车打开命令提示符，输入<code>python</code>回车，若出现类似于下图中的效果则说明你py的环境配置成功：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/check.png\" style=\"zoom:67%;\">\n\n<h1 id=\"添加Anaconda中国镜像\"><a href=\"#添加Anaconda中国镜像\" class=\"headerlink\" title=\"添加Anaconda中国镜像\"></a>添加Anaconda中国镜像</h1><ol>\n    <li>打开命令提示符，执行“conda config --set show_channel_urls yes”指令</li>\n    <li>打开C:\\用户\\[你的用户名]文件夹，找到.condarc文件，用记事本打开</li>\n    <li>修改文件内容</li>\n    <li>命令提示符中执行“conda clean -i ”指令</li>\n</ol>\n\n\n<p>&emsp;&emsp;修改后的<code>.condarc</code>应该长下面这个样子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">channels:<br>  - defaults<br>show_channel_urls: true<br>default_channels:<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2<br>custom_channels:<br>  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"PyCharm的汉化\"><a href=\"#PyCharm的汉化\" class=\"headerlink\" title=\"PyCharm的汉化\"></a>PyCharm的汉化</h1><p><strong>注意：本章中所有图片均来源于网络，侵删！若图片信息与文本描述不相符，则优先听从文本指令。</strong></p>\n<p>&emsp;&emsp;打开PyCharm可以看到下面的界面：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/25389123-349af93c05042b76.webp\" style=\"zoom:80%;\">\n\n<p>&emsp;&emsp;点击左侧的<code>Plugins</code>按钮，接着点击<code>Marketplace</code>，在搜索栏内填入<code>chinese</code>可以看到下面的样子：</p>\n<img src=\"https://img-blog.csdnimg.cn/20210304214811945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTExODA1,size_16,color_FFFFFF,t_70#pic_center\" style=\"zoom:59%;\">\n\n<p>&emsp;&emsp;然后按照图中所示，点击<code>Install</code>，等待安装完毕后重启PyCharm，你就会发现界面变成中文了。</p>\n<h1 id=\"PyCharm插件推荐\"><a href=\"#PyCharm插件推荐\" class=\"headerlink\" title=\"PyCharm插件推荐\"></a>PyCharm插件推荐</h1><ul>\n    <li>Key Promoter X: 快捷键提示插件，如果你的鼠标操作可以用快捷键替代则会在右下角提醒你</li>\n    <li>Material Theme UI: 界面美化插件（名字后面带个Lite的是免费版，不带的是付费版）</li>\n    <li>Translation: 翻译插件</li>\n</ul>\n\n\n<h1 id=\"PyCharm优化\"><a href=\"#PyCharm优化\" class=\"headerlink\" title=\"PyCharm优化\"></a>PyCharm优化</h1><p><strong>注意：本章仅针对16G内存的电脑，若你的电脑内存比较小，请自己抉择最大内存设置。</strong></p>\n<p>&emsp;&emsp;点击界面左下角的设置按钮，然后点击<code>编辑自定义VM选项</code>，进入图示界面：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/edit.png\" style=\"zoom:67%;\">\n\n<p>&emsp;&emsp;在列表最后面添加如下语句，这里就不解释具体原因了：</p>\n<blockquote>\n<p>-Dfile.encoding=UTF-8<br>-XX:-UseCounterDecay<br>-XX:+DoEscapeAnalysis</p>\n</blockquote>\n<p>&emsp;&emsp;列表头有两行语句，分别是：<code>-Xms***</code>、<code>-Xmx***</code>。这两个语句分别用于设置最小内存和最大内存限制，这里修改为：<code>-Xms512m</code>、<code>-Xmx2048m</code>。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"}]}]}},"excerpt":"","more":"<h1 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h1><p>&emsp;&emsp;首先，我们需要下载Anaconda3和PyCharm的安装包，班群的小伙伴可以直接在群文件里面下载，其他人可以去官网下载，这里列出下载链接：<a href=\"https://www.anaconda.com/products/individual\">Anaconda3</a>、<a href=\"https://www.jetbrains.com/zh-cn/pycharm/download/#section=windows\">PyCharm</a></p>\n<p>&emsp;&emsp;温馨提示：PyCharm下载社区版（Community）就够用了，安装Anaconda3就不需要手动安装Python了。</p>\n<h1 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h1><p><strong>声明：本章所有图片均来源于网络，若有侵权可以联系我删除。因为来源与网络，可能图片中的信息会与文字描述有部分不相符的内容，如果两者不一样则优先听从文字内容。</strong></p>\n<h2 id=\"Anaconda3\"><a href=\"#Anaconda3\" class=\"headerlink\" title=\"Anaconda3\"></a>Anaconda3</h2><p>&emsp;&emsp;打开安装包，可以看到下图所示的界面</p>\n<img src=\"https://pic1.zhimg.com/v2-1a95c6756d90ce6dd74a9f08f6dd50a8_r.jpg\" style=\"zoom:67%;\">\n\n<p>&emsp;&emsp;然后可以看到下面的界面，这里两个选项区别不大，如果你想让电脑上所有用户都能使用Anaconda3就选2，否则默认即可。</p>\n<img src=\"https://pic2.zhimg.com/v2-29778a46617e491adb554ac5fa5823b1_r.jpg\" style=\"zoom:67%;\">\n\n<p>&emsp;&emsp;接下来是安装路径的选择，这里以<code>E:\\Anaconda\\</code>为例。</p>\n<p>&emsp;&emsp;<strong>注意：安装目录必须是空的，即Anaconda文件夹内不能有任何文件！如果Anaconda文件夹不存在安装程序会自动创建，不需要手动新建文件夹！</strong></p>\n<img src=\"https://pic2.zhimg.com/v2-64590b21362f65132f54d1a597f0c809_r.jpg\" style=\"zoom:67%;\">\n\n<p>&emsp;&emsp;点击next即可进入下面的界面，新版本的安装界面第二个选项写的是3.8，这个不用管，保持默认即可。</p>\n<img src=\"https://pic1.zhimg.com/v2-118a4d294002f24f36b86cb6250b2594_r.jpg\" style=\"zoom:67%;\">\n\n<p>&emsp;&emsp;点击<code>Install</code>后一路<code>Next</code>就能进入最终的这个界面，两个选项都取消，点击<code>Finish</code>就完成安装了。</p>\n<img src=\"https://pic2.zhimg.com/v2-6ed983e8cedf48dc0c0870d3de2c620d_r.jpg\" style=\"zoom:67%;\">\n\n<h2 id=\"Pycharm\"><a href=\"#Pycharm\" class=\"headerlink\" title=\"Pycharm\"></a>Pycharm</h2><p>&emsp;&emsp;打开安装包，进入修改安装路径的界面，这里随意选择自己想要的安装路径即可。</p>\n<p>&emsp;&emsp;<strong>注意：这里目标文件夹同样要是空的！</strong></p>\n<img src=\"https://pic4.zhimg.com/80/v2-8fa2ab72964bc9a979b31d562012e45b_720w.jpg\" style=\"zoom:67%;\">\n\n<p>&emsp;&emsp;接下来这个界面是让很多人迷惑的界面，你们的界面跟这个应该有一点不太一样，没有32位的选项，也没有最下面安装JRE的选项，不影响安装。</p>\n<img src=\"https://pic2.zhimg.com/80/v2-4adeead66fe9a9ac358d2ef6e1984b2d_720w.jpg\" style=\"zoom: 67%;\">\n\n<p>&emsp;&emsp;进入最后一个界面的时候可以先把<code>Run PyCharm</code>取消掉，点击<code>Finish</code>就完成安装了</p>\n<h1 id=\"配置Anaconda环境变量\"><a href=\"#配置Anaconda环境变量\" class=\"headerlink\" title=\"配置Anaconda环境变量\"></a>配置Anaconda环境变量</h1><p>&emsp;&emsp;此电脑——属性——高级系统设置——环境变量——系统变量——[双击Path]</p>\n<p>&emsp;&emsp;然后在里面添加一下内容：（<strong>注意：<code>E:\\Tools\\Anaconda</code>需要替换成你的Anaconda3的安装目录！</strong>）</p>\n<blockquote>\n<p>E:\\Tools\\Anaconda3（Python需要）<br>E:\\Tools\\Anaconda3\\Scripts（conda自带脚本）<br>E:\\Tools\\Anaconda3\\Library\\mingw-w64\\bin（使用C with python的时候） E:\\Anaconda\\Library\\usr\\bin<br>E:\\Tools\\Anaconda3\\Library\\bin（jupyter notebook动态库）</p>\n</blockquote>\n<p>&emsp;&emsp;修改完之后就是下图中的效果：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/path.png\" style=\"zoom:73%;\">\n\n<p>&emsp;&emsp;保存并退出打开的这些界面，然后<code>Win + R</code>打开运行，输入<code>cmd</code>回车打开命令提示符，输入<code>python</code>回车，若出现类似于下图中的效果则说明你py的环境配置成功：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/check.png\" style=\"zoom:67%;\">\n\n<h1 id=\"添加Anaconda中国镜像\"><a href=\"#添加Anaconda中国镜像\" class=\"headerlink\" title=\"添加Anaconda中国镜像\"></a>添加Anaconda中国镜像</h1><ol>\n    <li>打开命令提示符，执行“conda config --set show_channel_urls yes”指令</li>\n    <li>打开C:\\用户\\[你的用户名]文件夹，找到.condarc文件，用记事本打开</li>\n    <li>修改文件内容</li>\n    <li>命令提示符中执行“conda clean -i ”指令</li>\n</ol>\n\n\n<p>&emsp;&emsp;修改后的<code>.condarc</code>应该长下面这个样子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">channels:<br>  - defaults<br>show_channel_urls: true<br>default_channels:<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r<br>  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2<br>custom_channels:<br>  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br>  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"PyCharm的汉化\"><a href=\"#PyCharm的汉化\" class=\"headerlink\" title=\"PyCharm的汉化\"></a>PyCharm的汉化</h1><p><strong>注意：本章中所有图片均来源于网络，侵删！若图片信息与文本描述不相符，则优先听从文本指令。</strong></p>\n<p>&emsp;&emsp;打开PyCharm可以看到下面的界面：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/25389123-349af93c05042b76.webp\" style=\"zoom:80%;\">\n\n<p>&emsp;&emsp;点击左侧的<code>Plugins</code>按钮，接着点击<code>Marketplace</code>，在搜索栏内填入<code>chinese</code>可以看到下面的样子：</p>\n<img src=\"https://img-blog.csdnimg.cn/20210304214811945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0MTExODA1,size_16,color_FFFFFF,t_70#pic_center\" style=\"zoom:59%;\">\n\n<p>&emsp;&emsp;然后按照图中所示，点击<code>Install</code>，等待安装完毕后重启PyCharm，你就会发现界面变成中文了。</p>\n<h1 id=\"PyCharm插件推荐\"><a href=\"#PyCharm插件推荐\" class=\"headerlink\" title=\"PyCharm插件推荐\"></a>PyCharm插件推荐</h1><ul>\n    <li>Key Promoter X: 快捷键提示插件，如果你的鼠标操作可以用快捷键替代则会在右下角提醒你</li>\n    <li>Material Theme UI: 界面美化插件（名字后面带个Lite的是免费版，不带的是付费版）</li>\n    <li>Translation: 翻译插件</li>\n</ul>\n\n\n<h1 id=\"PyCharm优化\"><a href=\"#PyCharm优化\" class=\"headerlink\" title=\"PyCharm优化\"></a>PyCharm优化</h1><p><strong>注意：本章仅针对16G内存的电脑，若你的电脑内存比较小，请自己抉择最大内存设置。</strong></p>\n<p>&emsp;&emsp;点击界面左下角的设置按钮，然后点击<code>编辑自定义VM选项</code>，进入图示界面：</p>\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/py/edit.png\" style=\"zoom:67%;\">\n\n<p>&emsp;&emsp;在列表最后面添加如下语句，这里就不解释具体原因了：</p>\n<blockquote>\n<p>-Dfile.encoding=UTF-8<br>-XX:-UseCounterDecay<br>-XX:+DoEscapeAnalysis</p>\n</blockquote>\n<p>&emsp;&emsp;列表头有两行语句，分别是：<code>-Xms***</code>、<code>-Xmx***</code>。这两个语句分别用于设置最小内存和最大内存限制，这里修改为：<code>-Xms512m</code>、<code>-Xmx2048m</code>。</p>\n"},{"title":"现代工业|开发日志","date":"2020-08-15T12:31:38.000Z","toc_number":false,"cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b1.png","description":"有关“现代工业”的所有代码更新记录以及简单介绍","_content":"\n# 简介\n\n&emsp;&emsp;这里讲罗列出“现代工业”所有的更新记录以及更新内容的介绍。\n\n&emsp;&emsp;目前所有更新日志代号均以“#”开头，以后可能会有变更。\n\n&emsp;&emsp;关于项目的有关内容，可以查看“[爱发电](https://afdian.net/@emptydreams)”中的介绍。\n\n------\n\n# 功能开发顺序\n\n<div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#66ccff\">（顺序由内测组投票决定）</font></div>\n\n| 序号  |        功能        | 难度 |  进度  |\n| :---: | :----------------: | :--: | :----: |\n| **1** | 更舒适的合成表查看 |  3   |  完成  |\n| **2** |      管道系统      |  5   | 编写中 |\n| **3** |    高级配置系统    |  2   |  待机  |\n| **4** |     红石能衰退     |  ?   |  待机  |\n| **5** |       储能器       |  3   |  待机  |\n| **6** |   完整的金属冶炼   |  4   |  待机  |\n| **7** |      精制工具      |  4   |  待机  |\n| **8** |     更多的电器     |  3   |  待机  |\n\n\n\n---\n\n# 新的更新\n\n## #88.更多类型的管道\n\n&emsp;&emsp;目前已有三种类型的管道：直线型、直角拐弯型、十字型，后续可能会添加T字型。\n\n## #89.修复管道已知问题\n\n<ul>\n    <li>玩家复活后复活点附近管道渲染异常</li>\n    <li>管道竖直放置时膨胀箱判定错误</li>\n    <li>道放置连接时已存在的管道时服务端数据更新错误</li>\n    <li>blockstates书写错误</li>\n    <li>直角管道放置时方向判定错误</li>\n    <li>管道连接时模型闪烁</li>\n    <li>管道修改连接时有几率导致游戏崩溃</li>\n    <li>管道水平放置时选择框渲染错误</li>\n    <li>直角管道多方向无法正确连接</li>\n    <li>客户端数据更新后选择框渲染错误</li>\n    <li>管道运输流体后不触发离线存储</li>\n    <li>十字管道转向错误</li>\n    <li>在两个管道中间放置管道显示效果不更新</li>\n    <li>十字管道数据重复</li>\n</ul>\n\n## #90.优化管道算法\n\n&emsp;&emsp;全面重写管道运输算法，尽量避免递归，防止超长管道运输时迭代过多导致堆栈溢出。\n\n## #91.修复优化算法带来的漏洞\n\n<ul>\n    <li>直线管道与直角管道数据方向不更新</li>\n    <li>放置直角管道导致游戏崩溃</li>\n    <li>管道连接时水平流体数据管理器内部错误</li>\n    <li>字管道连接时方向数据同步异常</li>\n</ul>\n\n## #92.修复`dor`的漏洞\n\n&emsp;&emsp;修复`DataReader`无法正确读取VarInt的漏洞。\n\n## #93.新的GUI控件\n\n&emsp;&emsp;添加翻页控件，GUI支持显示多页内容，可以上下翻页也可左右翻页。\n\n## #94.移除老旧的GUI设计\n\n&emsp;&emsp;老旧的GUI渲染设计采用“静态+动态”的绘制方式，这导致诸如`滑动框`、`翻页`等功能实现苦难，故换用新的渲染设计。新的渲染设计采用“纯动态绘制”的绘制方式，并且将控件的坐标设置改为控件在控件组中的坐标而非在GUI中的坐标，减少控件内部和GUI的接触。\n\n## #95.修复新的渲染的漏洞\n\n<ul>\n    <li>进度条绘制错误（完全无法正常显示）</li>\n    <li>画笔坐标错误</li>\n    <li>画笔剪切超出显示范围导致后台报错</li>\n    <li>控件在多控件组嵌套时渲染错误</li>\n    <li>MSlot在多控件组嵌套时Slot坐标计算错误</li>\n    <li>合成表按钮和GUI冲突导致后台报错</li>\n    <li>鼠标坐标判定错误</li>\n    <li>滚动条渲染错误</li>\n    <li>按钮文字渲染错误</li>\n    <li>GL设置错误引起的图像绘制异常</li>\n</ul>\n\n## #96.新的鼠标事件触发方式\n\n&emsp;&emsp;老旧的触发方式已经无法满足新式GUI设计的功能需求，故改用新的鼠标事件触发方式。\n\n&emsp;&emsp;旧触发方式采用：`开始触发事件` -> `扫描控件` -> `触发指定控件的事件`。\n\n&emsp;&emsp;新触发方式采用：`开始触发事件` -> `分配任务至控件组` -> `控件组扫描并触发事件`。\n\n## #97.修复新的事件触发方式带来的漏洞\n\n<ul>\n    <li>鼠标事件无法触发</li>\n    <li>触发鼠标事件过程中坐标发生偏移</li>\n    <li>鼠标事件对象判断失误的漏洞</li>\n    <li>全局鼠标按键当鼠标在控件外时无法触发</li>\n    <li>鼠标离开事件判定错误</li>\n</ul>\n\n\n\n\n\n------\n\n# 历史记录：\n\n## #1 项目的起点\n\n&emsp;&emsp;建立现代工业（ModernIndustry）项目，并建立主类以及完成最为基础的架设，此时MI没有任何代码层面及用户层面的功能。\n\n## #2 建立电力体系\n\n&emsp;&emsp;简单建立电力系统中的基础概念：发电机、用电器、导线。\n\n|    分类    |                                                         介绍 |\n| :--------: | -----------------------------------------------------------: |\n| **发电机** |                               制造能量的机器全部归类于发电机 |\n| **用电器** |                               消耗能量的机器全部归类与用电器 |\n|  **导线**  | 因为导线采用了和机器不同的算法，所以导线单独分类，用于传输能量 |\n|    补充    |                 储电器同时属于发电机与用电器分类，不属于导线 |\n\n## #3 一切的开端---第一个电器\n\n&emsp;&emsp;创建了MI中的第一个机器——压缩机，不过其在电力系统完工之前不需要电能就可以运行，前期主要用于测试代码功能，在电力系统制作时为其添加了消耗电能的功能。\n\n## #4 构建电力系统的基本框架\n\n&emsp;&emsp;构建了电力系统的基本内容与规范，包括：电能概念、电压概念、EleWorker……\n\n|   分类    |                                                         介绍 |\n| :-------: | -----------------------------------------------------------: |\n|   电能    |                               用于表示能量数量的一个指示数字 |\n|   电压    | 用于表示电压等级的一个指示数字，理论上支持所有非负整数，电压与电能无直接联系 |\n| EleWorker |           电力系统的“工作核心”，系统的所有操作都封装在该类中 |\n|  计数器   | 用于在用电器输入电压不符合需求电压时计数并在计数器达到阈值时执行指令的工具 |\n| 线路缓存  | 用于存储线路计算的缓存信息，以此减少线路计算的时间和成本（可以选择不实现缓存功能） |\n\n## #5 第一个导线\n\n&emsp;&emsp;创建了MI中的第一种导线——粗制导线，也是开发前期阶段唯一可用的导线。导线中实现了信息存储、渲染、缓存三大功能，而线路计算则写入了缓存中。\n\n### 线路计算原理：\n\n&emsp;&emsp;在线路计算中，包含三大流程：寻找线路、计算线路、反馈信息。\n\n&emsp;&emsp;其中前两个流程可以用等价的方法替换，顺序也可以调整，但反馈信息必须在最后进行。\n\n|      分类      |                                                         介绍 |\n| :------------: | -----------------------------------------------------------: |\n|  **寻找线路**  |                           寻找指定用电器到非指定发电机的路径 |\n|  **计算线路**  |             计算线路上损耗的电能及发电机最终输出的电能和电压 |\n|  **反馈信息**  |           向电力系统反馈计算结果，系统将根据结果进行数据更新 |\n|      路径      | 表示线路中指定起点到指定终点经过的所有导线方块，包含起点与终点，不包含机器方块 |\n|  非指定发电机  | MI采用被动式电能运输，所以寻找线路时一般并不知道目标发电机的位置 |\n| 被动式电能运输 | 用电器主动向电力系统发起传输电能的请求，然后由电力系统负责完成其余工作 |\n\n&emsp;&emsp;不过MI中的粗制导线没有完全按照上述方法进行，而是按照：`读取缓存 -> 计算线路 -> 反馈信息`的流程工作。\n\n|     分类     |                                                         介绍 |\n| :----------: | -----------------------------------------------------------: |\n| **读取缓存** |               从发电机列表中直接寻找目标发电机，然后读取缓存 |\n| **计算线路** |             若缓存不存在则计算起点到终点的最短路径并写入缓存 |\n|  发电机列表  | 一条线路中所有导线共享同一个缓存，每一根导线都负责维护缓存中的发电机列表 |\n\n&emsp;&emsp;上述列出的第一种方式为粗制导线最初使用的工作流程，后因为技术原因替换为第二种。\n\n## #6 发电机的出现\n\n&emsp;&emsp;添加了第一个发电机方块——无线电能方块，用于测试电力系统是否可以正常工作，也用于给玩家提供一个万能的创造模式用发电机。\n\n## #7 完善电力系统框架\n\n&emsp;&emsp;这是对电力系统第N次重构，完善了电力系统的功能，删除了不需要的部分。从该版本起，缓存彻底被排除在电力系统规范外，是否实现缓存与电力系统工作没有任何关系。\n\n## #8 合成表模块的第一次开发\n\n&emsp;&emsp;原版的合成表本人并不会使用，所以干脆写了一个独立的合成表模块，其中所有内容都是可变的，拓展性较强，但存在结构混乱的缺陷。\n\n## #9 加入自动化概念\n\n&emsp;&emsp;建立了`registry`包，用于自动化注册方块、物品等内容，摆脱手动编码的烦恼。\n\n## #10 自动化的推进\n\n&emsp;&emsp;除方块、物品的自动化注册外，又新提供了部分内容，此时自动化系统变得较为完善，包括以下内容：\n\n|               分类               |                                                         介绍 |\n| :------------------------------: | -----------------------------------------------------------: |\n| **方块、物品、TileEntity的注册** |                                                 基本游戏内容 |\n|           **网络通讯**           |     封装了网络通讯相关的代码，使服务端与客户端的沟通更加简便 |\n|           **数据存储**           | 支持部分数据类型的自动存储，拜托手动编码的烦恼，不过目前仍存在一些限制 |\n|           **GUI绘制**            |  支持运行时绘制GUI材质，拜托手动绘制材质及寻找组件坐标的烦恼 |\n|           **JSON生成**           |                                 自动生成方块、物品的JSON文件 |\n\n## #11 BUG修复\n\n&emsp;&emsp;修复部分BUG。\n\n## #12 GUI绘制\n\n&emsp;&emsp;完善GUI绘制的功能。\n\n## #13 新的功能——属性\n\n&emsp;&emsp;在工具使用时提供额外效果的玩意，有点类似于附魔。\n\n## #14 工具类\n\n&emsp;&emsp;提供了一系列`Util`类，封装了一些常用操作，缩减了代码量。\n\n## #15 时刻表\n\n&emsp;&emsp;用于在指定时间后执行指定操作，因为某些功能限制，在`#38`时被移除。\n\n## #16 添加一系列物品及机器\n\n## #17 GUI绘制的完善\n\n&emsp;&emsp;解决了GUI绘制坐标点寻找烧脑的问题，彻底摆脱思考，同时优化了性能。\n\n## #18 重写合成表模块\n\n&emsp;&emsp;因为合成表模块结构过于混乱，没有任何易用性及美观性，所以重新设计、编写了合成表模块：\n\n|        分类        |                                                         介绍 |\n| :----------------: | -----------------------------------------------------------: |\n| `CraftGuide<T, R>` |                                   创建、管理合成表，数据可变 |\n|     `ItemSol`      |                       存储物品列表，可有序可无序，数据不可变 |\n|   `ItemElement`    |                                     存储单个物品，数据不可变 |\n|      `IShape`      | 合成表，内部存储原料列表和产物列表，可有序可无序，数据不可变 |\n\n## #19 修复线路计算中的问题\n\n&emsp;&emsp;将线路计算方式换为`#5`中的第二种方式。\n\n## #24 优化自动数据存储\n\n&emsp;&emsp;减少了存储类名需要的成本\n\n## #34 优化扳手的玩法\n\n&emsp;&emsp;扳手玩法改为右键不同区域转向不同的方向，`shift + 右键`拆除方块，暂时没有耐久。\n\n## #35 完善自动注册的功能\n\n&emsp;&emsp;使自动注册支持对物品、方块列表进行排序，保证在每次创建存档时创造模式物品栏中的排列顺序不变化。\n\n## #36 第一次材质扩充\n\n## #37 增强合成表模块\n\n&emsp;&emsp;修改了MC原版注册JSON合成表的方法，在其中加入了注册MI的JSON合成表的代码，自此注册合成表可以不再面对繁杂的代码编写。\n\n## #38 修复服务端支持\n\n&emsp;&emsp;修复因代码问题导致的服务端启动崩溃。\n\n## #39 GUI添加鼠标事件\n\n&emsp;&emsp;GUI支持鼠标事件，在鼠标移出、移入、按下、松开或点击控件时会自动调用控件的方法（前提是控件注册了相关事件）。一个控件可以重复注册同一种事件，在事件被触发时所有相同事件都会被触发，不会被遗漏。\n\n## #40 优化自动化网络传输结构\n\n&emsp;&emsp;自动化网络传输采用“注册”结构，添加新的网络传输方式变得更加方便。同时网络传输不再主动询问用户是否需要发送信息，更加偏向半自动化，采用用户主动向网络传输系统发送请求的方式，减少了运行开支。\n\n## #41.添加合成表显示\n\n&emsp;&emsp;预期设计是点击机器的进度条可以查看该机器所有的合成表，不过目前由于网络通信的原因还未添加触发合成表显示的机制。以后还会为合成表添加更多的功能，例如：自动装填。\n\n## #42.修复导线网络通信漏洞\n\n&emsp;&emsp;修复导线的网络通信中由于IDEA“重命名”功能的BUG出现的一些神奇的代码。\n\n## #43.网络通信新功能——GUI通信\n\n&emsp;&emsp;网络通信支持客户端与服务端GUI之间的互相通信。\n\n## #44.GUI支持事件进行网络通信\n\n&emsp;&emsp;MIFrame添加了用于支持注册的事件进行网路单向通信的接口，由于一些设计缺陷以及考虑到代码简洁性的原因，事件的网络通信暂时只支持客户端到服务端的通信（即只能由客户端发送信息到服务端）。\n\n## #45-修复GUI根据鼠标坐标获取组件错误的问题\n\n&emsp;&emsp;原本获取组件的算法有问题，这次修改了算法。\n\n## #46-修复Group内添加的组件鼠标事件错误的问题\n\n&emsp;&emsp;原本的事件触发方式导致`Group`内的鼠标事件无法触发，这次修改了触发方式，使`Group`内组件的鼠标事件也可以正确触发。\n\n## #47-修复GUI按钮响应错误的问题\n\n&emsp;&emsp;修复GUI按钮鼠标事件的错误响应，以及为鼠标点击添加了音效。\n\n## #48-修复GUI组件onAddToGUI方法运行两次\n\n&emsp;&emsp;`StaticFrameClient`构造函数中的错误用法导致客户端`onAddToGUI`运行两次。\n\n## #49.修复Group的错误算法\n\n&emsp;&emsp;`Group`类获取鼠标指向的组件时没有调用组件的判断方法直接返回了组件，导致判断结果异常。\n\n## \\#50.添加合成表按钮\n\n&emsp;&emsp;添加了隐形的合成表按钮，支持全自动调整坐标和尺寸。部分功能依赖`MComponent`执行，所以从该版本开始要求`MComponent`的子类重写`onAddToGUI`方法时必须调用父类对应的方法。\n\n## \\#49-修复Group的错误算法\n\n&emsp;&emsp;`Group`类获取鼠标指向的组件时没有调用组件的判断方法直接返回了组件，导致判断结果异常。\n\n## \\#50.添加合成表按钮\n\n&emsp;&emsp;添加了隐形的合成表按钮，支持全自动调整坐标和尺寸。部分功能依赖`MComponent`执行，所以从该版本开始要求`MComponent`的子类重写`onAddToGUI`方法时必须调用父类对应的方法。\n\n## \\#51-添加对已有所有合成表类型的显示支持\n\n&emsp;&emsp;自动合成表显示目前已经支持对已有四种类型的合成表进行显示：\n\n|      合成表类型      |                         特点介绍 |\n| :------------------: | -------------------------------: |\n|  `OrderlyShapeOnly`  |       原料列表有序，产物仅有一种 |\n| `UnorderlyShapeOnly` |       原料列表无序，产物仅有一种 |\n|    `OrderlyShape`    | 原料列表有序，产物有多种（无序） |\n|   `UnorderlyShape`   | 原料列表无序，产物有多种（无序） |\n\n<div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#66ccff\">注：原料列表有序即相当于有序合成表，无序则为无序合成表</font></div>\n\n## \\#52-修复打开空的合成表时游戏崩溃\n\n&emsp;&emsp;修复打开空的合成表时抛出`IndexOutOfBoundException`及`IllegalArgumentException`导致的程序崩溃。\n\n## #53.修复GUI网络通信时客户端服务端窗体对象可能不一致的漏洞\n\n&emsp;&emsp;以往GUI进行网络通信时，通信内容中并没有存储发送信息的GUI的窗体信息，导致接收端无法判断窗体是否一致，该更新在通讯信息中加入了GUI窗体校验信息，辅助信息正确性校验。\n\n## #54.修复点击合成表按钮响应多次的BUG\n\n&emsp;&emsp;以往按钮注册事件的代码位置错误，导致同一个事件被多次注册，从而使按钮响应多次，该更新修改了注册机制，添加了专门的初始化接口，修正了该BUG。\n\n## #55.添加配置功能\n\n&emsp;&emsp;支持简单的配置功能，预备后续重新写一遍更高级的。\n\n## #56.重写方块JSON生成器\n\n&emsp;&emsp;重写了`BlockJsonBuilder`类，提供了更加高级的功能，支持多种方块的JSON生成，同时支持快捷的模板添加。\n\n## #57.GUI显示调整\n\n&emsp;&emsp;GUI中玩家背包上方添加“物品栏”文字。\n\n## #58.修复自动读写崩溃问题\n\n&emsp;&emsp;当需要存储的值为`null`时会导致存储失败并放弃剩余数据，该问题出现的原因是大部分情况下客户端的TE中并没有存储有效数据。解决方案：客户端不再触发自动读写。\n\n## #59.实现本地GUI渲染\n\n&emsp;&emsp;实现了本地子GUI渲染，允许玩家在已打开的GUI上再打开一个GUI。打开子GUI时会拦截原GUI的所有操作，当玩家尝试关闭GUI时只会关闭子GUI，而原GUI保持开启。\n\n## #60.实现以玩家为凭借的双端通信\n\n&emsp;&emsp;允许以玩家为`KEY`进行服务端客户端双端通信，为保持安全以`UUID`为凭借。\n\n## #61.修复服务端SideOnly问题\n\n&emsp;&emsp;修复因`SideOnly(CLIENT)`导致的服务端BUG。\n\n## #62.修复两端数据不一致导致的BUG\n\n&emsp;&emsp;修复因客户端与服务端`网络注册ID`和`GUI ID`不一致导致的问题。\n\n## #63.修复GUI渲染问题\n\n&emsp;&emsp;修复当传入数据为负值时导致的`CommonProgress`渲染异常。\n\n## #64.字节层次的数据操作——dor\n\n&emsp;&emsp;添加了自制的数据操作库`dor`，主要由`IDataReader`(读取器)和`IDataWriter`(写入器)组成。同时提供了两个默认实现：支持读写的`ByteDataOperator`以及只读的`ReadOnlyDataOperator`。\n\n## #65.新的数据读写系统\n\n&emsp;&emsp;编写全新的数据读写系统，除原本的`NBTTagCompound`支持外，新加了对`ByteBuf`及自制的`dor`的支持。\n\n## #66.新的自动数据读写\n\n&emsp;&emsp;依靠新的数据读写系统编写了全新的自动化数据读写库，运行主要依靠`IClassData`，实现了对数据的自动存储，同时支持数据类型转换。\n\n## #67.完善合成表自动填充的功能\n\n&emsp;&emsp;修复了合成表填充时存在的所有已知BUG，优化合成表显示。\n\n## #68.网络通信换用dor系统\n\n&emsp;&emsp;自动化网络通信全面抛弃`NBTTagCompound`，使用`dor`读写系统。\n\n## #69.修复dor漏洞及优化功能\n\n<ul>\n    <li>修复读写数据时下标错误的更新</li>\n    <li>修复读写占用多字节的数据时的错误移位操作</li>\n    <li>修复读写varint时的错误移位操作</li>\n    <li>优化不合理的写入顺序</li>\n</ul>\n## #70.移除“属性”功能\n\n&emsp;&emsp;由于`属性`功能与附魔玩法重复并且存在漏洞，所以决定将该功能删除。\n\n## #71.添加虚拟dor\n\n&emsp;&emsp;添加了`VarDataReader`类，用于在不复制任何数据的情况下进行`data`读取，优化了`IDataReader#readData()`的时间成本及空间成本。\n\n## #72.修复自动化网络通信的BUG\n\n&emsp;&emsp;修复基于方块的网络通信中可能存在的进行网络通信时客户端世界未构造完毕的BUG。\n\n## #73.修复合成表填充显示异常\n\n&emsp;&emsp;修复合成表填充后GUI显示异常，通过在填充合成表后代码触发数据同步来更新GUI显示。\n\n## #74.支持自动注册流体\n\n&emsp;&emsp;支持自动注册流体、流体物品、流体方块及流体桶。\n\n## #75.自动注册系统改用注册机制\n\n&emsp;&emsp;自动注册系统换用注册机制添加注册类型，拓展性更强。\n\n## #76.修复一些小漏洞\n\n<ul>\n    <li>生成本地名称时将\".\"误写为\":\"\n    <li>矿石生成器注册异常\n    <li>Mixin编译报错\n    <li>新版自动注册不调用排序方法\n    <li>某些注册机错误处理本地名称\n    <li>Json生成器对key的错误处理\n</ul>\n\n\n## #77.完善组件\n\n<ul>\n    <li>补充GUI材质\n    <li>扩充字典内容\n    <li>完善语言文件（中文简体）\n</ul>\n\n\n## #78.添加流体管道的接口\n\n&emsp;&emsp;添加了流体管道需要用到的接口（可能不全，后续调整），大致确定了流体管道工作方式。\n\n## #79.添加流体管道的TileEntity的默认实现\n\n&emsp;&emsp;默认的`TIleEntity`实现了对管道需要用到的数据的底层管理，包括渲染数据、连接数据、存储数据等。\n\n## #80.GUI自动绘制添加更多的事件\n\n&emsp;&emsp;GUI自动绘制添加了`MouseLocationListener`事件，该事件每Tick在组件绘制前被触发，用于记录鼠标坐标的更改。同时还修改了部分GUI鼠标事件的触发方式，让事件功能更加强大。\n\n## #81.GUI添加滚动条控件\n\n&emsp;&emsp;向自动化GUI系统添加滚动条控件，效果与创造模式背包右侧的滚动条类似。\n\n## #82.GUI添加更多事件\n\n&emsp;&emsp;支持控件监视键盘事件（包括按下和释放）以及鼠标滚轮滑动事件。\n\n## #83.添加类信息查看器\n\n&emsp;&emsp;添加类信息查看器，右键方块即可查看方块`TileEntity`中存储的信息。该物品是为了取代老旧的线缆信息查看器，故同时删除了线缆信息查看器。\n\n## #84.优化和完善自动化数据存储\n\n<ul>\n    <li>优化对枚举类的存储，占用更少的空间</li>\n    <li>自动化数据存储类型转换默认支持到字符串的转换</li>\n    <li>已有的类型添加更完善的类型转换功能</li>\n</ul>\n\n\n## #85.修复并优化管道的部分功能\n\n<ul>\n    <li><b>修复：</b>放置时不自动连接周围方块</li>\n    <li><b>修复：</b>数据读取时报错导致无法正确恢复存档内容</li>\n    <li><b>修复：</b>管道放置时朝向数据客户端服务端计算结果不一致</li>\n    <li><b>修复：</b>管道输出流体到世界后流体不会流动</li>\n    <li><b>优化：</b>移除多余的数据</li>\n    <li><b>优化：</b>细化碰撞箱</li>\n    <li><b>优化：</b>管道放置时的朝向判断</li>\n    <li><b>优化：</b>管道的网络资源占用</li>\n    <li><b>添加：</b>支持添加管塞</li>\n\n\n</ul>\n\n## #86.修复功能优化带来的漏洞\n\n<ul>\n    <li>导线无法正常连接周围方块</li>\n    <li>机器无法正常从导线获取能量</li>\n</ul>\n\n\n## #87.优化包/类结构\n\n&emsp;&emsp;将`BlockUtil`合并到`WorldUtil`中，修改部分包名，修改部分包的包含结构。","source":"_posts/dlog.md","raw":"---\ntitle: 现代工业|开发日志\ndate: 2020-08-15 20:31:38\ntoc_number: false\ncategories:\n  - Java\ntags:\n  - 现代工业\n  - MC\n  - 日志\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b1.png\ndescription: 有关“现代工业”的所有代码更新记录以及简单介绍\n---\n\n# 简介\n\n&emsp;&emsp;这里讲罗列出“现代工业”所有的更新记录以及更新内容的介绍。\n\n&emsp;&emsp;目前所有更新日志代号均以“#”开头，以后可能会有变更。\n\n&emsp;&emsp;关于项目的有关内容，可以查看“[爱发电](https://afdian.net/@emptydreams)”中的介绍。\n\n------\n\n# 功能开发顺序\n\n<div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#66ccff\">（顺序由内测组投票决定）</font></div>\n\n| 序号  |        功能        | 难度 |  进度  |\n| :---: | :----------------: | :--: | :----: |\n| **1** | 更舒适的合成表查看 |  3   |  完成  |\n| **2** |      管道系统      |  5   | 编写中 |\n| **3** |    高级配置系统    |  2   |  待机  |\n| **4** |     红石能衰退     |  ?   |  待机  |\n| **5** |       储能器       |  3   |  待机  |\n| **6** |   完整的金属冶炼   |  4   |  待机  |\n| **7** |      精制工具      |  4   |  待机  |\n| **8** |     更多的电器     |  3   |  待机  |\n\n\n\n---\n\n# 新的更新\n\n## #88.更多类型的管道\n\n&emsp;&emsp;目前已有三种类型的管道：直线型、直角拐弯型、十字型，后续可能会添加T字型。\n\n## #89.修复管道已知问题\n\n<ul>\n    <li>玩家复活后复活点附近管道渲染异常</li>\n    <li>管道竖直放置时膨胀箱判定错误</li>\n    <li>道放置连接时已存在的管道时服务端数据更新错误</li>\n    <li>blockstates书写错误</li>\n    <li>直角管道放置时方向判定错误</li>\n    <li>管道连接时模型闪烁</li>\n    <li>管道修改连接时有几率导致游戏崩溃</li>\n    <li>管道水平放置时选择框渲染错误</li>\n    <li>直角管道多方向无法正确连接</li>\n    <li>客户端数据更新后选择框渲染错误</li>\n    <li>管道运输流体后不触发离线存储</li>\n    <li>十字管道转向错误</li>\n    <li>在两个管道中间放置管道显示效果不更新</li>\n    <li>十字管道数据重复</li>\n</ul>\n\n## #90.优化管道算法\n\n&emsp;&emsp;全面重写管道运输算法，尽量避免递归，防止超长管道运输时迭代过多导致堆栈溢出。\n\n## #91.修复优化算法带来的漏洞\n\n<ul>\n    <li>直线管道与直角管道数据方向不更新</li>\n    <li>放置直角管道导致游戏崩溃</li>\n    <li>管道连接时水平流体数据管理器内部错误</li>\n    <li>字管道连接时方向数据同步异常</li>\n</ul>\n\n## #92.修复`dor`的漏洞\n\n&emsp;&emsp;修复`DataReader`无法正确读取VarInt的漏洞。\n\n## #93.新的GUI控件\n\n&emsp;&emsp;添加翻页控件，GUI支持显示多页内容，可以上下翻页也可左右翻页。\n\n## #94.移除老旧的GUI设计\n\n&emsp;&emsp;老旧的GUI渲染设计采用“静态+动态”的绘制方式，这导致诸如`滑动框`、`翻页`等功能实现苦难，故换用新的渲染设计。新的渲染设计采用“纯动态绘制”的绘制方式，并且将控件的坐标设置改为控件在控件组中的坐标而非在GUI中的坐标，减少控件内部和GUI的接触。\n\n## #95.修复新的渲染的漏洞\n\n<ul>\n    <li>进度条绘制错误（完全无法正常显示）</li>\n    <li>画笔坐标错误</li>\n    <li>画笔剪切超出显示范围导致后台报错</li>\n    <li>控件在多控件组嵌套时渲染错误</li>\n    <li>MSlot在多控件组嵌套时Slot坐标计算错误</li>\n    <li>合成表按钮和GUI冲突导致后台报错</li>\n    <li>鼠标坐标判定错误</li>\n    <li>滚动条渲染错误</li>\n    <li>按钮文字渲染错误</li>\n    <li>GL设置错误引起的图像绘制异常</li>\n</ul>\n\n## #96.新的鼠标事件触发方式\n\n&emsp;&emsp;老旧的触发方式已经无法满足新式GUI设计的功能需求，故改用新的鼠标事件触发方式。\n\n&emsp;&emsp;旧触发方式采用：`开始触发事件` -> `扫描控件` -> `触发指定控件的事件`。\n\n&emsp;&emsp;新触发方式采用：`开始触发事件` -> `分配任务至控件组` -> `控件组扫描并触发事件`。\n\n## #97.修复新的事件触发方式带来的漏洞\n\n<ul>\n    <li>鼠标事件无法触发</li>\n    <li>触发鼠标事件过程中坐标发生偏移</li>\n    <li>鼠标事件对象判断失误的漏洞</li>\n    <li>全局鼠标按键当鼠标在控件外时无法触发</li>\n    <li>鼠标离开事件判定错误</li>\n</ul>\n\n\n\n\n\n------\n\n# 历史记录：\n\n## #1 项目的起点\n\n&emsp;&emsp;建立现代工业（ModernIndustry）项目，并建立主类以及完成最为基础的架设，此时MI没有任何代码层面及用户层面的功能。\n\n## #2 建立电力体系\n\n&emsp;&emsp;简单建立电力系统中的基础概念：发电机、用电器、导线。\n\n|    分类    |                                                         介绍 |\n| :--------: | -----------------------------------------------------------: |\n| **发电机** |                               制造能量的机器全部归类于发电机 |\n| **用电器** |                               消耗能量的机器全部归类与用电器 |\n|  **导线**  | 因为导线采用了和机器不同的算法，所以导线单独分类，用于传输能量 |\n|    补充    |                 储电器同时属于发电机与用电器分类，不属于导线 |\n\n## #3 一切的开端---第一个电器\n\n&emsp;&emsp;创建了MI中的第一个机器——压缩机，不过其在电力系统完工之前不需要电能就可以运行，前期主要用于测试代码功能，在电力系统制作时为其添加了消耗电能的功能。\n\n## #4 构建电力系统的基本框架\n\n&emsp;&emsp;构建了电力系统的基本内容与规范，包括：电能概念、电压概念、EleWorker……\n\n|   分类    |                                                         介绍 |\n| :-------: | -----------------------------------------------------------: |\n|   电能    |                               用于表示能量数量的一个指示数字 |\n|   电压    | 用于表示电压等级的一个指示数字，理论上支持所有非负整数，电压与电能无直接联系 |\n| EleWorker |           电力系统的“工作核心”，系统的所有操作都封装在该类中 |\n|  计数器   | 用于在用电器输入电压不符合需求电压时计数并在计数器达到阈值时执行指令的工具 |\n| 线路缓存  | 用于存储线路计算的缓存信息，以此减少线路计算的时间和成本（可以选择不实现缓存功能） |\n\n## #5 第一个导线\n\n&emsp;&emsp;创建了MI中的第一种导线——粗制导线，也是开发前期阶段唯一可用的导线。导线中实现了信息存储、渲染、缓存三大功能，而线路计算则写入了缓存中。\n\n### 线路计算原理：\n\n&emsp;&emsp;在线路计算中，包含三大流程：寻找线路、计算线路、反馈信息。\n\n&emsp;&emsp;其中前两个流程可以用等价的方法替换，顺序也可以调整，但反馈信息必须在最后进行。\n\n|      分类      |                                                         介绍 |\n| :------------: | -----------------------------------------------------------: |\n|  **寻找线路**  |                           寻找指定用电器到非指定发电机的路径 |\n|  **计算线路**  |             计算线路上损耗的电能及发电机最终输出的电能和电压 |\n|  **反馈信息**  |           向电力系统反馈计算结果，系统将根据结果进行数据更新 |\n|      路径      | 表示线路中指定起点到指定终点经过的所有导线方块，包含起点与终点，不包含机器方块 |\n|  非指定发电机  | MI采用被动式电能运输，所以寻找线路时一般并不知道目标发电机的位置 |\n| 被动式电能运输 | 用电器主动向电力系统发起传输电能的请求，然后由电力系统负责完成其余工作 |\n\n&emsp;&emsp;不过MI中的粗制导线没有完全按照上述方法进行，而是按照：`读取缓存 -> 计算线路 -> 反馈信息`的流程工作。\n\n|     分类     |                                                         介绍 |\n| :----------: | -----------------------------------------------------------: |\n| **读取缓存** |               从发电机列表中直接寻找目标发电机，然后读取缓存 |\n| **计算线路** |             若缓存不存在则计算起点到终点的最短路径并写入缓存 |\n|  发电机列表  | 一条线路中所有导线共享同一个缓存，每一根导线都负责维护缓存中的发电机列表 |\n\n&emsp;&emsp;上述列出的第一种方式为粗制导线最初使用的工作流程，后因为技术原因替换为第二种。\n\n## #6 发电机的出现\n\n&emsp;&emsp;添加了第一个发电机方块——无线电能方块，用于测试电力系统是否可以正常工作，也用于给玩家提供一个万能的创造模式用发电机。\n\n## #7 完善电力系统框架\n\n&emsp;&emsp;这是对电力系统第N次重构，完善了电力系统的功能，删除了不需要的部分。从该版本起，缓存彻底被排除在电力系统规范外，是否实现缓存与电力系统工作没有任何关系。\n\n## #8 合成表模块的第一次开发\n\n&emsp;&emsp;原版的合成表本人并不会使用，所以干脆写了一个独立的合成表模块，其中所有内容都是可变的，拓展性较强，但存在结构混乱的缺陷。\n\n## #9 加入自动化概念\n\n&emsp;&emsp;建立了`registry`包，用于自动化注册方块、物品等内容，摆脱手动编码的烦恼。\n\n## #10 自动化的推进\n\n&emsp;&emsp;除方块、物品的自动化注册外，又新提供了部分内容，此时自动化系统变得较为完善，包括以下内容：\n\n|               分类               |                                                         介绍 |\n| :------------------------------: | -----------------------------------------------------------: |\n| **方块、物品、TileEntity的注册** |                                                 基本游戏内容 |\n|           **网络通讯**           |     封装了网络通讯相关的代码，使服务端与客户端的沟通更加简便 |\n|           **数据存储**           | 支持部分数据类型的自动存储，拜托手动编码的烦恼，不过目前仍存在一些限制 |\n|           **GUI绘制**            |  支持运行时绘制GUI材质，拜托手动绘制材质及寻找组件坐标的烦恼 |\n|           **JSON生成**           |                                 自动生成方块、物品的JSON文件 |\n\n## #11 BUG修复\n\n&emsp;&emsp;修复部分BUG。\n\n## #12 GUI绘制\n\n&emsp;&emsp;完善GUI绘制的功能。\n\n## #13 新的功能——属性\n\n&emsp;&emsp;在工具使用时提供额外效果的玩意，有点类似于附魔。\n\n## #14 工具类\n\n&emsp;&emsp;提供了一系列`Util`类，封装了一些常用操作，缩减了代码量。\n\n## #15 时刻表\n\n&emsp;&emsp;用于在指定时间后执行指定操作，因为某些功能限制，在`#38`时被移除。\n\n## #16 添加一系列物品及机器\n\n## #17 GUI绘制的完善\n\n&emsp;&emsp;解决了GUI绘制坐标点寻找烧脑的问题，彻底摆脱思考，同时优化了性能。\n\n## #18 重写合成表模块\n\n&emsp;&emsp;因为合成表模块结构过于混乱，没有任何易用性及美观性，所以重新设计、编写了合成表模块：\n\n|        分类        |                                                         介绍 |\n| :----------------: | -----------------------------------------------------------: |\n| `CraftGuide<T, R>` |                                   创建、管理合成表，数据可变 |\n|     `ItemSol`      |                       存储物品列表，可有序可无序，数据不可变 |\n|   `ItemElement`    |                                     存储单个物品，数据不可变 |\n|      `IShape`      | 合成表，内部存储原料列表和产物列表，可有序可无序，数据不可变 |\n\n## #19 修复线路计算中的问题\n\n&emsp;&emsp;将线路计算方式换为`#5`中的第二种方式。\n\n## #24 优化自动数据存储\n\n&emsp;&emsp;减少了存储类名需要的成本\n\n## #34 优化扳手的玩法\n\n&emsp;&emsp;扳手玩法改为右键不同区域转向不同的方向，`shift + 右键`拆除方块，暂时没有耐久。\n\n## #35 完善自动注册的功能\n\n&emsp;&emsp;使自动注册支持对物品、方块列表进行排序，保证在每次创建存档时创造模式物品栏中的排列顺序不变化。\n\n## #36 第一次材质扩充\n\n## #37 增强合成表模块\n\n&emsp;&emsp;修改了MC原版注册JSON合成表的方法，在其中加入了注册MI的JSON合成表的代码，自此注册合成表可以不再面对繁杂的代码编写。\n\n## #38 修复服务端支持\n\n&emsp;&emsp;修复因代码问题导致的服务端启动崩溃。\n\n## #39 GUI添加鼠标事件\n\n&emsp;&emsp;GUI支持鼠标事件，在鼠标移出、移入、按下、松开或点击控件时会自动调用控件的方法（前提是控件注册了相关事件）。一个控件可以重复注册同一种事件，在事件被触发时所有相同事件都会被触发，不会被遗漏。\n\n## #40 优化自动化网络传输结构\n\n&emsp;&emsp;自动化网络传输采用“注册”结构，添加新的网络传输方式变得更加方便。同时网络传输不再主动询问用户是否需要发送信息，更加偏向半自动化，采用用户主动向网络传输系统发送请求的方式，减少了运行开支。\n\n## #41.添加合成表显示\n\n&emsp;&emsp;预期设计是点击机器的进度条可以查看该机器所有的合成表，不过目前由于网络通信的原因还未添加触发合成表显示的机制。以后还会为合成表添加更多的功能，例如：自动装填。\n\n## #42.修复导线网络通信漏洞\n\n&emsp;&emsp;修复导线的网络通信中由于IDEA“重命名”功能的BUG出现的一些神奇的代码。\n\n## #43.网络通信新功能——GUI通信\n\n&emsp;&emsp;网络通信支持客户端与服务端GUI之间的互相通信。\n\n## #44.GUI支持事件进行网络通信\n\n&emsp;&emsp;MIFrame添加了用于支持注册的事件进行网路单向通信的接口，由于一些设计缺陷以及考虑到代码简洁性的原因，事件的网络通信暂时只支持客户端到服务端的通信（即只能由客户端发送信息到服务端）。\n\n## #45-修复GUI根据鼠标坐标获取组件错误的问题\n\n&emsp;&emsp;原本获取组件的算法有问题，这次修改了算法。\n\n## #46-修复Group内添加的组件鼠标事件错误的问题\n\n&emsp;&emsp;原本的事件触发方式导致`Group`内的鼠标事件无法触发，这次修改了触发方式，使`Group`内组件的鼠标事件也可以正确触发。\n\n## #47-修复GUI按钮响应错误的问题\n\n&emsp;&emsp;修复GUI按钮鼠标事件的错误响应，以及为鼠标点击添加了音效。\n\n## #48-修复GUI组件onAddToGUI方法运行两次\n\n&emsp;&emsp;`StaticFrameClient`构造函数中的错误用法导致客户端`onAddToGUI`运行两次。\n\n## #49.修复Group的错误算法\n\n&emsp;&emsp;`Group`类获取鼠标指向的组件时没有调用组件的判断方法直接返回了组件，导致判断结果异常。\n\n## \\#50.添加合成表按钮\n\n&emsp;&emsp;添加了隐形的合成表按钮，支持全自动调整坐标和尺寸。部分功能依赖`MComponent`执行，所以从该版本开始要求`MComponent`的子类重写`onAddToGUI`方法时必须调用父类对应的方法。\n\n## \\#49-修复Group的错误算法\n\n&emsp;&emsp;`Group`类获取鼠标指向的组件时没有调用组件的判断方法直接返回了组件，导致判断结果异常。\n\n## \\#50.添加合成表按钮\n\n&emsp;&emsp;添加了隐形的合成表按钮，支持全自动调整坐标和尺寸。部分功能依赖`MComponent`执行，所以从该版本开始要求`MComponent`的子类重写`onAddToGUI`方法时必须调用父类对应的方法。\n\n## \\#51-添加对已有所有合成表类型的显示支持\n\n&emsp;&emsp;自动合成表显示目前已经支持对已有四种类型的合成表进行显示：\n\n|      合成表类型      |                         特点介绍 |\n| :------------------: | -------------------------------: |\n|  `OrderlyShapeOnly`  |       原料列表有序，产物仅有一种 |\n| `UnorderlyShapeOnly` |       原料列表无序，产物仅有一种 |\n|    `OrderlyShape`    | 原料列表有序，产物有多种（无序） |\n|   `UnorderlyShape`   | 原料列表无序，产物有多种（无序） |\n\n<div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#66ccff\">注：原料列表有序即相当于有序合成表，无序则为无序合成表</font></div>\n\n## \\#52-修复打开空的合成表时游戏崩溃\n\n&emsp;&emsp;修复打开空的合成表时抛出`IndexOutOfBoundException`及`IllegalArgumentException`导致的程序崩溃。\n\n## #53.修复GUI网络通信时客户端服务端窗体对象可能不一致的漏洞\n\n&emsp;&emsp;以往GUI进行网络通信时，通信内容中并没有存储发送信息的GUI的窗体信息，导致接收端无法判断窗体是否一致，该更新在通讯信息中加入了GUI窗体校验信息，辅助信息正确性校验。\n\n## #54.修复点击合成表按钮响应多次的BUG\n\n&emsp;&emsp;以往按钮注册事件的代码位置错误，导致同一个事件被多次注册，从而使按钮响应多次，该更新修改了注册机制，添加了专门的初始化接口，修正了该BUG。\n\n## #55.添加配置功能\n\n&emsp;&emsp;支持简单的配置功能，预备后续重新写一遍更高级的。\n\n## #56.重写方块JSON生成器\n\n&emsp;&emsp;重写了`BlockJsonBuilder`类，提供了更加高级的功能，支持多种方块的JSON生成，同时支持快捷的模板添加。\n\n## #57.GUI显示调整\n\n&emsp;&emsp;GUI中玩家背包上方添加“物品栏”文字。\n\n## #58.修复自动读写崩溃问题\n\n&emsp;&emsp;当需要存储的值为`null`时会导致存储失败并放弃剩余数据，该问题出现的原因是大部分情况下客户端的TE中并没有存储有效数据。解决方案：客户端不再触发自动读写。\n\n## #59.实现本地GUI渲染\n\n&emsp;&emsp;实现了本地子GUI渲染，允许玩家在已打开的GUI上再打开一个GUI。打开子GUI时会拦截原GUI的所有操作，当玩家尝试关闭GUI时只会关闭子GUI，而原GUI保持开启。\n\n## #60.实现以玩家为凭借的双端通信\n\n&emsp;&emsp;允许以玩家为`KEY`进行服务端客户端双端通信，为保持安全以`UUID`为凭借。\n\n## #61.修复服务端SideOnly问题\n\n&emsp;&emsp;修复因`SideOnly(CLIENT)`导致的服务端BUG。\n\n## #62.修复两端数据不一致导致的BUG\n\n&emsp;&emsp;修复因客户端与服务端`网络注册ID`和`GUI ID`不一致导致的问题。\n\n## #63.修复GUI渲染问题\n\n&emsp;&emsp;修复当传入数据为负值时导致的`CommonProgress`渲染异常。\n\n## #64.字节层次的数据操作——dor\n\n&emsp;&emsp;添加了自制的数据操作库`dor`，主要由`IDataReader`(读取器)和`IDataWriter`(写入器)组成。同时提供了两个默认实现：支持读写的`ByteDataOperator`以及只读的`ReadOnlyDataOperator`。\n\n## #65.新的数据读写系统\n\n&emsp;&emsp;编写全新的数据读写系统，除原本的`NBTTagCompound`支持外，新加了对`ByteBuf`及自制的`dor`的支持。\n\n## #66.新的自动数据读写\n\n&emsp;&emsp;依靠新的数据读写系统编写了全新的自动化数据读写库，运行主要依靠`IClassData`，实现了对数据的自动存储，同时支持数据类型转换。\n\n## #67.完善合成表自动填充的功能\n\n&emsp;&emsp;修复了合成表填充时存在的所有已知BUG，优化合成表显示。\n\n## #68.网络通信换用dor系统\n\n&emsp;&emsp;自动化网络通信全面抛弃`NBTTagCompound`，使用`dor`读写系统。\n\n## #69.修复dor漏洞及优化功能\n\n<ul>\n    <li>修复读写数据时下标错误的更新</li>\n    <li>修复读写占用多字节的数据时的错误移位操作</li>\n    <li>修复读写varint时的错误移位操作</li>\n    <li>优化不合理的写入顺序</li>\n</ul>\n## #70.移除“属性”功能\n\n&emsp;&emsp;由于`属性`功能与附魔玩法重复并且存在漏洞，所以决定将该功能删除。\n\n## #71.添加虚拟dor\n\n&emsp;&emsp;添加了`VarDataReader`类，用于在不复制任何数据的情况下进行`data`读取，优化了`IDataReader#readData()`的时间成本及空间成本。\n\n## #72.修复自动化网络通信的BUG\n\n&emsp;&emsp;修复基于方块的网络通信中可能存在的进行网络通信时客户端世界未构造完毕的BUG。\n\n## #73.修复合成表填充显示异常\n\n&emsp;&emsp;修复合成表填充后GUI显示异常，通过在填充合成表后代码触发数据同步来更新GUI显示。\n\n## #74.支持自动注册流体\n\n&emsp;&emsp;支持自动注册流体、流体物品、流体方块及流体桶。\n\n## #75.自动注册系统改用注册机制\n\n&emsp;&emsp;自动注册系统换用注册机制添加注册类型，拓展性更强。\n\n## #76.修复一些小漏洞\n\n<ul>\n    <li>生成本地名称时将\".\"误写为\":\"\n    <li>矿石生成器注册异常\n    <li>Mixin编译报错\n    <li>新版自动注册不调用排序方法\n    <li>某些注册机错误处理本地名称\n    <li>Json生成器对key的错误处理\n</ul>\n\n\n## #77.完善组件\n\n<ul>\n    <li>补充GUI材质\n    <li>扩充字典内容\n    <li>完善语言文件（中文简体）\n</ul>\n\n\n## #78.添加流体管道的接口\n\n&emsp;&emsp;添加了流体管道需要用到的接口（可能不全，后续调整），大致确定了流体管道工作方式。\n\n## #79.添加流体管道的TileEntity的默认实现\n\n&emsp;&emsp;默认的`TIleEntity`实现了对管道需要用到的数据的底层管理，包括渲染数据、连接数据、存储数据等。\n\n## #80.GUI自动绘制添加更多的事件\n\n&emsp;&emsp;GUI自动绘制添加了`MouseLocationListener`事件，该事件每Tick在组件绘制前被触发，用于记录鼠标坐标的更改。同时还修改了部分GUI鼠标事件的触发方式，让事件功能更加强大。\n\n## #81.GUI添加滚动条控件\n\n&emsp;&emsp;向自动化GUI系统添加滚动条控件，效果与创造模式背包右侧的滚动条类似。\n\n## #82.GUI添加更多事件\n\n&emsp;&emsp;支持控件监视键盘事件（包括按下和释放）以及鼠标滚轮滑动事件。\n\n## #83.添加类信息查看器\n\n&emsp;&emsp;添加类信息查看器，右键方块即可查看方块`TileEntity`中存储的信息。该物品是为了取代老旧的线缆信息查看器，故同时删除了线缆信息查看器。\n\n## #84.优化和完善自动化数据存储\n\n<ul>\n    <li>优化对枚举类的存储，占用更少的空间</li>\n    <li>自动化数据存储类型转换默认支持到字符串的转换</li>\n    <li>已有的类型添加更完善的类型转换功能</li>\n</ul>\n\n\n## #85.修复并优化管道的部分功能\n\n<ul>\n    <li><b>修复：</b>放置时不自动连接周围方块</li>\n    <li><b>修复：</b>数据读取时报错导致无法正确恢复存档内容</li>\n    <li><b>修复：</b>管道放置时朝向数据客户端服务端计算结果不一致</li>\n    <li><b>修复：</b>管道输出流体到世界后流体不会流动</li>\n    <li><b>优化：</b>移除多余的数据</li>\n    <li><b>优化：</b>细化碰撞箱</li>\n    <li><b>优化：</b>管道放置时的朝向判断</li>\n    <li><b>优化：</b>管道的网络资源占用</li>\n    <li><b>添加：</b>支持添加管塞</li>\n\n\n</ul>\n\n## #86.修复功能优化带来的漏洞\n\n<ul>\n    <li>导线无法正常连接周围方块</li>\n    <li>机器无法正常从导线获取能量</li>\n</ul>\n\n\n## #87.优化包/类结构\n\n&emsp;&emsp;将`BlockUtil`合并到`WorldUtil`中，修改部分包名，修改部分包的包含结构。","slug":"dlog","published":1,"updated":"2021-09-29T07:45:46.075Z","_id":"cku22zp3l001f7kwq5f583j93","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>&emsp;&emsp;这里讲罗列出“现代工业”所有的更新记录以及更新内容的介绍。</p>\n<p>&emsp;&emsp;目前所有更新日志代号均以“#”开头，以后可能会有变更。</p>\n<p>&emsp;&emsp;关于项目的有关内容，可以查看“<a href=\"https://afdian.net/@emptydreams\">爱发电</a>”中的介绍。</p>\n<hr>\n<h1 id=\"功能开发顺序\"><a href=\"#功能开发顺序\" class=\"headerlink\" title=\"功能开发顺序\"></a>功能开发顺序</h1><div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#66ccff\">（顺序由内测组投票决定）</font></div>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">序号</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">难度</th>\n<th align=\"center\">进度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\">更舒适的合成表查看</td>\n<td align=\"center\">3</td>\n<td align=\"center\">完成</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>2</strong></td>\n<td align=\"center\">管道系统</td>\n<td align=\"center\">5</td>\n<td align=\"center\">编写中</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>3</strong></td>\n<td align=\"center\">高级配置系统</td>\n<td align=\"center\">2</td>\n<td align=\"center\">待机</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>4</strong></td>\n<td align=\"center\">红石能衰退</td>\n<td align=\"center\">?</td>\n<td align=\"center\">待机</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>5</strong></td>\n<td align=\"center\">储能器</td>\n<td align=\"center\">3</td>\n<td align=\"center\">待机</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>6</strong></td>\n<td align=\"center\">完整的金属冶炼</td>\n<td align=\"center\">4</td>\n<td align=\"center\">待机</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>7</strong></td>\n<td align=\"center\">精制工具</td>\n<td align=\"center\">4</td>\n<td align=\"center\">待机</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>8</strong></td>\n<td align=\"center\">更多的电器</td>\n<td align=\"center\">3</td>\n<td align=\"center\">待机</td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"新的更新\"><a href=\"#新的更新\" class=\"headerlink\" title=\"新的更新\"></a>新的更新</h1><h2 id=\"88-更多类型的管道\"><a href=\"#88-更多类型的管道\" class=\"headerlink\" title=\"#88.更多类型的管道\"></a>#88.更多类型的管道</h2><p>&emsp;&emsp;目前已有三种类型的管道：直线型、直角拐弯型、十字型，后续可能会添加T字型。</p>\n<h2 id=\"89-修复管道已知问题\"><a href=\"#89-修复管道已知问题\" class=\"headerlink\" title=\"#89.修复管道已知问题\"></a>#89.修复管道已知问题</h2><ul>\n    <li>玩家复活后复活点附近管道渲染异常</li>\n    <li>管道竖直放置时膨胀箱判定错误</li>\n    <li>道放置连接时已存在的管道时服务端数据更新错误</li>\n    <li>blockstates书写错误</li>\n    <li>直角管道放置时方向判定错误</li>\n    <li>管道连接时模型闪烁</li>\n    <li>管道修改连接时有几率导致游戏崩溃</li>\n    <li>管道水平放置时选择框渲染错误</li>\n    <li>直角管道多方向无法正确连接</li>\n    <li>客户端数据更新后选择框渲染错误</li>\n    <li>管道运输流体后不触发离线存储</li>\n    <li>十字管道转向错误</li>\n    <li>在两个管道中间放置管道显示效果不更新</li>\n    <li>十字管道数据重复</li>\n</ul>\n\n<h2 id=\"90-优化管道算法\"><a href=\"#90-优化管道算法\" class=\"headerlink\" title=\"#90.优化管道算法\"></a>#90.优化管道算法</h2><p>&emsp;&emsp;全面重写管道运输算法，尽量避免递归，防止超长管道运输时迭代过多导致堆栈溢出。</p>\n<h2 id=\"91-修复优化算法带来的漏洞\"><a href=\"#91-修复优化算法带来的漏洞\" class=\"headerlink\" title=\"#91.修复优化算法带来的漏洞\"></a>#91.修复优化算法带来的漏洞</h2><ul>\n    <li>直线管道与直角管道数据方向不更新</li>\n    <li>放置直角管道导致游戏崩溃</li>\n    <li>管道连接时水平流体数据管理器内部错误</li>\n    <li>字管道连接时方向数据同步异常</li>\n</ul>\n\n<h2 id=\"92-修复dor的漏洞\"><a href=\"#92-修复dor的漏洞\" class=\"headerlink\" title=\"#92.修复dor的漏洞\"></a>#92.修复<code>dor</code>的漏洞</h2><p>&emsp;&emsp;修复<code>DataReader</code>无法正确读取VarInt的漏洞。</p>\n<h2 id=\"93-新的GUI控件\"><a href=\"#93-新的GUI控件\" class=\"headerlink\" title=\"#93.新的GUI控件\"></a>#93.新的GUI控件</h2><p>&emsp;&emsp;添加翻页控件，GUI支持显示多页内容，可以上下翻页也可左右翻页。</p>\n<h2 id=\"94-移除老旧的GUI设计\"><a href=\"#94-移除老旧的GUI设计\" class=\"headerlink\" title=\"#94.移除老旧的GUI设计\"></a>#94.移除老旧的GUI设计</h2><p>&emsp;&emsp;老旧的GUI渲染设计采用“静态+动态”的绘制方式，这导致诸如<code>滑动框</code>、<code>翻页</code>等功能实现苦难，故换用新的渲染设计。新的渲染设计采用“纯动态绘制”的绘制方式，并且将控件的坐标设置改为控件在控件组中的坐标而非在GUI中的坐标，减少控件内部和GUI的接触。</p>\n<h2 id=\"95-修复新的渲染的漏洞\"><a href=\"#95-修复新的渲染的漏洞\" class=\"headerlink\" title=\"#95.修复新的渲染的漏洞\"></a>#95.修复新的渲染的漏洞</h2><ul>\n    <li>进度条绘制错误（完全无法正常显示）</li>\n    <li>画笔坐标错误</li>\n    <li>画笔剪切超出显示范围导致后台报错</li>\n    <li>控件在多控件组嵌套时渲染错误</li>\n    <li>MSlot在多控件组嵌套时Slot坐标计算错误</li>\n    <li>合成表按钮和GUI冲突导致后台报错</li>\n    <li>鼠标坐标判定错误</li>\n    <li>滚动条渲染错误</li>\n    <li>按钮文字渲染错误</li>\n    <li>GL设置错误引起的图像绘制异常</li>\n</ul>\n\n<h2 id=\"96-新的鼠标事件触发方式\"><a href=\"#96-新的鼠标事件触发方式\" class=\"headerlink\" title=\"#96.新的鼠标事件触发方式\"></a>#96.新的鼠标事件触发方式</h2><p>&emsp;&emsp;老旧的触发方式已经无法满足新式GUI设计的功能需求，故改用新的鼠标事件触发方式。</p>\n<p>&emsp;&emsp;旧触发方式采用：<code>开始触发事件</code> -&gt; <code>扫描控件</code> -&gt; <code>触发指定控件的事件</code>。</p>\n<p>&emsp;&emsp;新触发方式采用：<code>开始触发事件</code> -&gt; <code>分配任务至控件组</code> -&gt; <code>控件组扫描并触发事件</code>。</p>\n<h2 id=\"97-修复新的事件触发方式带来的漏洞\"><a href=\"#97-修复新的事件触发方式带来的漏洞\" class=\"headerlink\" title=\"#97.修复新的事件触发方式带来的漏洞\"></a>#97.修复新的事件触发方式带来的漏洞</h2><ul>\n    <li>鼠标事件无法触发</li>\n    <li>触发鼠标事件过程中坐标发生偏移</li>\n    <li>鼠标事件对象判断失误的漏洞</li>\n    <li>全局鼠标按键当鼠标在控件外时无法触发</li>\n    <li>鼠标离开事件判定错误</li>\n</ul>\n\n\n\n\n\n<hr>\n<h1 id=\"历史记录：\"><a href=\"#历史记录：\" class=\"headerlink\" title=\"历史记录：\"></a>历史记录：</h1><h2 id=\"1-项目的起点\"><a href=\"#1-项目的起点\" class=\"headerlink\" title=\"#1 项目的起点\"></a>#1 项目的起点</h2><p>&emsp;&emsp;建立现代工业（ModernIndustry）项目，并建立主类以及完成最为基础的架设，此时MI没有任何代码层面及用户层面的功能。</p>\n<h2 id=\"2-建立电力体系\"><a href=\"#2-建立电力体系\" class=\"headerlink\" title=\"#2 建立电力体系\"></a>#2 建立电力体系</h2><p>&emsp;&emsp;简单建立电力系统中的基础概念：发电机、用电器、导线。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"right\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>发电机</strong></td>\n<td align=\"right\">制造能量的机器全部归类于发电机</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>用电器</strong></td>\n<td align=\"right\">消耗能量的机器全部归类与用电器</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>导线</strong></td>\n<td align=\"right\">因为导线采用了和机器不同的算法，所以导线单独分类，用于传输能量</td>\n</tr>\n<tr>\n<td align=\"center\">补充</td>\n<td align=\"right\">储电器同时属于发电机与用电器分类，不属于导线</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-一切的开端—第一个电器\"><a href=\"#3-一切的开端—第一个电器\" class=\"headerlink\" title=\"#3 一切的开端—第一个电器\"></a>#3 一切的开端—第一个电器</h2><p>&emsp;&emsp;创建了MI中的第一个机器——压缩机，不过其在电力系统完工之前不需要电能就可以运行，前期主要用于测试代码功能，在电力系统制作时为其添加了消耗电能的功能。</p>\n<h2 id=\"4-构建电力系统的基本框架\"><a href=\"#4-构建电力系统的基本框架\" class=\"headerlink\" title=\"#4 构建电力系统的基本框架\"></a>#4 构建电力系统的基本框架</h2><p>&emsp;&emsp;构建了电力系统的基本内容与规范，包括：电能概念、电压概念、EleWorker……</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"right\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">电能</td>\n<td align=\"right\">用于表示能量数量的一个指示数字</td>\n</tr>\n<tr>\n<td align=\"center\">电压</td>\n<td align=\"right\">用于表示电压等级的一个指示数字，理论上支持所有非负整数，电压与电能无直接联系</td>\n</tr>\n<tr>\n<td align=\"center\">EleWorker</td>\n<td align=\"right\">电力系统的“工作核心”，系统的所有操作都封装在该类中</td>\n</tr>\n<tr>\n<td align=\"center\">计数器</td>\n<td align=\"right\">用于在用电器输入电压不符合需求电压时计数并在计数器达到阈值时执行指令的工具</td>\n</tr>\n<tr>\n<td align=\"center\">线路缓存</td>\n<td align=\"right\">用于存储线路计算的缓存信息，以此减少线路计算的时间和成本（可以选择不实现缓存功能）</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-第一个导线\"><a href=\"#5-第一个导线\" class=\"headerlink\" title=\"#5 第一个导线\"></a>#5 第一个导线</h2><p>&emsp;&emsp;创建了MI中的第一种导线——粗制导线，也是开发前期阶段唯一可用的导线。导线中实现了信息存储、渲染、缓存三大功能，而线路计算则写入了缓存中。</p>\n<h3 id=\"线路计算原理：\"><a href=\"#线路计算原理：\" class=\"headerlink\" title=\"线路计算原理：\"></a>线路计算原理：</h3><p>&emsp;&emsp;在线路计算中，包含三大流程：寻找线路、计算线路、反馈信息。</p>\n<p>&emsp;&emsp;其中前两个流程可以用等价的方法替换，顺序也可以调整，但反馈信息必须在最后进行。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"right\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>寻找线路</strong></td>\n<td align=\"right\">寻找指定用电器到非指定发电机的路径</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>计算线路</strong></td>\n<td align=\"right\">计算线路上损耗的电能及发电机最终输出的电能和电压</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>反馈信息</strong></td>\n<td align=\"right\">向电力系统反馈计算结果，系统将根据结果进行数据更新</td>\n</tr>\n<tr>\n<td align=\"center\">路径</td>\n<td align=\"right\">表示线路中指定起点到指定终点经过的所有导线方块，包含起点与终点，不包含机器方块</td>\n</tr>\n<tr>\n<td align=\"center\">非指定发电机</td>\n<td align=\"right\">MI采用被动式电能运输，所以寻找线路时一般并不知道目标发电机的位置</td>\n</tr>\n<tr>\n<td align=\"center\">被动式电能运输</td>\n<td align=\"right\">用电器主动向电力系统发起传输电能的请求，然后由电力系统负责完成其余工作</td>\n</tr>\n</tbody></table>\n<p>&emsp;&emsp;不过MI中的粗制导线没有完全按照上述方法进行，而是按照：<code>读取缓存 -&gt; 计算线路 -&gt; 反馈信息</code>的流程工作。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"right\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>读取缓存</strong></td>\n<td align=\"right\">从发电机列表中直接寻找目标发电机，然后读取缓存</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>计算线路</strong></td>\n<td align=\"right\">若缓存不存在则计算起点到终点的最短路径并写入缓存</td>\n</tr>\n<tr>\n<td align=\"center\">发电机列表</td>\n<td align=\"right\">一条线路中所有导线共享同一个缓存，每一根导线都负责维护缓存中的发电机列表</td>\n</tr>\n</tbody></table>\n<p>&emsp;&emsp;上述列出的第一种方式为粗制导线最初使用的工作流程，后因为技术原因替换为第二种。</p>\n<h2 id=\"6-发电机的出现\"><a href=\"#6-发电机的出现\" class=\"headerlink\" title=\"#6 发电机的出现\"></a>#6 发电机的出现</h2><p>&emsp;&emsp;添加了第一个发电机方块——无线电能方块，用于测试电力系统是否可以正常工作，也用于给玩家提供一个万能的创造模式用发电机。</p>\n<h2 id=\"7-完善电力系统框架\"><a href=\"#7-完善电力系统框架\" class=\"headerlink\" title=\"#7 完善电力系统框架\"></a>#7 完善电力系统框架</h2><p>&emsp;&emsp;这是对电力系统第N次重构，完善了电力系统的功能，删除了不需要的部分。从该版本起，缓存彻底被排除在电力系统规范外，是否实现缓存与电力系统工作没有任何关系。</p>\n<h2 id=\"8-合成表模块的第一次开发\"><a href=\"#8-合成表模块的第一次开发\" class=\"headerlink\" title=\"#8 合成表模块的第一次开发\"></a>#8 合成表模块的第一次开发</h2><p>&emsp;&emsp;原版的合成表本人并不会使用，所以干脆写了一个独立的合成表模块，其中所有内容都是可变的，拓展性较强，但存在结构混乱的缺陷。</p>\n<h2 id=\"9-加入自动化概念\"><a href=\"#9-加入自动化概念\" class=\"headerlink\" title=\"#9 加入自动化概念\"></a>#9 加入自动化概念</h2><p>&emsp;&emsp;建立了<code>registry</code>包，用于自动化注册方块、物品等内容，摆脱手动编码的烦恼。</p>\n<h2 id=\"10-自动化的推进\"><a href=\"#10-自动化的推进\" class=\"headerlink\" title=\"#10 自动化的推进\"></a>#10 自动化的推进</h2><p>&emsp;&emsp;除方块、物品的自动化注册外，又新提供了部分内容，此时自动化系统变得较为完善，包括以下内容：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"right\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>方块、物品、TileEntity的注册</strong></td>\n<td align=\"right\">基本游戏内容</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>网络通讯</strong></td>\n<td align=\"right\">封装了网络通讯相关的代码，使服务端与客户端的沟通更加简便</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>数据存储</strong></td>\n<td align=\"right\">支持部分数据类型的自动存储，拜托手动编码的烦恼，不过目前仍存在一些限制</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>GUI绘制</strong></td>\n<td align=\"right\">支持运行时绘制GUI材质，拜托手动绘制材质及寻找组件坐标的烦恼</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>JSON生成</strong></td>\n<td align=\"right\">自动生成方块、物品的JSON文件</td>\n</tr>\n</tbody></table>\n<h2 id=\"11-BUG修复\"><a href=\"#11-BUG修复\" class=\"headerlink\" title=\"#11 BUG修复\"></a>#11 BUG修复</h2><p>&emsp;&emsp;修复部分BUG。</p>\n<h2 id=\"12-GUI绘制\"><a href=\"#12-GUI绘制\" class=\"headerlink\" title=\"#12 GUI绘制\"></a>#12 GUI绘制</h2><p>&emsp;&emsp;完善GUI绘制的功能。</p>\n<h2 id=\"13-新的功能——属性\"><a href=\"#13-新的功能——属性\" class=\"headerlink\" title=\"#13 新的功能——属性\"></a>#13 新的功能——属性</h2><p>&emsp;&emsp;在工具使用时提供额外效果的玩意，有点类似于附魔。</p>\n<h2 id=\"14-工具类\"><a href=\"#14-工具类\" class=\"headerlink\" title=\"#14 工具类\"></a>#14 工具类</h2><p>&emsp;&emsp;提供了一系列<code>Util</code>类，封装了一些常用操作，缩减了代码量。</p>\n<h2 id=\"15-时刻表\"><a href=\"#15-时刻表\" class=\"headerlink\" title=\"#15 时刻表\"></a>#15 时刻表</h2><p>&emsp;&emsp;用于在指定时间后执行指定操作，因为某些功能限制，在<code>#38</code>时被移除。</p>\n<h2 id=\"16-添加一系列物品及机器\"><a href=\"#16-添加一系列物品及机器\" class=\"headerlink\" title=\"#16 添加一系列物品及机器\"></a>#16 添加一系列物品及机器</h2><h2 id=\"17-GUI绘制的完善\"><a href=\"#17-GUI绘制的完善\" class=\"headerlink\" title=\"#17 GUI绘制的完善\"></a>#17 GUI绘制的完善</h2><p>&emsp;&emsp;解决了GUI绘制坐标点寻找烧脑的问题，彻底摆脱思考，同时优化了性能。</p>\n<h2 id=\"18-重写合成表模块\"><a href=\"#18-重写合成表模块\" class=\"headerlink\" title=\"#18 重写合成表模块\"></a>#18 重写合成表模块</h2><p>&emsp;&emsp;因为合成表模块结构过于混乱，没有任何易用性及美观性，所以重新设计、编写了合成表模块：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"right\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>CraftGuide&lt;T, R&gt;</code></td>\n<td align=\"right\">创建、管理合成表，数据可变</td>\n</tr>\n<tr>\n<td align=\"center\"><code>ItemSol</code></td>\n<td align=\"right\">存储物品列表，可有序可无序，数据不可变</td>\n</tr>\n<tr>\n<td align=\"center\"><code>ItemElement</code></td>\n<td align=\"right\">存储单个物品，数据不可变</td>\n</tr>\n<tr>\n<td align=\"center\"><code>IShape</code></td>\n<td align=\"right\">合成表，内部存储原料列表和产物列表，可有序可无序，数据不可变</td>\n</tr>\n</tbody></table>\n<h2 id=\"19-修复线路计算中的问题\"><a href=\"#19-修复线路计算中的问题\" class=\"headerlink\" title=\"#19 修复线路计算中的问题\"></a>#19 修复线路计算中的问题</h2><p>&emsp;&emsp;将线路计算方式换为<code>#5</code>中的第二种方式。</p>\n<h2 id=\"24-优化自动数据存储\"><a href=\"#24-优化自动数据存储\" class=\"headerlink\" title=\"#24 优化自动数据存储\"></a>#24 优化自动数据存储</h2><p>&emsp;&emsp;减少了存储类名需要的成本</p>\n<h2 id=\"34-优化扳手的玩法\"><a href=\"#34-优化扳手的玩法\" class=\"headerlink\" title=\"#34 优化扳手的玩法\"></a>#34 优化扳手的玩法</h2><p>&emsp;&emsp;扳手玩法改为右键不同区域转向不同的方向，<code>shift + 右键</code>拆除方块，暂时没有耐久。</p>\n<h2 id=\"35-完善自动注册的功能\"><a href=\"#35-完善自动注册的功能\" class=\"headerlink\" title=\"#35 完善自动注册的功能\"></a>#35 完善自动注册的功能</h2><p>&emsp;&emsp;使自动注册支持对物品、方块列表进行排序，保证在每次创建存档时创造模式物品栏中的排列顺序不变化。</p>\n<h2 id=\"36-第一次材质扩充\"><a href=\"#36-第一次材质扩充\" class=\"headerlink\" title=\"#36 第一次材质扩充\"></a>#36 第一次材质扩充</h2><h2 id=\"37-增强合成表模块\"><a href=\"#37-增强合成表模块\" class=\"headerlink\" title=\"#37 增强合成表模块\"></a>#37 增强合成表模块</h2><p>&emsp;&emsp;修改了MC原版注册JSON合成表的方法，在其中加入了注册MI的JSON合成表的代码，自此注册合成表可以不再面对繁杂的代码编写。</p>\n<h2 id=\"38-修复服务端支持\"><a href=\"#38-修复服务端支持\" class=\"headerlink\" title=\"#38 修复服务端支持\"></a>#38 修复服务端支持</h2><p>&emsp;&emsp;修复因代码问题导致的服务端启动崩溃。</p>\n<h2 id=\"39-GUI添加鼠标事件\"><a href=\"#39-GUI添加鼠标事件\" class=\"headerlink\" title=\"#39 GUI添加鼠标事件\"></a>#39 GUI添加鼠标事件</h2><p>&emsp;&emsp;GUI支持鼠标事件，在鼠标移出、移入、按下、松开或点击控件时会自动调用控件的方法（前提是控件注册了相关事件）。一个控件可以重复注册同一种事件，在事件被触发时所有相同事件都会被触发，不会被遗漏。</p>\n<h2 id=\"40-优化自动化网络传输结构\"><a href=\"#40-优化自动化网络传输结构\" class=\"headerlink\" title=\"#40 优化自动化网络传输结构\"></a>#40 优化自动化网络传输结构</h2><p>&emsp;&emsp;自动化网络传输采用“注册”结构，添加新的网络传输方式变得更加方便。同时网络传输不再主动询问用户是否需要发送信息，更加偏向半自动化，采用用户主动向网络传输系统发送请求的方式，减少了运行开支。</p>\n<h2 id=\"41-添加合成表显示\"><a href=\"#41-添加合成表显示\" class=\"headerlink\" title=\"#41.添加合成表显示\"></a>#41.添加合成表显示</h2><p>&emsp;&emsp;预期设计是点击机器的进度条可以查看该机器所有的合成表，不过目前由于网络通信的原因还未添加触发合成表显示的机制。以后还会为合成表添加更多的功能，例如：自动装填。</p>\n<h2 id=\"42-修复导线网络通信漏洞\"><a href=\"#42-修复导线网络通信漏洞\" class=\"headerlink\" title=\"#42.修复导线网络通信漏洞\"></a>#42.修复导线网络通信漏洞</h2><p>&emsp;&emsp;修复导线的网络通信中由于IDEA“重命名”功能的BUG出现的一些神奇的代码。</p>\n<h2 id=\"43-网络通信新功能——GUI通信\"><a href=\"#43-网络通信新功能——GUI通信\" class=\"headerlink\" title=\"#43.网络通信新功能——GUI通信\"></a>#43.网络通信新功能——GUI通信</h2><p>&emsp;&emsp;网络通信支持客户端与服务端GUI之间的互相通信。</p>\n<h2 id=\"44-GUI支持事件进行网络通信\"><a href=\"#44-GUI支持事件进行网络通信\" class=\"headerlink\" title=\"#44.GUI支持事件进行网络通信\"></a>#44.GUI支持事件进行网络通信</h2><p>&emsp;&emsp;MIFrame添加了用于支持注册的事件进行网路单向通信的接口，由于一些设计缺陷以及考虑到代码简洁性的原因，事件的网络通信暂时只支持客户端到服务端的通信（即只能由客户端发送信息到服务端）。</p>\n<h2 id=\"45-修复GUI根据鼠标坐标获取组件错误的问题\"><a href=\"#45-修复GUI根据鼠标坐标获取组件错误的问题\" class=\"headerlink\" title=\"#45-修复GUI根据鼠标坐标获取组件错误的问题\"></a>#45-修复GUI根据鼠标坐标获取组件错误的问题</h2><p>&emsp;&emsp;原本获取组件的算法有问题，这次修改了算法。</p>\n<h2 id=\"46-修复Group内添加的组件鼠标事件错误的问题\"><a href=\"#46-修复Group内添加的组件鼠标事件错误的问题\" class=\"headerlink\" title=\"#46-修复Group内添加的组件鼠标事件错误的问题\"></a>#46-修复Group内添加的组件鼠标事件错误的问题</h2><p>&emsp;&emsp;原本的事件触发方式导致<code>Group</code>内的鼠标事件无法触发，这次修改了触发方式，使<code>Group</code>内组件的鼠标事件也可以正确触发。</p>\n<h2 id=\"47-修复GUI按钮响应错误的问题\"><a href=\"#47-修复GUI按钮响应错误的问题\" class=\"headerlink\" title=\"#47-修复GUI按钮响应错误的问题\"></a>#47-修复GUI按钮响应错误的问题</h2><p>&emsp;&emsp;修复GUI按钮鼠标事件的错误响应，以及为鼠标点击添加了音效。</p>\n<h2 id=\"48-修复GUI组件onAddToGUI方法运行两次\"><a href=\"#48-修复GUI组件onAddToGUI方法运行两次\" class=\"headerlink\" title=\"#48-修复GUI组件onAddToGUI方法运行两次\"></a>#48-修复GUI组件onAddToGUI方法运行两次</h2><p>&emsp;&emsp;<code>StaticFrameClient</code>构造函数中的错误用法导致客户端<code>onAddToGUI</code>运行两次。</p>\n<h2 id=\"49-修复Group的错误算法\"><a href=\"#49-修复Group的错误算法\" class=\"headerlink\" title=\"#49.修复Group的错误算法\"></a>#49.修复Group的错误算法</h2><p>&emsp;&emsp;<code>Group</code>类获取鼠标指向的组件时没有调用组件的判断方法直接返回了组件，导致判断结果异常。</p>\n<h2 id=\"50-添加合成表按钮\"><a href=\"#50-添加合成表按钮\" class=\"headerlink\" title=\"#50.添加合成表按钮\"></a>#50.添加合成表按钮</h2><p>&emsp;&emsp;添加了隐形的合成表按钮，支持全自动调整坐标和尺寸。部分功能依赖<code>MComponent</code>执行，所以从该版本开始要求<code>MComponent</code>的子类重写<code>onAddToGUI</code>方法时必须调用父类对应的方法。</p>\n<h2 id=\"49-修复Group的错误算法-1\"><a href=\"#49-修复Group的错误算法-1\" class=\"headerlink\" title=\"#49-修复Group的错误算法\"></a>#49-修复Group的错误算法</h2><p>&emsp;&emsp;<code>Group</code>类获取鼠标指向的组件时没有调用组件的判断方法直接返回了组件，导致判断结果异常。</p>\n<h2 id=\"50-添加合成表按钮-1\"><a href=\"#50-添加合成表按钮-1\" class=\"headerlink\" title=\"#50.添加合成表按钮\"></a>#50.添加合成表按钮</h2><p>&emsp;&emsp;添加了隐形的合成表按钮，支持全自动调整坐标和尺寸。部分功能依赖<code>MComponent</code>执行，所以从该版本开始要求<code>MComponent</code>的子类重写<code>onAddToGUI</code>方法时必须调用父类对应的方法。</p>\n<h2 id=\"51-添加对已有所有合成表类型的显示支持\"><a href=\"#51-添加对已有所有合成表类型的显示支持\" class=\"headerlink\" title=\"#51-添加对已有所有合成表类型的显示支持\"></a>#51-添加对已有所有合成表类型的显示支持</h2><p>&emsp;&emsp;自动合成表显示目前已经支持对已有四种类型的合成表进行显示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">合成表类型</th>\n<th align=\"right\">特点介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>OrderlyShapeOnly</code></td>\n<td align=\"right\">原料列表有序，产物仅有一种</td>\n</tr>\n<tr>\n<td align=\"center\"><code>UnorderlyShapeOnly</code></td>\n<td align=\"right\">原料列表无序，产物仅有一种</td>\n</tr>\n<tr>\n<td align=\"center\"><code>OrderlyShape</code></td>\n<td align=\"right\">原料列表有序，产物有多种（无序）</td>\n</tr>\n<tr>\n<td align=\"center\"><code>UnorderlyShape</code></td>\n<td align=\"right\">原料列表无序，产物有多种（无序）</td>\n</tr>\n</tbody></table>\n<div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#66ccff\">注：原料列表有序即相当于有序合成表，无序则为无序合成表</font></div>\n\n<h2 id=\"52-修复打开空的合成表时游戏崩溃\"><a href=\"#52-修复打开空的合成表时游戏崩溃\" class=\"headerlink\" title=\"#52-修复打开空的合成表时游戏崩溃\"></a>#52-修复打开空的合成表时游戏崩溃</h2><p>&emsp;&emsp;修复打开空的合成表时抛出<code>IndexOutOfBoundException</code>及<code>IllegalArgumentException</code>导致的程序崩溃。</p>\n<h2 id=\"53-修复GUI网络通信时客户端服务端窗体对象可能不一致的漏洞\"><a href=\"#53-修复GUI网络通信时客户端服务端窗体对象可能不一致的漏洞\" class=\"headerlink\" title=\"#53.修复GUI网络通信时客户端服务端窗体对象可能不一致的漏洞\"></a>#53.修复GUI网络通信时客户端服务端窗体对象可能不一致的漏洞</h2><p>&emsp;&emsp;以往GUI进行网络通信时，通信内容中并没有存储发送信息的GUI的窗体信息，导致接收端无法判断窗体是否一致，该更新在通讯信息中加入了GUI窗体校验信息，辅助信息正确性校验。</p>\n<h2 id=\"54-修复点击合成表按钮响应多次的BUG\"><a href=\"#54-修复点击合成表按钮响应多次的BUG\" class=\"headerlink\" title=\"#54.修复点击合成表按钮响应多次的BUG\"></a>#54.修复点击合成表按钮响应多次的BUG</h2><p>&emsp;&emsp;以往按钮注册事件的代码位置错误，导致同一个事件被多次注册，从而使按钮响应多次，该更新修改了注册机制，添加了专门的初始化接口，修正了该BUG。</p>\n<h2 id=\"55-添加配置功能\"><a href=\"#55-添加配置功能\" class=\"headerlink\" title=\"#55.添加配置功能\"></a>#55.添加配置功能</h2><p>&emsp;&emsp;支持简单的配置功能，预备后续重新写一遍更高级的。</p>\n<h2 id=\"56-重写方块JSON生成器\"><a href=\"#56-重写方块JSON生成器\" class=\"headerlink\" title=\"#56.重写方块JSON生成器\"></a>#56.重写方块JSON生成器</h2><p>&emsp;&emsp;重写了<code>BlockJsonBuilder</code>类，提供了更加高级的功能，支持多种方块的JSON生成，同时支持快捷的模板添加。</p>\n<h2 id=\"57-GUI显示调整\"><a href=\"#57-GUI显示调整\" class=\"headerlink\" title=\"#57.GUI显示调整\"></a>#57.GUI显示调整</h2><p>&emsp;&emsp;GUI中玩家背包上方添加“物品栏”文字。</p>\n<h2 id=\"58-修复自动读写崩溃问题\"><a href=\"#58-修复自动读写崩溃问题\" class=\"headerlink\" title=\"#58.修复自动读写崩溃问题\"></a>#58.修复自动读写崩溃问题</h2><p>&emsp;&emsp;当需要存储的值为<code>null</code>时会导致存储失败并放弃剩余数据，该问题出现的原因是大部分情况下客户端的TE中并没有存储有效数据。解决方案：客户端不再触发自动读写。</p>\n<h2 id=\"59-实现本地GUI渲染\"><a href=\"#59-实现本地GUI渲染\" class=\"headerlink\" title=\"#59.实现本地GUI渲染\"></a>#59.实现本地GUI渲染</h2><p>&emsp;&emsp;实现了本地子GUI渲染，允许玩家在已打开的GUI上再打开一个GUI。打开子GUI时会拦截原GUI的所有操作，当玩家尝试关闭GUI时只会关闭子GUI，而原GUI保持开启。</p>\n<h2 id=\"60-实现以玩家为凭借的双端通信\"><a href=\"#60-实现以玩家为凭借的双端通信\" class=\"headerlink\" title=\"#60.实现以玩家为凭借的双端通信\"></a>#60.实现以玩家为凭借的双端通信</h2><p>&emsp;&emsp;允许以玩家为<code>KEY</code>进行服务端客户端双端通信，为保持安全以<code>UUID</code>为凭借。</p>\n<h2 id=\"61-修复服务端SideOnly问题\"><a href=\"#61-修复服务端SideOnly问题\" class=\"headerlink\" title=\"#61.修复服务端SideOnly问题\"></a>#61.修复服务端SideOnly问题</h2><p>&emsp;&emsp;修复因<code>SideOnly(CLIENT)</code>导致的服务端BUG。</p>\n<h2 id=\"62-修复两端数据不一致导致的BUG\"><a href=\"#62-修复两端数据不一致导致的BUG\" class=\"headerlink\" title=\"#62.修复两端数据不一致导致的BUG\"></a>#62.修复两端数据不一致导致的BUG</h2><p>&emsp;&emsp;修复因客户端与服务端<code>网络注册ID</code>和<code>GUI ID</code>不一致导致的问题。</p>\n<h2 id=\"63-修复GUI渲染问题\"><a href=\"#63-修复GUI渲染问题\" class=\"headerlink\" title=\"#63.修复GUI渲染问题\"></a>#63.修复GUI渲染问题</h2><p>&emsp;&emsp;修复当传入数据为负值时导致的<code>CommonProgress</code>渲染异常。</p>\n<h2 id=\"64-字节层次的数据操作——dor\"><a href=\"#64-字节层次的数据操作——dor\" class=\"headerlink\" title=\"#64.字节层次的数据操作——dor\"></a>#64.字节层次的数据操作——dor</h2><p>&emsp;&emsp;添加了自制的数据操作库<code>dor</code>，主要由<code>IDataReader</code>(读取器)和<code>IDataWriter</code>(写入器)组成。同时提供了两个默认实现：支持读写的<code>ByteDataOperator</code>以及只读的<code>ReadOnlyDataOperator</code>。</p>\n<h2 id=\"65-新的数据读写系统\"><a href=\"#65-新的数据读写系统\" class=\"headerlink\" title=\"#65.新的数据读写系统\"></a>#65.新的数据读写系统</h2><p>&emsp;&emsp;编写全新的数据读写系统，除原本的<code>NBTTagCompound</code>支持外，新加了对<code>ByteBuf</code>及自制的<code>dor</code>的支持。</p>\n<h2 id=\"66-新的自动数据读写\"><a href=\"#66-新的自动数据读写\" class=\"headerlink\" title=\"#66.新的自动数据读写\"></a>#66.新的自动数据读写</h2><p>&emsp;&emsp;依靠新的数据读写系统编写了全新的自动化数据读写库，运行主要依靠<code>IClassData</code>，实现了对数据的自动存储，同时支持数据类型转换。</p>\n<h2 id=\"67-完善合成表自动填充的功能\"><a href=\"#67-完善合成表自动填充的功能\" class=\"headerlink\" title=\"#67.完善合成表自动填充的功能\"></a>#67.完善合成表自动填充的功能</h2><p>&emsp;&emsp;修复了合成表填充时存在的所有已知BUG，优化合成表显示。</p>\n<h2 id=\"68-网络通信换用dor系统\"><a href=\"#68-网络通信换用dor系统\" class=\"headerlink\" title=\"#68.网络通信换用dor系统\"></a>#68.网络通信换用dor系统</h2><p>&emsp;&emsp;自动化网络通信全面抛弃<code>NBTTagCompound</code>，使用<code>dor</code>读写系统。</p>\n<h2 id=\"69-修复dor漏洞及优化功能\"><a href=\"#69-修复dor漏洞及优化功能\" class=\"headerlink\" title=\"#69.修复dor漏洞及优化功能\"></a>#69.修复dor漏洞及优化功能</h2><ul>\n    <li>修复读写数据时下标错误的更新</li>\n    <li>修复读写占用多字节的数据时的错误移位操作</li>\n    <li>修复读写varint时的错误移位操作</li>\n    <li>优化不合理的写入顺序</li>\n</ul>\n## #70.移除“属性”功能\n\n<p>&emsp;&emsp;由于<code>属性</code>功能与附魔玩法重复并且存在漏洞，所以决定将该功能删除。</p>\n<h2 id=\"71-添加虚拟dor\"><a href=\"#71-添加虚拟dor\" class=\"headerlink\" title=\"#71.添加虚拟dor\"></a>#71.添加虚拟dor</h2><p>&emsp;&emsp;添加了<code>VarDataReader</code>类，用于在不复制任何数据的情况下进行<code>data</code>读取，优化了<code>IDataReader#readData()</code>的时间成本及空间成本。</p>\n<h2 id=\"72-修复自动化网络通信的BUG\"><a href=\"#72-修复自动化网络通信的BUG\" class=\"headerlink\" title=\"#72.修复自动化网络通信的BUG\"></a>#72.修复自动化网络通信的BUG</h2><p>&emsp;&emsp;修复基于方块的网络通信中可能存在的进行网络通信时客户端世界未构造完毕的BUG。</p>\n<h2 id=\"73-修复合成表填充显示异常\"><a href=\"#73-修复合成表填充显示异常\" class=\"headerlink\" title=\"#73.修复合成表填充显示异常\"></a>#73.修复合成表填充显示异常</h2><p>&emsp;&emsp;修复合成表填充后GUI显示异常，通过在填充合成表后代码触发数据同步来更新GUI显示。</p>\n<h2 id=\"74-支持自动注册流体\"><a href=\"#74-支持自动注册流体\" class=\"headerlink\" title=\"#74.支持自动注册流体\"></a>#74.支持自动注册流体</h2><p>&emsp;&emsp;支持自动注册流体、流体物品、流体方块及流体桶。</p>\n<h2 id=\"75-自动注册系统改用注册机制\"><a href=\"#75-自动注册系统改用注册机制\" class=\"headerlink\" title=\"#75.自动注册系统改用注册机制\"></a>#75.自动注册系统改用注册机制</h2><p>&emsp;&emsp;自动注册系统换用注册机制添加注册类型，拓展性更强。</p>\n<h2 id=\"76-修复一些小漏洞\"><a href=\"#76-修复一些小漏洞\" class=\"headerlink\" title=\"#76.修复一些小漏洞\"></a>#76.修复一些小漏洞</h2><ul>\n    <li>生成本地名称时将\".\"误写为\":\"\n    </li><li>矿石生成器注册异常\n    </li><li>Mixin编译报错\n    </li><li>新版自动注册不调用排序方法\n    </li><li>某些注册机错误处理本地名称\n    </li><li>Json生成器对key的错误处理\n</li></ul>\n\n\n<h2 id=\"77-完善组件\"><a href=\"#77-完善组件\" class=\"headerlink\" title=\"#77.完善组件\"></a>#77.完善组件</h2><ul>\n    <li>补充GUI材质\n    </li><li>扩充字典内容\n    </li><li>完善语言文件（中文简体）\n</li></ul>\n\n\n<h2 id=\"78-添加流体管道的接口\"><a href=\"#78-添加流体管道的接口\" class=\"headerlink\" title=\"#78.添加流体管道的接口\"></a>#78.添加流体管道的接口</h2><p>&emsp;&emsp;添加了流体管道需要用到的接口（可能不全，后续调整），大致确定了流体管道工作方式。</p>\n<h2 id=\"79-添加流体管道的TileEntity的默认实现\"><a href=\"#79-添加流体管道的TileEntity的默认实现\" class=\"headerlink\" title=\"#79.添加流体管道的TileEntity的默认实现\"></a>#79.添加流体管道的TileEntity的默认实现</h2><p>&emsp;&emsp;默认的<code>TIleEntity</code>实现了对管道需要用到的数据的底层管理，包括渲染数据、连接数据、存储数据等。</p>\n<h2 id=\"80-GUI自动绘制添加更多的事件\"><a href=\"#80-GUI自动绘制添加更多的事件\" class=\"headerlink\" title=\"#80.GUI自动绘制添加更多的事件\"></a>#80.GUI自动绘制添加更多的事件</h2><p>&emsp;&emsp;GUI自动绘制添加了<code>MouseLocationListener</code>事件，该事件每Tick在组件绘制前被触发，用于记录鼠标坐标的更改。同时还修改了部分GUI鼠标事件的触发方式，让事件功能更加强大。</p>\n<h2 id=\"81-GUI添加滚动条控件\"><a href=\"#81-GUI添加滚动条控件\" class=\"headerlink\" title=\"#81.GUI添加滚动条控件\"></a>#81.GUI添加滚动条控件</h2><p>&emsp;&emsp;向自动化GUI系统添加滚动条控件，效果与创造模式背包右侧的滚动条类似。</p>\n<h2 id=\"82-GUI添加更多事件\"><a href=\"#82-GUI添加更多事件\" class=\"headerlink\" title=\"#82.GUI添加更多事件\"></a>#82.GUI添加更多事件</h2><p>&emsp;&emsp;支持控件监视键盘事件（包括按下和释放）以及鼠标滚轮滑动事件。</p>\n<h2 id=\"83-添加类信息查看器\"><a href=\"#83-添加类信息查看器\" class=\"headerlink\" title=\"#83.添加类信息查看器\"></a>#83.添加类信息查看器</h2><p>&emsp;&emsp;添加类信息查看器，右键方块即可查看方块<code>TileEntity</code>中存储的信息。该物品是为了取代老旧的线缆信息查看器，故同时删除了线缆信息查看器。</p>\n<h2 id=\"84-优化和完善自动化数据存储\"><a href=\"#84-优化和完善自动化数据存储\" class=\"headerlink\" title=\"#84.优化和完善自动化数据存储\"></a>#84.优化和完善自动化数据存储</h2><ul>\n    <li>优化对枚举类的存储，占用更少的空间</li>\n    <li>自动化数据存储类型转换默认支持到字符串的转换</li>\n    <li>已有的类型添加更完善的类型转换功能</li>\n</ul>\n\n\n<h2 id=\"85-修复并优化管道的部分功能\"><a href=\"#85-修复并优化管道的部分功能\" class=\"headerlink\" title=\"#85.修复并优化管道的部分功能\"></a>#85.修复并优化管道的部分功能</h2><ul>\n    <li><b>修复：</b>放置时不自动连接周围方块</li>\n    <li><b>修复：</b>数据读取时报错导致无法正确恢复存档内容</li>\n    <li><b>修复：</b>管道放置时朝向数据客户端服务端计算结果不一致</li>\n    <li><b>修复：</b>管道输出流体到世界后流体不会流动</li>\n    <li><b>优化：</b>移除多余的数据</li>\n    <li><b>优化：</b>细化碰撞箱</li>\n    <li><b>优化：</b>管道放置时的朝向判断</li>\n    <li><b>优化：</b>管道的网络资源占用</li>\n    <li><b>添加：</b>支持添加管塞</li>\n\n\n</ul>\n\n<h2 id=\"86-修复功能优化带来的漏洞\"><a href=\"#86-修复功能优化带来的漏洞\" class=\"headerlink\" title=\"#86.修复功能优化带来的漏洞\"></a>#86.修复功能优化带来的漏洞</h2><ul>\n    <li>导线无法正常连接周围方块</li>\n    <li>机器无法正常从导线获取能量</li>\n</ul>\n\n\n<h2 id=\"87-优化包-类结构\"><a href=\"#87-优化包-类结构\" class=\"headerlink\" title=\"#87.优化包/类结构\"></a>#87.优化包/类结构</h2><p>&emsp;&emsp;将<code>BlockUtil</code>合并到<code>WorldUtil</code>中，修改部分包名，修改部分包的包含结构。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"}]}]}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>&emsp;&emsp;这里讲罗列出“现代工业”所有的更新记录以及更新内容的介绍。</p>\n<p>&emsp;&emsp;目前所有更新日志代号均以“#”开头，以后可能会有变更。</p>\n<p>&emsp;&emsp;关于项目的有关内容，可以查看“<a href=\"https://afdian.net/@emptydreams\">爱发电</a>”中的介绍。</p>\n<hr>\n<h1 id=\"功能开发顺序\"><a href=\"#功能开发顺序\" class=\"headerlink\" title=\"功能开发顺序\"></a>功能开发顺序</h1><div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#66ccff\">（顺序由内测组投票决定）</font></div>\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">序号</th>\n<th align=\"center\">功能</th>\n<th align=\"center\">难度</th>\n<th align=\"center\">进度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>1</strong></td>\n<td align=\"center\">更舒适的合成表查看</td>\n<td align=\"center\">3</td>\n<td align=\"center\">完成</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>2</strong></td>\n<td align=\"center\">管道系统</td>\n<td align=\"center\">5</td>\n<td align=\"center\">编写中</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>3</strong></td>\n<td align=\"center\">高级配置系统</td>\n<td align=\"center\">2</td>\n<td align=\"center\">待机</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>4</strong></td>\n<td align=\"center\">红石能衰退</td>\n<td align=\"center\">?</td>\n<td align=\"center\">待机</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>5</strong></td>\n<td align=\"center\">储能器</td>\n<td align=\"center\">3</td>\n<td align=\"center\">待机</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>6</strong></td>\n<td align=\"center\">完整的金属冶炼</td>\n<td align=\"center\">4</td>\n<td align=\"center\">待机</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>7</strong></td>\n<td align=\"center\">精制工具</td>\n<td align=\"center\">4</td>\n<td align=\"center\">待机</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>8</strong></td>\n<td align=\"center\">更多的电器</td>\n<td align=\"center\">3</td>\n<td align=\"center\">待机</td>\n</tr>\n</tbody></table>\n<hr>\n<h1 id=\"新的更新\"><a href=\"#新的更新\" class=\"headerlink\" title=\"新的更新\"></a>新的更新</h1><h2 id=\"88-更多类型的管道\"><a href=\"#88-更多类型的管道\" class=\"headerlink\" title=\"#88.更多类型的管道\"></a>#88.更多类型的管道</h2><p>&emsp;&emsp;目前已有三种类型的管道：直线型、直角拐弯型、十字型，后续可能会添加T字型。</p>\n<h2 id=\"89-修复管道已知问题\"><a href=\"#89-修复管道已知问题\" class=\"headerlink\" title=\"#89.修复管道已知问题\"></a>#89.修复管道已知问题</h2><ul>\n    <li>玩家复活后复活点附近管道渲染异常</li>\n    <li>管道竖直放置时膨胀箱判定错误</li>\n    <li>道放置连接时已存在的管道时服务端数据更新错误</li>\n    <li>blockstates书写错误</li>\n    <li>直角管道放置时方向判定错误</li>\n    <li>管道连接时模型闪烁</li>\n    <li>管道修改连接时有几率导致游戏崩溃</li>\n    <li>管道水平放置时选择框渲染错误</li>\n    <li>直角管道多方向无法正确连接</li>\n    <li>客户端数据更新后选择框渲染错误</li>\n    <li>管道运输流体后不触发离线存储</li>\n    <li>十字管道转向错误</li>\n    <li>在两个管道中间放置管道显示效果不更新</li>\n    <li>十字管道数据重复</li>\n</ul>\n\n<h2 id=\"90-优化管道算法\"><a href=\"#90-优化管道算法\" class=\"headerlink\" title=\"#90.优化管道算法\"></a>#90.优化管道算法</h2><p>&emsp;&emsp;全面重写管道运输算法，尽量避免递归，防止超长管道运输时迭代过多导致堆栈溢出。</p>\n<h2 id=\"91-修复优化算法带来的漏洞\"><a href=\"#91-修复优化算法带来的漏洞\" class=\"headerlink\" title=\"#91.修复优化算法带来的漏洞\"></a>#91.修复优化算法带来的漏洞</h2><ul>\n    <li>直线管道与直角管道数据方向不更新</li>\n    <li>放置直角管道导致游戏崩溃</li>\n    <li>管道连接时水平流体数据管理器内部错误</li>\n    <li>字管道连接时方向数据同步异常</li>\n</ul>\n\n<h2 id=\"92-修复dor的漏洞\"><a href=\"#92-修复dor的漏洞\" class=\"headerlink\" title=\"#92.修复dor的漏洞\"></a>#92.修复<code>dor</code>的漏洞</h2><p>&emsp;&emsp;修复<code>DataReader</code>无法正确读取VarInt的漏洞。</p>\n<h2 id=\"93-新的GUI控件\"><a href=\"#93-新的GUI控件\" class=\"headerlink\" title=\"#93.新的GUI控件\"></a>#93.新的GUI控件</h2><p>&emsp;&emsp;添加翻页控件，GUI支持显示多页内容，可以上下翻页也可左右翻页。</p>\n<h2 id=\"94-移除老旧的GUI设计\"><a href=\"#94-移除老旧的GUI设计\" class=\"headerlink\" title=\"#94.移除老旧的GUI设计\"></a>#94.移除老旧的GUI设计</h2><p>&emsp;&emsp;老旧的GUI渲染设计采用“静态+动态”的绘制方式，这导致诸如<code>滑动框</code>、<code>翻页</code>等功能实现苦难，故换用新的渲染设计。新的渲染设计采用“纯动态绘制”的绘制方式，并且将控件的坐标设置改为控件在控件组中的坐标而非在GUI中的坐标，减少控件内部和GUI的接触。</p>\n<h2 id=\"95-修复新的渲染的漏洞\"><a href=\"#95-修复新的渲染的漏洞\" class=\"headerlink\" title=\"#95.修复新的渲染的漏洞\"></a>#95.修复新的渲染的漏洞</h2><ul>\n    <li>进度条绘制错误（完全无法正常显示）</li>\n    <li>画笔坐标错误</li>\n    <li>画笔剪切超出显示范围导致后台报错</li>\n    <li>控件在多控件组嵌套时渲染错误</li>\n    <li>MSlot在多控件组嵌套时Slot坐标计算错误</li>\n    <li>合成表按钮和GUI冲突导致后台报错</li>\n    <li>鼠标坐标判定错误</li>\n    <li>滚动条渲染错误</li>\n    <li>按钮文字渲染错误</li>\n    <li>GL设置错误引起的图像绘制异常</li>\n</ul>\n\n<h2 id=\"96-新的鼠标事件触发方式\"><a href=\"#96-新的鼠标事件触发方式\" class=\"headerlink\" title=\"#96.新的鼠标事件触发方式\"></a>#96.新的鼠标事件触发方式</h2><p>&emsp;&emsp;老旧的触发方式已经无法满足新式GUI设计的功能需求，故改用新的鼠标事件触发方式。</p>\n<p>&emsp;&emsp;旧触发方式采用：<code>开始触发事件</code> -&gt; <code>扫描控件</code> -&gt; <code>触发指定控件的事件</code>。</p>\n<p>&emsp;&emsp;新触发方式采用：<code>开始触发事件</code> -&gt; <code>分配任务至控件组</code> -&gt; <code>控件组扫描并触发事件</code>。</p>\n<h2 id=\"97-修复新的事件触发方式带来的漏洞\"><a href=\"#97-修复新的事件触发方式带来的漏洞\" class=\"headerlink\" title=\"#97.修复新的事件触发方式带来的漏洞\"></a>#97.修复新的事件触发方式带来的漏洞</h2><ul>\n    <li>鼠标事件无法触发</li>\n    <li>触发鼠标事件过程中坐标发生偏移</li>\n    <li>鼠标事件对象判断失误的漏洞</li>\n    <li>全局鼠标按键当鼠标在控件外时无法触发</li>\n    <li>鼠标离开事件判定错误</li>\n</ul>\n\n\n\n\n\n<hr>\n<h1 id=\"历史记录：\"><a href=\"#历史记录：\" class=\"headerlink\" title=\"历史记录：\"></a>历史记录：</h1><h2 id=\"1-项目的起点\"><a href=\"#1-项目的起点\" class=\"headerlink\" title=\"#1 项目的起点\"></a>#1 项目的起点</h2><p>&emsp;&emsp;建立现代工业（ModernIndustry）项目，并建立主类以及完成最为基础的架设，此时MI没有任何代码层面及用户层面的功能。</p>\n<h2 id=\"2-建立电力体系\"><a href=\"#2-建立电力体系\" class=\"headerlink\" title=\"#2 建立电力体系\"></a>#2 建立电力体系</h2><p>&emsp;&emsp;简单建立电力系统中的基础概念：发电机、用电器、导线。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"right\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>发电机</strong></td>\n<td align=\"right\">制造能量的机器全部归类于发电机</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>用电器</strong></td>\n<td align=\"right\">消耗能量的机器全部归类与用电器</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>导线</strong></td>\n<td align=\"right\">因为导线采用了和机器不同的算法，所以导线单独分类，用于传输能量</td>\n</tr>\n<tr>\n<td align=\"center\">补充</td>\n<td align=\"right\">储电器同时属于发电机与用电器分类，不属于导线</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-一切的开端—第一个电器\"><a href=\"#3-一切的开端—第一个电器\" class=\"headerlink\" title=\"#3 一切的开端—第一个电器\"></a>#3 一切的开端—第一个电器</h2><p>&emsp;&emsp;创建了MI中的第一个机器——压缩机，不过其在电力系统完工之前不需要电能就可以运行，前期主要用于测试代码功能，在电力系统制作时为其添加了消耗电能的功能。</p>\n<h2 id=\"4-构建电力系统的基本框架\"><a href=\"#4-构建电力系统的基本框架\" class=\"headerlink\" title=\"#4 构建电力系统的基本框架\"></a>#4 构建电力系统的基本框架</h2><p>&emsp;&emsp;构建了电力系统的基本内容与规范，包括：电能概念、电压概念、EleWorker……</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"right\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">电能</td>\n<td align=\"right\">用于表示能量数量的一个指示数字</td>\n</tr>\n<tr>\n<td align=\"center\">电压</td>\n<td align=\"right\">用于表示电压等级的一个指示数字，理论上支持所有非负整数，电压与电能无直接联系</td>\n</tr>\n<tr>\n<td align=\"center\">EleWorker</td>\n<td align=\"right\">电力系统的“工作核心”，系统的所有操作都封装在该类中</td>\n</tr>\n<tr>\n<td align=\"center\">计数器</td>\n<td align=\"right\">用于在用电器输入电压不符合需求电压时计数并在计数器达到阈值时执行指令的工具</td>\n</tr>\n<tr>\n<td align=\"center\">线路缓存</td>\n<td align=\"right\">用于存储线路计算的缓存信息，以此减少线路计算的时间和成本（可以选择不实现缓存功能）</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-第一个导线\"><a href=\"#5-第一个导线\" class=\"headerlink\" title=\"#5 第一个导线\"></a>#5 第一个导线</h2><p>&emsp;&emsp;创建了MI中的第一种导线——粗制导线，也是开发前期阶段唯一可用的导线。导线中实现了信息存储、渲染、缓存三大功能，而线路计算则写入了缓存中。</p>\n<h3 id=\"线路计算原理：\"><a href=\"#线路计算原理：\" class=\"headerlink\" title=\"线路计算原理：\"></a>线路计算原理：</h3><p>&emsp;&emsp;在线路计算中，包含三大流程：寻找线路、计算线路、反馈信息。</p>\n<p>&emsp;&emsp;其中前两个流程可以用等价的方法替换，顺序也可以调整，但反馈信息必须在最后进行。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"right\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>寻找线路</strong></td>\n<td align=\"right\">寻找指定用电器到非指定发电机的路径</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>计算线路</strong></td>\n<td align=\"right\">计算线路上损耗的电能及发电机最终输出的电能和电压</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>反馈信息</strong></td>\n<td align=\"right\">向电力系统反馈计算结果，系统将根据结果进行数据更新</td>\n</tr>\n<tr>\n<td align=\"center\">路径</td>\n<td align=\"right\">表示线路中指定起点到指定终点经过的所有导线方块，包含起点与终点，不包含机器方块</td>\n</tr>\n<tr>\n<td align=\"center\">非指定发电机</td>\n<td align=\"right\">MI采用被动式电能运输，所以寻找线路时一般并不知道目标发电机的位置</td>\n</tr>\n<tr>\n<td align=\"center\">被动式电能运输</td>\n<td align=\"right\">用电器主动向电力系统发起传输电能的请求，然后由电力系统负责完成其余工作</td>\n</tr>\n</tbody></table>\n<p>&emsp;&emsp;不过MI中的粗制导线没有完全按照上述方法进行，而是按照：<code>读取缓存 -&gt; 计算线路 -&gt; 反馈信息</code>的流程工作。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"right\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>读取缓存</strong></td>\n<td align=\"right\">从发电机列表中直接寻找目标发电机，然后读取缓存</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>计算线路</strong></td>\n<td align=\"right\">若缓存不存在则计算起点到终点的最短路径并写入缓存</td>\n</tr>\n<tr>\n<td align=\"center\">发电机列表</td>\n<td align=\"right\">一条线路中所有导线共享同一个缓存，每一根导线都负责维护缓存中的发电机列表</td>\n</tr>\n</tbody></table>\n<p>&emsp;&emsp;上述列出的第一种方式为粗制导线最初使用的工作流程，后因为技术原因替换为第二种。</p>\n<h2 id=\"6-发电机的出现\"><a href=\"#6-发电机的出现\" class=\"headerlink\" title=\"#6 发电机的出现\"></a>#6 发电机的出现</h2><p>&emsp;&emsp;添加了第一个发电机方块——无线电能方块，用于测试电力系统是否可以正常工作，也用于给玩家提供一个万能的创造模式用发电机。</p>\n<h2 id=\"7-完善电力系统框架\"><a href=\"#7-完善电力系统框架\" class=\"headerlink\" title=\"#7 完善电力系统框架\"></a>#7 完善电力系统框架</h2><p>&emsp;&emsp;这是对电力系统第N次重构，完善了电力系统的功能，删除了不需要的部分。从该版本起，缓存彻底被排除在电力系统规范外，是否实现缓存与电力系统工作没有任何关系。</p>\n<h2 id=\"8-合成表模块的第一次开发\"><a href=\"#8-合成表模块的第一次开发\" class=\"headerlink\" title=\"#8 合成表模块的第一次开发\"></a>#8 合成表模块的第一次开发</h2><p>&emsp;&emsp;原版的合成表本人并不会使用，所以干脆写了一个独立的合成表模块，其中所有内容都是可变的，拓展性较强，但存在结构混乱的缺陷。</p>\n<h2 id=\"9-加入自动化概念\"><a href=\"#9-加入自动化概念\" class=\"headerlink\" title=\"#9 加入自动化概念\"></a>#9 加入自动化概念</h2><p>&emsp;&emsp;建立了<code>registry</code>包，用于自动化注册方块、物品等内容，摆脱手动编码的烦恼。</p>\n<h2 id=\"10-自动化的推进\"><a href=\"#10-自动化的推进\" class=\"headerlink\" title=\"#10 自动化的推进\"></a>#10 自动化的推进</h2><p>&emsp;&emsp;除方块、物品的自动化注册外，又新提供了部分内容，此时自动化系统变得较为完善，包括以下内容：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"right\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><strong>方块、物品、TileEntity的注册</strong></td>\n<td align=\"right\">基本游戏内容</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>网络通讯</strong></td>\n<td align=\"right\">封装了网络通讯相关的代码，使服务端与客户端的沟通更加简便</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>数据存储</strong></td>\n<td align=\"right\">支持部分数据类型的自动存储，拜托手动编码的烦恼，不过目前仍存在一些限制</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>GUI绘制</strong></td>\n<td align=\"right\">支持运行时绘制GUI材质，拜托手动绘制材质及寻找组件坐标的烦恼</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>JSON生成</strong></td>\n<td align=\"right\">自动生成方块、物品的JSON文件</td>\n</tr>\n</tbody></table>\n<h2 id=\"11-BUG修复\"><a href=\"#11-BUG修复\" class=\"headerlink\" title=\"#11 BUG修复\"></a>#11 BUG修复</h2><p>&emsp;&emsp;修复部分BUG。</p>\n<h2 id=\"12-GUI绘制\"><a href=\"#12-GUI绘制\" class=\"headerlink\" title=\"#12 GUI绘制\"></a>#12 GUI绘制</h2><p>&emsp;&emsp;完善GUI绘制的功能。</p>\n<h2 id=\"13-新的功能——属性\"><a href=\"#13-新的功能——属性\" class=\"headerlink\" title=\"#13 新的功能——属性\"></a>#13 新的功能——属性</h2><p>&emsp;&emsp;在工具使用时提供额外效果的玩意，有点类似于附魔。</p>\n<h2 id=\"14-工具类\"><a href=\"#14-工具类\" class=\"headerlink\" title=\"#14 工具类\"></a>#14 工具类</h2><p>&emsp;&emsp;提供了一系列<code>Util</code>类，封装了一些常用操作，缩减了代码量。</p>\n<h2 id=\"15-时刻表\"><a href=\"#15-时刻表\" class=\"headerlink\" title=\"#15 时刻表\"></a>#15 时刻表</h2><p>&emsp;&emsp;用于在指定时间后执行指定操作，因为某些功能限制，在<code>#38</code>时被移除。</p>\n<h2 id=\"16-添加一系列物品及机器\"><a href=\"#16-添加一系列物品及机器\" class=\"headerlink\" title=\"#16 添加一系列物品及机器\"></a>#16 添加一系列物品及机器</h2><h2 id=\"17-GUI绘制的完善\"><a href=\"#17-GUI绘制的完善\" class=\"headerlink\" title=\"#17 GUI绘制的完善\"></a>#17 GUI绘制的完善</h2><p>&emsp;&emsp;解决了GUI绘制坐标点寻找烧脑的问题，彻底摆脱思考，同时优化了性能。</p>\n<h2 id=\"18-重写合成表模块\"><a href=\"#18-重写合成表模块\" class=\"headerlink\" title=\"#18 重写合成表模块\"></a>#18 重写合成表模块</h2><p>&emsp;&emsp;因为合成表模块结构过于混乱，没有任何易用性及美观性，所以重新设计、编写了合成表模块：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">分类</th>\n<th align=\"right\">介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>CraftGuide&lt;T, R&gt;</code></td>\n<td align=\"right\">创建、管理合成表，数据可变</td>\n</tr>\n<tr>\n<td align=\"center\"><code>ItemSol</code></td>\n<td align=\"right\">存储物品列表，可有序可无序，数据不可变</td>\n</tr>\n<tr>\n<td align=\"center\"><code>ItemElement</code></td>\n<td align=\"right\">存储单个物品，数据不可变</td>\n</tr>\n<tr>\n<td align=\"center\"><code>IShape</code></td>\n<td align=\"right\">合成表，内部存储原料列表和产物列表，可有序可无序，数据不可变</td>\n</tr>\n</tbody></table>\n<h2 id=\"19-修复线路计算中的问题\"><a href=\"#19-修复线路计算中的问题\" class=\"headerlink\" title=\"#19 修复线路计算中的问题\"></a>#19 修复线路计算中的问题</h2><p>&emsp;&emsp;将线路计算方式换为<code>#5</code>中的第二种方式。</p>\n<h2 id=\"24-优化自动数据存储\"><a href=\"#24-优化自动数据存储\" class=\"headerlink\" title=\"#24 优化自动数据存储\"></a>#24 优化自动数据存储</h2><p>&emsp;&emsp;减少了存储类名需要的成本</p>\n<h2 id=\"34-优化扳手的玩法\"><a href=\"#34-优化扳手的玩法\" class=\"headerlink\" title=\"#34 优化扳手的玩法\"></a>#34 优化扳手的玩法</h2><p>&emsp;&emsp;扳手玩法改为右键不同区域转向不同的方向，<code>shift + 右键</code>拆除方块，暂时没有耐久。</p>\n<h2 id=\"35-完善自动注册的功能\"><a href=\"#35-完善自动注册的功能\" class=\"headerlink\" title=\"#35 完善自动注册的功能\"></a>#35 完善自动注册的功能</h2><p>&emsp;&emsp;使自动注册支持对物品、方块列表进行排序，保证在每次创建存档时创造模式物品栏中的排列顺序不变化。</p>\n<h2 id=\"36-第一次材质扩充\"><a href=\"#36-第一次材质扩充\" class=\"headerlink\" title=\"#36 第一次材质扩充\"></a>#36 第一次材质扩充</h2><h2 id=\"37-增强合成表模块\"><a href=\"#37-增强合成表模块\" class=\"headerlink\" title=\"#37 增强合成表模块\"></a>#37 增强合成表模块</h2><p>&emsp;&emsp;修改了MC原版注册JSON合成表的方法，在其中加入了注册MI的JSON合成表的代码，自此注册合成表可以不再面对繁杂的代码编写。</p>\n<h2 id=\"38-修复服务端支持\"><a href=\"#38-修复服务端支持\" class=\"headerlink\" title=\"#38 修复服务端支持\"></a>#38 修复服务端支持</h2><p>&emsp;&emsp;修复因代码问题导致的服务端启动崩溃。</p>\n<h2 id=\"39-GUI添加鼠标事件\"><a href=\"#39-GUI添加鼠标事件\" class=\"headerlink\" title=\"#39 GUI添加鼠标事件\"></a>#39 GUI添加鼠标事件</h2><p>&emsp;&emsp;GUI支持鼠标事件，在鼠标移出、移入、按下、松开或点击控件时会自动调用控件的方法（前提是控件注册了相关事件）。一个控件可以重复注册同一种事件，在事件被触发时所有相同事件都会被触发，不会被遗漏。</p>\n<h2 id=\"40-优化自动化网络传输结构\"><a href=\"#40-优化自动化网络传输结构\" class=\"headerlink\" title=\"#40 优化自动化网络传输结构\"></a>#40 优化自动化网络传输结构</h2><p>&emsp;&emsp;自动化网络传输采用“注册”结构，添加新的网络传输方式变得更加方便。同时网络传输不再主动询问用户是否需要发送信息，更加偏向半自动化，采用用户主动向网络传输系统发送请求的方式，减少了运行开支。</p>\n<h2 id=\"41-添加合成表显示\"><a href=\"#41-添加合成表显示\" class=\"headerlink\" title=\"#41.添加合成表显示\"></a>#41.添加合成表显示</h2><p>&emsp;&emsp;预期设计是点击机器的进度条可以查看该机器所有的合成表，不过目前由于网络通信的原因还未添加触发合成表显示的机制。以后还会为合成表添加更多的功能，例如：自动装填。</p>\n<h2 id=\"42-修复导线网络通信漏洞\"><a href=\"#42-修复导线网络通信漏洞\" class=\"headerlink\" title=\"#42.修复导线网络通信漏洞\"></a>#42.修复导线网络通信漏洞</h2><p>&emsp;&emsp;修复导线的网络通信中由于IDEA“重命名”功能的BUG出现的一些神奇的代码。</p>\n<h2 id=\"43-网络通信新功能——GUI通信\"><a href=\"#43-网络通信新功能——GUI通信\" class=\"headerlink\" title=\"#43.网络通信新功能——GUI通信\"></a>#43.网络通信新功能——GUI通信</h2><p>&emsp;&emsp;网络通信支持客户端与服务端GUI之间的互相通信。</p>\n<h2 id=\"44-GUI支持事件进行网络通信\"><a href=\"#44-GUI支持事件进行网络通信\" class=\"headerlink\" title=\"#44.GUI支持事件进行网络通信\"></a>#44.GUI支持事件进行网络通信</h2><p>&emsp;&emsp;MIFrame添加了用于支持注册的事件进行网路单向通信的接口，由于一些设计缺陷以及考虑到代码简洁性的原因，事件的网络通信暂时只支持客户端到服务端的通信（即只能由客户端发送信息到服务端）。</p>\n<h2 id=\"45-修复GUI根据鼠标坐标获取组件错误的问题\"><a href=\"#45-修复GUI根据鼠标坐标获取组件错误的问题\" class=\"headerlink\" title=\"#45-修复GUI根据鼠标坐标获取组件错误的问题\"></a>#45-修复GUI根据鼠标坐标获取组件错误的问题</h2><p>&emsp;&emsp;原本获取组件的算法有问题，这次修改了算法。</p>\n<h2 id=\"46-修复Group内添加的组件鼠标事件错误的问题\"><a href=\"#46-修复Group内添加的组件鼠标事件错误的问题\" class=\"headerlink\" title=\"#46-修复Group内添加的组件鼠标事件错误的问题\"></a>#46-修复Group内添加的组件鼠标事件错误的问题</h2><p>&emsp;&emsp;原本的事件触发方式导致<code>Group</code>内的鼠标事件无法触发，这次修改了触发方式，使<code>Group</code>内组件的鼠标事件也可以正确触发。</p>\n<h2 id=\"47-修复GUI按钮响应错误的问题\"><a href=\"#47-修复GUI按钮响应错误的问题\" class=\"headerlink\" title=\"#47-修复GUI按钮响应错误的问题\"></a>#47-修复GUI按钮响应错误的问题</h2><p>&emsp;&emsp;修复GUI按钮鼠标事件的错误响应，以及为鼠标点击添加了音效。</p>\n<h2 id=\"48-修复GUI组件onAddToGUI方法运行两次\"><a href=\"#48-修复GUI组件onAddToGUI方法运行两次\" class=\"headerlink\" title=\"#48-修复GUI组件onAddToGUI方法运行两次\"></a>#48-修复GUI组件onAddToGUI方法运行两次</h2><p>&emsp;&emsp;<code>StaticFrameClient</code>构造函数中的错误用法导致客户端<code>onAddToGUI</code>运行两次。</p>\n<h2 id=\"49-修复Group的错误算法\"><a href=\"#49-修复Group的错误算法\" class=\"headerlink\" title=\"#49.修复Group的错误算法\"></a>#49.修复Group的错误算法</h2><p>&emsp;&emsp;<code>Group</code>类获取鼠标指向的组件时没有调用组件的判断方法直接返回了组件，导致判断结果异常。</p>\n<h2 id=\"50-添加合成表按钮\"><a href=\"#50-添加合成表按钮\" class=\"headerlink\" title=\"#50.添加合成表按钮\"></a>#50.添加合成表按钮</h2><p>&emsp;&emsp;添加了隐形的合成表按钮，支持全自动调整坐标和尺寸。部分功能依赖<code>MComponent</code>执行，所以从该版本开始要求<code>MComponent</code>的子类重写<code>onAddToGUI</code>方法时必须调用父类对应的方法。</p>\n<h2 id=\"49-修复Group的错误算法-1\"><a href=\"#49-修复Group的错误算法-1\" class=\"headerlink\" title=\"#49-修复Group的错误算法\"></a>#49-修复Group的错误算法</h2><p>&emsp;&emsp;<code>Group</code>类获取鼠标指向的组件时没有调用组件的判断方法直接返回了组件，导致判断结果异常。</p>\n<h2 id=\"50-添加合成表按钮-1\"><a href=\"#50-添加合成表按钮-1\" class=\"headerlink\" title=\"#50.添加合成表按钮\"></a>#50.添加合成表按钮</h2><p>&emsp;&emsp;添加了隐形的合成表按钮，支持全自动调整坐标和尺寸。部分功能依赖<code>MComponent</code>执行，所以从该版本开始要求<code>MComponent</code>的子类重写<code>onAddToGUI</code>方法时必须调用父类对应的方法。</p>\n<h2 id=\"51-添加对已有所有合成表类型的显示支持\"><a href=\"#51-添加对已有所有合成表类型的显示支持\" class=\"headerlink\" title=\"#51-添加对已有所有合成表类型的显示支持\"></a>#51-添加对已有所有合成表类型的显示支持</h2><p>&emsp;&emsp;自动合成表显示目前已经支持对已有四种类型的合成表进行显示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">合成表类型</th>\n<th align=\"right\">特点介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\"><code>OrderlyShapeOnly</code></td>\n<td align=\"right\">原料列表有序，产物仅有一种</td>\n</tr>\n<tr>\n<td align=\"center\"><code>UnorderlyShapeOnly</code></td>\n<td align=\"right\">原料列表无序，产物仅有一种</td>\n</tr>\n<tr>\n<td align=\"center\"><code>OrderlyShape</code></td>\n<td align=\"right\">原料列表有序，产物有多种（无序）</td>\n</tr>\n<tr>\n<td align=\"center\"><code>UnorderlyShape</code></td>\n<td align=\"right\">原料列表无序，产物有多种（无序）</td>\n</tr>\n</tbody></table>\n<div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#66ccff\">注：原料列表有序即相当于有序合成表，无序则为无序合成表</font></div>\n\n<h2 id=\"52-修复打开空的合成表时游戏崩溃\"><a href=\"#52-修复打开空的合成表时游戏崩溃\" class=\"headerlink\" title=\"#52-修复打开空的合成表时游戏崩溃\"></a>#52-修复打开空的合成表时游戏崩溃</h2><p>&emsp;&emsp;修复打开空的合成表时抛出<code>IndexOutOfBoundException</code>及<code>IllegalArgumentException</code>导致的程序崩溃。</p>\n<h2 id=\"53-修复GUI网络通信时客户端服务端窗体对象可能不一致的漏洞\"><a href=\"#53-修复GUI网络通信时客户端服务端窗体对象可能不一致的漏洞\" class=\"headerlink\" title=\"#53.修复GUI网络通信时客户端服务端窗体对象可能不一致的漏洞\"></a>#53.修复GUI网络通信时客户端服务端窗体对象可能不一致的漏洞</h2><p>&emsp;&emsp;以往GUI进行网络通信时，通信内容中并没有存储发送信息的GUI的窗体信息，导致接收端无法判断窗体是否一致，该更新在通讯信息中加入了GUI窗体校验信息，辅助信息正确性校验。</p>\n<h2 id=\"54-修复点击合成表按钮响应多次的BUG\"><a href=\"#54-修复点击合成表按钮响应多次的BUG\" class=\"headerlink\" title=\"#54.修复点击合成表按钮响应多次的BUG\"></a>#54.修复点击合成表按钮响应多次的BUG</h2><p>&emsp;&emsp;以往按钮注册事件的代码位置错误，导致同一个事件被多次注册，从而使按钮响应多次，该更新修改了注册机制，添加了专门的初始化接口，修正了该BUG。</p>\n<h2 id=\"55-添加配置功能\"><a href=\"#55-添加配置功能\" class=\"headerlink\" title=\"#55.添加配置功能\"></a>#55.添加配置功能</h2><p>&emsp;&emsp;支持简单的配置功能，预备后续重新写一遍更高级的。</p>\n<h2 id=\"56-重写方块JSON生成器\"><a href=\"#56-重写方块JSON生成器\" class=\"headerlink\" title=\"#56.重写方块JSON生成器\"></a>#56.重写方块JSON生成器</h2><p>&emsp;&emsp;重写了<code>BlockJsonBuilder</code>类，提供了更加高级的功能，支持多种方块的JSON生成，同时支持快捷的模板添加。</p>\n<h2 id=\"57-GUI显示调整\"><a href=\"#57-GUI显示调整\" class=\"headerlink\" title=\"#57.GUI显示调整\"></a>#57.GUI显示调整</h2><p>&emsp;&emsp;GUI中玩家背包上方添加“物品栏”文字。</p>\n<h2 id=\"58-修复自动读写崩溃问题\"><a href=\"#58-修复自动读写崩溃问题\" class=\"headerlink\" title=\"#58.修复自动读写崩溃问题\"></a>#58.修复自动读写崩溃问题</h2><p>&emsp;&emsp;当需要存储的值为<code>null</code>时会导致存储失败并放弃剩余数据，该问题出现的原因是大部分情况下客户端的TE中并没有存储有效数据。解决方案：客户端不再触发自动读写。</p>\n<h2 id=\"59-实现本地GUI渲染\"><a href=\"#59-实现本地GUI渲染\" class=\"headerlink\" title=\"#59.实现本地GUI渲染\"></a>#59.实现本地GUI渲染</h2><p>&emsp;&emsp;实现了本地子GUI渲染，允许玩家在已打开的GUI上再打开一个GUI。打开子GUI时会拦截原GUI的所有操作，当玩家尝试关闭GUI时只会关闭子GUI，而原GUI保持开启。</p>\n<h2 id=\"60-实现以玩家为凭借的双端通信\"><a href=\"#60-实现以玩家为凭借的双端通信\" class=\"headerlink\" title=\"#60.实现以玩家为凭借的双端通信\"></a>#60.实现以玩家为凭借的双端通信</h2><p>&emsp;&emsp;允许以玩家为<code>KEY</code>进行服务端客户端双端通信，为保持安全以<code>UUID</code>为凭借。</p>\n<h2 id=\"61-修复服务端SideOnly问题\"><a href=\"#61-修复服务端SideOnly问题\" class=\"headerlink\" title=\"#61.修复服务端SideOnly问题\"></a>#61.修复服务端SideOnly问题</h2><p>&emsp;&emsp;修复因<code>SideOnly(CLIENT)</code>导致的服务端BUG。</p>\n<h2 id=\"62-修复两端数据不一致导致的BUG\"><a href=\"#62-修复两端数据不一致导致的BUG\" class=\"headerlink\" title=\"#62.修复两端数据不一致导致的BUG\"></a>#62.修复两端数据不一致导致的BUG</h2><p>&emsp;&emsp;修复因客户端与服务端<code>网络注册ID</code>和<code>GUI ID</code>不一致导致的问题。</p>\n<h2 id=\"63-修复GUI渲染问题\"><a href=\"#63-修复GUI渲染问题\" class=\"headerlink\" title=\"#63.修复GUI渲染问题\"></a>#63.修复GUI渲染问题</h2><p>&emsp;&emsp;修复当传入数据为负值时导致的<code>CommonProgress</code>渲染异常。</p>\n<h2 id=\"64-字节层次的数据操作——dor\"><a href=\"#64-字节层次的数据操作——dor\" class=\"headerlink\" title=\"#64.字节层次的数据操作——dor\"></a>#64.字节层次的数据操作——dor</h2><p>&emsp;&emsp;添加了自制的数据操作库<code>dor</code>，主要由<code>IDataReader</code>(读取器)和<code>IDataWriter</code>(写入器)组成。同时提供了两个默认实现：支持读写的<code>ByteDataOperator</code>以及只读的<code>ReadOnlyDataOperator</code>。</p>\n<h2 id=\"65-新的数据读写系统\"><a href=\"#65-新的数据读写系统\" class=\"headerlink\" title=\"#65.新的数据读写系统\"></a>#65.新的数据读写系统</h2><p>&emsp;&emsp;编写全新的数据读写系统，除原本的<code>NBTTagCompound</code>支持外，新加了对<code>ByteBuf</code>及自制的<code>dor</code>的支持。</p>\n<h2 id=\"66-新的自动数据读写\"><a href=\"#66-新的自动数据读写\" class=\"headerlink\" title=\"#66.新的自动数据读写\"></a>#66.新的自动数据读写</h2><p>&emsp;&emsp;依靠新的数据读写系统编写了全新的自动化数据读写库，运行主要依靠<code>IClassData</code>，实现了对数据的自动存储，同时支持数据类型转换。</p>\n<h2 id=\"67-完善合成表自动填充的功能\"><a href=\"#67-完善合成表自动填充的功能\" class=\"headerlink\" title=\"#67.完善合成表自动填充的功能\"></a>#67.完善合成表自动填充的功能</h2><p>&emsp;&emsp;修复了合成表填充时存在的所有已知BUG，优化合成表显示。</p>\n<h2 id=\"68-网络通信换用dor系统\"><a href=\"#68-网络通信换用dor系统\" class=\"headerlink\" title=\"#68.网络通信换用dor系统\"></a>#68.网络通信换用dor系统</h2><p>&emsp;&emsp;自动化网络通信全面抛弃<code>NBTTagCompound</code>，使用<code>dor</code>读写系统。</p>\n<h2 id=\"69-修复dor漏洞及优化功能\"><a href=\"#69-修复dor漏洞及优化功能\" class=\"headerlink\" title=\"#69.修复dor漏洞及优化功能\"></a>#69.修复dor漏洞及优化功能</h2><ul>\n    <li>修复读写数据时下标错误的更新</li>\n    <li>修复读写占用多字节的数据时的错误移位操作</li>\n    <li>修复读写varint时的错误移位操作</li>\n    <li>优化不合理的写入顺序</li>\n</ul>\n## #70.移除“属性”功能\n\n<p>&emsp;&emsp;由于<code>属性</code>功能与附魔玩法重复并且存在漏洞，所以决定将该功能删除。</p>\n<h2 id=\"71-添加虚拟dor\"><a href=\"#71-添加虚拟dor\" class=\"headerlink\" title=\"#71.添加虚拟dor\"></a>#71.添加虚拟dor</h2><p>&emsp;&emsp;添加了<code>VarDataReader</code>类，用于在不复制任何数据的情况下进行<code>data</code>读取，优化了<code>IDataReader#readData()</code>的时间成本及空间成本。</p>\n<h2 id=\"72-修复自动化网络通信的BUG\"><a href=\"#72-修复自动化网络通信的BUG\" class=\"headerlink\" title=\"#72.修复自动化网络通信的BUG\"></a>#72.修复自动化网络通信的BUG</h2><p>&emsp;&emsp;修复基于方块的网络通信中可能存在的进行网络通信时客户端世界未构造完毕的BUG。</p>\n<h2 id=\"73-修复合成表填充显示异常\"><a href=\"#73-修复合成表填充显示异常\" class=\"headerlink\" title=\"#73.修复合成表填充显示异常\"></a>#73.修复合成表填充显示异常</h2><p>&emsp;&emsp;修复合成表填充后GUI显示异常，通过在填充合成表后代码触发数据同步来更新GUI显示。</p>\n<h2 id=\"74-支持自动注册流体\"><a href=\"#74-支持自动注册流体\" class=\"headerlink\" title=\"#74.支持自动注册流体\"></a>#74.支持自动注册流体</h2><p>&emsp;&emsp;支持自动注册流体、流体物品、流体方块及流体桶。</p>\n<h2 id=\"75-自动注册系统改用注册机制\"><a href=\"#75-自动注册系统改用注册机制\" class=\"headerlink\" title=\"#75.自动注册系统改用注册机制\"></a>#75.自动注册系统改用注册机制</h2><p>&emsp;&emsp;自动注册系统换用注册机制添加注册类型，拓展性更强。</p>\n<h2 id=\"76-修复一些小漏洞\"><a href=\"#76-修复一些小漏洞\" class=\"headerlink\" title=\"#76.修复一些小漏洞\"></a>#76.修复一些小漏洞</h2><ul>\n    <li>生成本地名称时将\".\"误写为\":\"\n    </li><li>矿石生成器注册异常\n    </li><li>Mixin编译报错\n    </li><li>新版自动注册不调用排序方法\n    </li><li>某些注册机错误处理本地名称\n    </li><li>Json生成器对key的错误处理\n</li></ul>\n\n\n<h2 id=\"77-完善组件\"><a href=\"#77-完善组件\" class=\"headerlink\" title=\"#77.完善组件\"></a>#77.完善组件</h2><ul>\n    <li>补充GUI材质\n    </li><li>扩充字典内容\n    </li><li>完善语言文件（中文简体）\n</li></ul>\n\n\n<h2 id=\"78-添加流体管道的接口\"><a href=\"#78-添加流体管道的接口\" class=\"headerlink\" title=\"#78.添加流体管道的接口\"></a>#78.添加流体管道的接口</h2><p>&emsp;&emsp;添加了流体管道需要用到的接口（可能不全，后续调整），大致确定了流体管道工作方式。</p>\n<h2 id=\"79-添加流体管道的TileEntity的默认实现\"><a href=\"#79-添加流体管道的TileEntity的默认实现\" class=\"headerlink\" title=\"#79.添加流体管道的TileEntity的默认实现\"></a>#79.添加流体管道的TileEntity的默认实现</h2><p>&emsp;&emsp;默认的<code>TIleEntity</code>实现了对管道需要用到的数据的底层管理，包括渲染数据、连接数据、存储数据等。</p>\n<h2 id=\"80-GUI自动绘制添加更多的事件\"><a href=\"#80-GUI自动绘制添加更多的事件\" class=\"headerlink\" title=\"#80.GUI自动绘制添加更多的事件\"></a>#80.GUI自动绘制添加更多的事件</h2><p>&emsp;&emsp;GUI自动绘制添加了<code>MouseLocationListener</code>事件，该事件每Tick在组件绘制前被触发，用于记录鼠标坐标的更改。同时还修改了部分GUI鼠标事件的触发方式，让事件功能更加强大。</p>\n<h2 id=\"81-GUI添加滚动条控件\"><a href=\"#81-GUI添加滚动条控件\" class=\"headerlink\" title=\"#81.GUI添加滚动条控件\"></a>#81.GUI添加滚动条控件</h2><p>&emsp;&emsp;向自动化GUI系统添加滚动条控件，效果与创造模式背包右侧的滚动条类似。</p>\n<h2 id=\"82-GUI添加更多事件\"><a href=\"#82-GUI添加更多事件\" class=\"headerlink\" title=\"#82.GUI添加更多事件\"></a>#82.GUI添加更多事件</h2><p>&emsp;&emsp;支持控件监视键盘事件（包括按下和释放）以及鼠标滚轮滑动事件。</p>\n<h2 id=\"83-添加类信息查看器\"><a href=\"#83-添加类信息查看器\" class=\"headerlink\" title=\"#83.添加类信息查看器\"></a>#83.添加类信息查看器</h2><p>&emsp;&emsp;添加类信息查看器，右键方块即可查看方块<code>TileEntity</code>中存储的信息。该物品是为了取代老旧的线缆信息查看器，故同时删除了线缆信息查看器。</p>\n<h2 id=\"84-优化和完善自动化数据存储\"><a href=\"#84-优化和完善自动化数据存储\" class=\"headerlink\" title=\"#84.优化和完善自动化数据存储\"></a>#84.优化和完善自动化数据存储</h2><ul>\n    <li>优化对枚举类的存储，占用更少的空间</li>\n    <li>自动化数据存储类型转换默认支持到字符串的转换</li>\n    <li>已有的类型添加更完善的类型转换功能</li>\n</ul>\n\n\n<h2 id=\"85-修复并优化管道的部分功能\"><a href=\"#85-修复并优化管道的部分功能\" class=\"headerlink\" title=\"#85.修复并优化管道的部分功能\"></a>#85.修复并优化管道的部分功能</h2><ul>\n    <li><b>修复：</b>放置时不自动连接周围方块</li>\n    <li><b>修复：</b>数据读取时报错导致无法正确恢复存档内容</li>\n    <li><b>修复：</b>管道放置时朝向数据客户端服务端计算结果不一致</li>\n    <li><b>修复：</b>管道输出流体到世界后流体不会流动</li>\n    <li><b>优化：</b>移除多余的数据</li>\n    <li><b>优化：</b>细化碰撞箱</li>\n    <li><b>优化：</b>管道放置时的朝向判断</li>\n    <li><b>优化：</b>管道的网络资源占用</li>\n    <li><b>添加：</b>支持添加管塞</li>\n\n\n</ul>\n\n<h2 id=\"86-修复功能优化带来的漏洞\"><a href=\"#86-修复功能优化带来的漏洞\" class=\"headerlink\" title=\"#86.修复功能优化带来的漏洞\"></a>#86.修复功能优化带来的漏洞</h2><ul>\n    <li>导线无法正常连接周围方块</li>\n    <li>机器无法正常从导线获取能量</li>\n</ul>\n\n\n<h2 id=\"87-优化包-类结构\"><a href=\"#87-优化包-类结构\" class=\"headerlink\" title=\"#87.优化包/类结构\"></a>#87.优化包/类结构</h2><p>&emsp;&emsp;将<code>BlockUtil</code>合并到<code>WorldUtil</code>中，修改部分包名，修改部分包的包含结构。</p>\n"},{"title":"如何理解c/c++中的输入/输出函数？","date":"2021-09-27T13:16:36.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b9.jpeg","description":"简要讲解控制台输入/输出的相关内容","_content":"\n\n\n# scanf的使用\n\n&emsp;&emsp;`scanf`声明在`stdio.h`头文件中，其声明为` int scanf(const char \\*format, ...)`。从声明可以看出，`scanf`接收如下参数：\n\n<ol>\n    <li>字符串：用于确定输入数据的类型</li>\n    <li>变长参数：用于输入需要进行写入的变量的地址</li>\n</ol>\n\n&emsp;&emsp;其返回值为int类型，值为成功匹配和赋值的个数，如果到达文件末尾或发生读错误，则返回`EOF`。\n\n&emsp;&emsp;对于`scanf`的变长参数，等后面指针专题再讨论这个问题，现在只需要知道传参时非数组、指针类型需要在变量名前面加上`&`。\n\n## EOF\n\n&emsp;&emsp;`EOF`是`End Of File`的缩写，通常在文本最后由该字符表示结束。该值一般为`-1`，但是在不同编译器中该值的定义可能不同，不过不用担心，C在`stdio.h`中已经通过宏的方式定义了该常量。\n\n\n## 示例\n\n```C\n#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    return 0;\n}\n```\n\n\n# printf的使用\n\n\n&emsp;&emsp;`printf`也声明在`stdio.h`头文件中，其声明为`int printf(const char *format, ...)`。从声明可以看出，`printf`接收如下参数：\n\n<ol>\n    <li>字符串：用于确定输出数据的类型</li>\n    <li>变长参数：用于输入需要打印的数据</li>\n</ol>\n\n&emsp;&emsp;其返回值为int类型，值为写入的字符总数，如果写入失败则返回一个负数。\n\n## 示例\n\n```C\n#include <stdio.h>\n\nint main() {\n    double PI = 3.1415;\n    printf(\"%f\", PI);\n    return 0;\n}\n```\n\n# 变长参数\n\n<div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#66ccff\">注：该章节不考虑编译器优化对参数传递方式的影响</font></div>\n\n&emsp;&emsp;变长参数的本质就是一段连续的内存，我们用一个图解释一下：\n\n![变长参数](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/bianchang.jpg)\n\n&emsp;&emsp;我们先来了解调用函数时是如何传参的，图中第一个对应的是函数`void example(int arg0, double arg1, short arg2)`的模型，在调用该函数时需要传入三个值，在传递时编译器会将要传入的值复制并排列到一起，然后传递给被调用的函数。函数使用时取用相应位置的内存即可。图中第二个对应的是函数`void example(char arg0[])`，传递方式和上面相同。\n\n&emsp;&emsp;第三个便是我们要说的变长参数，变长参数与普通传参不同的地方就在于传递的参数的数量是任意的，所以大多接受变长参数的函数都需要手动输入一个值表示变长参数的数量。\n\n# 缓冲区\n\n&emsp;&emsp;缓冲区是程序建立的一个内存空间，用于临时存储数据。其工作原理如图所示：（无缓冲输出就是把输入反过来）\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/io.jpg\" alt=\"示意图\" style=\"zoom:80%;\" />\n\n## 缓冲区的意义\n\n&emsp;&emsp;为什么要有缓冲区？根据上图第一个无缓冲输入所示，程序从用户输入中逐个读取数据，在输入较多数据时这无疑是一种费时费力的方法，同时此时用户也无法修改自己输入的内容，因为当键盘敲下的时候数据就被读取了。有了缓冲区之后，不仅使用户可以修改自己输入的数据（按下回车之前的），同时也让程序可以成段的读取数据，减少了时间成本，输出同理。\n\n&emsp;&emsp;那么无缓冲区的输入/输出就没有用武之地了吗？并不是，例如在写控制台游戏时你是希望用户按下键盘时立即执行操作还是等待缓冲区刷新？为了加快游戏对用户输入的处理速度，我们当然会选择无缓冲的输入方式。`stdio.h`中的`stderr`同样使用的无缓冲输出，这样使得错误信息可以更快的打印到控制台，而不用等待缓冲刷新。\n\n&emsp;&emsp;缓冲区的大小取决于操作系统，常见的大小为512字节和4096字节。\n\n&emsp;&emsp;PS：我曾经用C++写过一个贪吃蛇，想试试的可以[点击链接查看](https://dwz.cn/yqe55Kal)，当时还不会用git所以就不要吐槽里面为什么都是压缩包了。还有一个[旧版的演示视频](https://www.bilibili.com/video/BV1Hb411g7i8/)。\n\n## 缓冲区分类\n\n&emsp;&emsp;缓冲区分为两类：完全缓冲I/O和行缓冲I/O。\n\n### 完全缓冲\n\n&emsp;&emsp;完全缓冲是指只有当缓冲区被填满或手动触发缓冲区刷新时才会刷新缓冲区（即将数据内容发送至目的地），这种缓冲方式通常出现在文件I/O操作中。\n\n### 行缓冲\n\n&emsp;&emsp;行缓冲与完全缓冲不同的是其遇到换行符时便会刷新缓冲，键盘输入通常是行缓冲的方式，所以在摁下Enter键时程序才会开始处理数据。\n\n## 缓冲区刷新方式\n\n&emsp;&emsp;除了上面提到的自动刷新缓冲区的方式，我们还可以使用代码强制刷新缓冲区，即`stdio.h`中的`int fflush(FILE *stream)`函数。该函数的参数是需要刷新缓冲区的流（标准输入流是：stdin，标准输出流是：stdout，标准错误输出流是：stderr）。C++中还能使用`endl`换行并刷新缓冲区。\n\n# 有缓冲输入/输出\n\n&emsp;&emsp;平时我们使用的`scanf`和`printf`默认情况下都是有缓冲的。`scanf`和`printf`中都有一个字符串和变长参数作为参数，那么这个字符串的作用是什么呢？这个字符串是对要输入/输出的内容的描述，其中`%*`被称为“转换说明”，`%`与`*`之间的是转换说明修饰符。\n\n## 参数说明\n\n### 转换说明\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/zhuanhuan.jpg\" alt=\"转换说明\" style=\"zoom:67%;\" />\n\n### printf修饰符\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/xiushi.jpg\" alt=\"修饰符\" style=\"zoom:67%;\" />\n\n### printf标记\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/biaoji.jpg\" alt=\"标记\" style=\"zoom:67%;\" />\n\n### scanf修饰符\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/sxh.jpg\" alt=\"修饰符\" style=\"zoom:67%;\" />\n\n### printf与scanf中的`*`修饰符\n\n&emsp;&emsp;`printf`和`scanf`的修饰符中都可以使用`*`，但是他们的语义并不相同，我们写一段代码试一下：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int temp, width;\n    scanf(\"%*d %d %*d %d\", &temp, &width);\n    printf(\"result:%0*d\", width, temp);\n    return 0;\n}\n```\n\n&emsp;&emsp;我们现在来模拟一下程序运行（`| `不是实际内容，只是为了分割文字介绍与程序内容）：\n\n```\n控制台输入：\t\t| 654 12 5689 20\nscanf读取：\t\t| 654 12 5689 20\n赋值：\t\t\t| temp = 12, width = 20\nprintf解析字符串：\t| result:%020d\nprintf打印：\t\t| 00000000000000000012\n```\n\n&emsp;&emsp;这里就能看出来规律了，`scanf`中使用`*`会让scanf跳过对该项的赋值，但是输入时仍需要输入该项。`printf`中使用`*`可以在运行时决定填入的数字为多少（示例中只替换了一个数，实际操作中任意数字型的修饰符都可以用`*`替换）。\n\n## 注意事项\n\n&emsp;&emsp;使用`scanf`与`printf`时一定要注意字符串内容要与参数列表相对应，否则轻则程序崩溃，重则带着错误信息继续运行（为什么说继续运行更严重呢，因为直接崩溃更容易定位错误位置）。为什么会这样呢？我们再回顾一下函数处理变长参数的方式：按照数据类型分割内存。\n\n&emsp;&emsp;但是这两个函数的变长参数列表传递进去的类型是任意的，所以无法直接判断应该从哪个地方分割内存。这时候字符串里面的信息就派上用场了，它可以告诉函数这个地方传递进去的值是什么类型。如果我们本应该输入`%d %d %d`但是却输入了`%d %lf %d`，那么从第二项开始，后面的所有项都会被错误的读取。\n\n# 无缓冲输入\n\n&emsp;&emsp;许多编译器都为无缓冲输入提供了特殊的函数，其原型都在`conio.h`中。在继续向下说之前我们再来说一下“回显”是什么。回显是当用户敲击键盘时在控制台显示用户输入的内容，无回显输入在使用时不会在控制台显示用户输入，这通常用来实现密码输入的功能。\n\n&emsp;&emsp;在`conio.h`提供的函数中，包括有回显无缓冲的`getchar()`、无回显无缓冲的`getch()`。在UNIX系统中使用另一种控制方式，UNXI系统使用`ioctil()`函数（该函数在UNIX库中但并不属于ANSI C）控制输入类型，然后使用`getchar()`进行操作。在ANSI C中则使用`setbuf()`和`setvbuf()`函数控制缓冲，但是受限于系统的内部设置，这些函数可能不起作用。总而言之就是ANSI C没有提供无缓冲输入的标准方式，能否进行无缓冲输入取决于操作系统。\n\n# putchar\n\n&emsp;&emsp;`putchar`在标准中没有定义有无缓冲，所以在不同编译器（甚至是同一个编译器的不同版本）中都可能会有不同的结果。注意下面这段代码：\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    putchar('a');\n    system(\"pause\");\n    return 0;\n}\n```\n\n&emsp;&emsp;在`GCC 4.9.2`中该代码得到下面的结果：\n\n```\na请按任意键继续。。。\n```\n\n&emsp;&emsp;而在`GCC 8.1.0`中则得到下面的结果：\n\n```\n请按任意键继续。。。\n\na\n```\n\n# 参考资料\n\n>1. 《C Primer Plus》相关章节\n>2. 菜鸟教程相关章节：[1](https://www.runoob.com/cprogramming/c-function-printf.html)、[2](https://www.runoob.com/cprogramming/c-function-scanf.html)\n>3. [c语言里缓冲区的理解-CSDN博客](https://blog.csdn.net/qq_36532097/article/details/70197061)\n\n\n\n\n\n\n\n","source":"_posts/stdio.md","raw":"---\ntitle: 如何理解c/c++中的输入/输出函数？\ndate: 2021-09-27 21:16:36\ncategories:\n  - C/C++\ntags:\n  - 函数\n  - 教程\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b9.jpeg\ndescription: 简要讲解控制台输入/输出的相关内容\n---\n\n\n\n# scanf的使用\n\n&emsp;&emsp;`scanf`声明在`stdio.h`头文件中，其声明为` int scanf(const char \\*format, ...)`。从声明可以看出，`scanf`接收如下参数：\n\n<ol>\n    <li>字符串：用于确定输入数据的类型</li>\n    <li>变长参数：用于输入需要进行写入的变量的地址</li>\n</ol>\n\n&emsp;&emsp;其返回值为int类型，值为成功匹配和赋值的个数，如果到达文件末尾或发生读错误，则返回`EOF`。\n\n&emsp;&emsp;对于`scanf`的变长参数，等后面指针专题再讨论这个问题，现在只需要知道传参时非数组、指针类型需要在变量名前面加上`&`。\n\n## EOF\n\n&emsp;&emsp;`EOF`是`End Of File`的缩写，通常在文本最后由该字符表示结束。该值一般为`-1`，但是在不同编译器中该值的定义可能不同，不过不用担心，C在`stdio.h`中已经通过宏的方式定义了该常量。\n\n\n## 示例\n\n```C\n#include <stdio.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    return 0;\n}\n```\n\n\n# printf的使用\n\n\n&emsp;&emsp;`printf`也声明在`stdio.h`头文件中，其声明为`int printf(const char *format, ...)`。从声明可以看出，`printf`接收如下参数：\n\n<ol>\n    <li>字符串：用于确定输出数据的类型</li>\n    <li>变长参数：用于输入需要打印的数据</li>\n</ol>\n\n&emsp;&emsp;其返回值为int类型，值为写入的字符总数，如果写入失败则返回一个负数。\n\n## 示例\n\n```C\n#include <stdio.h>\n\nint main() {\n    double PI = 3.1415;\n    printf(\"%f\", PI);\n    return 0;\n}\n```\n\n# 变长参数\n\n<div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#66ccff\">注：该章节不考虑编译器优化对参数传递方式的影响</font></div>\n\n&emsp;&emsp;变长参数的本质就是一段连续的内存，我们用一个图解释一下：\n\n![变长参数](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/bianchang.jpg)\n\n&emsp;&emsp;我们先来了解调用函数时是如何传参的，图中第一个对应的是函数`void example(int arg0, double arg1, short arg2)`的模型，在调用该函数时需要传入三个值，在传递时编译器会将要传入的值复制并排列到一起，然后传递给被调用的函数。函数使用时取用相应位置的内存即可。图中第二个对应的是函数`void example(char arg0[])`，传递方式和上面相同。\n\n&emsp;&emsp;第三个便是我们要说的变长参数，变长参数与普通传参不同的地方就在于传递的参数的数量是任意的，所以大多接受变长参数的函数都需要手动输入一个值表示变长参数的数量。\n\n# 缓冲区\n\n&emsp;&emsp;缓冲区是程序建立的一个内存空间，用于临时存储数据。其工作原理如图所示：（无缓冲输出就是把输入反过来）\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/io.jpg\" alt=\"示意图\" style=\"zoom:80%;\" />\n\n## 缓冲区的意义\n\n&emsp;&emsp;为什么要有缓冲区？根据上图第一个无缓冲输入所示，程序从用户输入中逐个读取数据，在输入较多数据时这无疑是一种费时费力的方法，同时此时用户也无法修改自己输入的内容，因为当键盘敲下的时候数据就被读取了。有了缓冲区之后，不仅使用户可以修改自己输入的数据（按下回车之前的），同时也让程序可以成段的读取数据，减少了时间成本，输出同理。\n\n&emsp;&emsp;那么无缓冲区的输入/输出就没有用武之地了吗？并不是，例如在写控制台游戏时你是希望用户按下键盘时立即执行操作还是等待缓冲区刷新？为了加快游戏对用户输入的处理速度，我们当然会选择无缓冲的输入方式。`stdio.h`中的`stderr`同样使用的无缓冲输出，这样使得错误信息可以更快的打印到控制台，而不用等待缓冲刷新。\n\n&emsp;&emsp;缓冲区的大小取决于操作系统，常见的大小为512字节和4096字节。\n\n&emsp;&emsp;PS：我曾经用C++写过一个贪吃蛇，想试试的可以[点击链接查看](https://dwz.cn/yqe55Kal)，当时还不会用git所以就不要吐槽里面为什么都是压缩包了。还有一个[旧版的演示视频](https://www.bilibili.com/video/BV1Hb411g7i8/)。\n\n## 缓冲区分类\n\n&emsp;&emsp;缓冲区分为两类：完全缓冲I/O和行缓冲I/O。\n\n### 完全缓冲\n\n&emsp;&emsp;完全缓冲是指只有当缓冲区被填满或手动触发缓冲区刷新时才会刷新缓冲区（即将数据内容发送至目的地），这种缓冲方式通常出现在文件I/O操作中。\n\n### 行缓冲\n\n&emsp;&emsp;行缓冲与完全缓冲不同的是其遇到换行符时便会刷新缓冲，键盘输入通常是行缓冲的方式，所以在摁下Enter键时程序才会开始处理数据。\n\n## 缓冲区刷新方式\n\n&emsp;&emsp;除了上面提到的自动刷新缓冲区的方式，我们还可以使用代码强制刷新缓冲区，即`stdio.h`中的`int fflush(FILE *stream)`函数。该函数的参数是需要刷新缓冲区的流（标准输入流是：stdin，标准输出流是：stdout，标准错误输出流是：stderr）。C++中还能使用`endl`换行并刷新缓冲区。\n\n# 有缓冲输入/输出\n\n&emsp;&emsp;平时我们使用的`scanf`和`printf`默认情况下都是有缓冲的。`scanf`和`printf`中都有一个字符串和变长参数作为参数，那么这个字符串的作用是什么呢？这个字符串是对要输入/输出的内容的描述，其中`%*`被称为“转换说明”，`%`与`*`之间的是转换说明修饰符。\n\n## 参数说明\n\n### 转换说明\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/zhuanhuan.jpg\" alt=\"转换说明\" style=\"zoom:67%;\" />\n\n### printf修饰符\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/xiushi.jpg\" alt=\"修饰符\" style=\"zoom:67%;\" />\n\n### printf标记\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/biaoji.jpg\" alt=\"标记\" style=\"zoom:67%;\" />\n\n### scanf修饰符\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/sxh.jpg\" alt=\"修饰符\" style=\"zoom:67%;\" />\n\n### printf与scanf中的`*`修饰符\n\n&emsp;&emsp;`printf`和`scanf`的修饰符中都可以使用`*`，但是他们的语义并不相同，我们写一段代码试一下：\n\n```c\n#include <stdio.h>\n\nint main() {\n    int temp, width;\n    scanf(\"%*d %d %*d %d\", &temp, &width);\n    printf(\"result:%0*d\", width, temp);\n    return 0;\n}\n```\n\n&emsp;&emsp;我们现在来模拟一下程序运行（`| `不是实际内容，只是为了分割文字介绍与程序内容）：\n\n```\n控制台输入：\t\t| 654 12 5689 20\nscanf读取：\t\t| 654 12 5689 20\n赋值：\t\t\t| temp = 12, width = 20\nprintf解析字符串：\t| result:%020d\nprintf打印：\t\t| 00000000000000000012\n```\n\n&emsp;&emsp;这里就能看出来规律了，`scanf`中使用`*`会让scanf跳过对该项的赋值，但是输入时仍需要输入该项。`printf`中使用`*`可以在运行时决定填入的数字为多少（示例中只替换了一个数，实际操作中任意数字型的修饰符都可以用`*`替换）。\n\n## 注意事项\n\n&emsp;&emsp;使用`scanf`与`printf`时一定要注意字符串内容要与参数列表相对应，否则轻则程序崩溃，重则带着错误信息继续运行（为什么说继续运行更严重呢，因为直接崩溃更容易定位错误位置）。为什么会这样呢？我们再回顾一下函数处理变长参数的方式：按照数据类型分割内存。\n\n&emsp;&emsp;但是这两个函数的变长参数列表传递进去的类型是任意的，所以无法直接判断应该从哪个地方分割内存。这时候字符串里面的信息就派上用场了，它可以告诉函数这个地方传递进去的值是什么类型。如果我们本应该输入`%d %d %d`但是却输入了`%d %lf %d`，那么从第二项开始，后面的所有项都会被错误的读取。\n\n# 无缓冲输入\n\n&emsp;&emsp;许多编译器都为无缓冲输入提供了特殊的函数，其原型都在`conio.h`中。在继续向下说之前我们再来说一下“回显”是什么。回显是当用户敲击键盘时在控制台显示用户输入的内容，无回显输入在使用时不会在控制台显示用户输入，这通常用来实现密码输入的功能。\n\n&emsp;&emsp;在`conio.h`提供的函数中，包括有回显无缓冲的`getchar()`、无回显无缓冲的`getch()`。在UNIX系统中使用另一种控制方式，UNXI系统使用`ioctil()`函数（该函数在UNIX库中但并不属于ANSI C）控制输入类型，然后使用`getchar()`进行操作。在ANSI C中则使用`setbuf()`和`setvbuf()`函数控制缓冲，但是受限于系统的内部设置，这些函数可能不起作用。总而言之就是ANSI C没有提供无缓冲输入的标准方式，能否进行无缓冲输入取决于操作系统。\n\n# putchar\n\n&emsp;&emsp;`putchar`在标准中没有定义有无缓冲，所以在不同编译器（甚至是同一个编译器的不同版本）中都可能会有不同的结果。注意下面这段代码：\n\n```C\n#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    putchar('a');\n    system(\"pause\");\n    return 0;\n}\n```\n\n&emsp;&emsp;在`GCC 4.9.2`中该代码得到下面的结果：\n\n```\na请按任意键继续。。。\n```\n\n&emsp;&emsp;而在`GCC 8.1.0`中则得到下面的结果：\n\n```\n请按任意键继续。。。\n\na\n```\n\n# 参考资料\n\n>1. 《C Primer Plus》相关章节\n>2. 菜鸟教程相关章节：[1](https://www.runoob.com/cprogramming/c-function-printf.html)、[2](https://www.runoob.com/cprogramming/c-function-scanf.html)\n>3. [c语言里缓冲区的理解-CSDN博客](https://blog.csdn.net/qq_36532097/article/details/70197061)\n\n\n\n\n\n\n\n","slug":"stdio","published":1,"updated":"2021-10-13T12:11:33.570Z","_id":"cku3ervps0002s0wqf8m1bmhl","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"scanf的使用\"><a href=\"#scanf的使用\" class=\"headerlink\" title=\"scanf的使用\"></a>scanf的使用</h1><p>&emsp;&emsp;<code>scanf</code>声明在<code>stdio.h</code>头文件中，其声明为<code>int scanf(const char \\*format, ...)</code>。从声明可以看出，<code>scanf</code>接收如下参数：</p>\n<ol>\n    <li>字符串：用于确定输入数据的类型</li>\n    <li>变长参数：用于输入需要进行写入的变量的地址</li>\n</ol>\n\n<p>&emsp;&emsp;其返回值为int类型，值为成功匹配和赋值的个数，如果到达文件末尾或发生读错误，则返回<code>EOF</code>。</p>\n<p>&emsp;&emsp;对于<code>scanf</code>的变长参数，等后面指针专题再讨论这个问题，现在只需要知道传参时非数组、指针类型需要在变量名前面加上<code>&amp;</code>。</p>\n<h2 id=\"EOF\"><a href=\"#EOF\" class=\"headerlink\" title=\"EOF\"></a>EOF</h2><p>&emsp;&emsp;<code>EOF</code>是<code>End Of File</code>的缩写，通常在文本最后由该字符表示结束。该值一般为<code>-1</code>，但是在不同编译器中该值的定义可能不同，不过不用担心，C在<code>stdio.h</code>中已经通过宏的方式定义了该常量。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n;<br>    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;n);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"printf的使用\"><a href=\"#printf的使用\" class=\"headerlink\" title=\"printf的使用\"></a>printf的使用</h1><p>&emsp;&emsp;<code>printf</code>也声明在<code>stdio.h</code>头文件中，其声明为<code>int printf(const char *format, ...)</code>。从声明可以看出，<code>printf</code>接收如下参数：</p>\n<ol>\n    <li>字符串：用于确定输出数据的类型</li>\n    <li>变长参数：用于输入需要打印的数据</li>\n</ol>\n\n<p>&emsp;&emsp;其返回值为int类型，值为写入的字符总数，如果写入失败则返回一个负数。</p>\n<h2 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">double</span> PI = <span class=\"hljs-number\">3.1415</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%f&quot;</span>, PI);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"变长参数\"><a href=\"#变长参数\" class=\"headerlink\" title=\"变长参数\"></a>变长参数</h1><div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#66ccff\">注：该章节不考虑编译器优化对参数传递方式的影响</font></div>\n\n<p>&emsp;&emsp;变长参数的本质就是一段连续的内存，我们用一个图解释一下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/bianchang.jpg\" alt=\"变长参数\"></p>\n<p>&emsp;&emsp;我们先来了解调用函数时是如何传参的，图中第一个对应的是函数<code>void example(int arg0, double arg1, short arg2)</code>的模型，在调用该函数时需要传入三个值，在传递时编译器会将要传入的值复制并排列到一起，然后传递给被调用的函数。函数使用时取用相应位置的内存即可。图中第二个对应的是函数<code>void example(char arg0[])</code>，传递方式和上面相同。</p>\n<p>&emsp;&emsp;第三个便是我们要说的变长参数，变长参数与普通传参不同的地方就在于传递的参数的数量是任意的，所以大多接受变长参数的函数都需要手动输入一个值表示变长参数的数量。</p>\n<h1 id=\"缓冲区\"><a href=\"#缓冲区\" class=\"headerlink\" title=\"缓冲区\"></a>缓冲区</h1><p>&emsp;&emsp;缓冲区是程序建立的一个内存空间，用于临时存储数据。其工作原理如图所示：（无缓冲输出就是把输入反过来）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/io.jpg\" alt=\"示意图\" style=\"zoom:80%;\"></p>\n<h2 id=\"缓冲区的意义\"><a href=\"#缓冲区的意义\" class=\"headerlink\" title=\"缓冲区的意义\"></a>缓冲区的意义</h2><p>&emsp;&emsp;为什么要有缓冲区？根据上图第一个无缓冲输入所示，程序从用户输入中逐个读取数据，在输入较多数据时这无疑是一种费时费力的方法，同时此时用户也无法修改自己输入的内容，因为当键盘敲下的时候数据就被读取了。有了缓冲区之后，不仅使用户可以修改自己输入的数据（按下回车之前的），同时也让程序可以成段的读取数据，减少了时间成本，输出同理。</p>\n<p>&emsp;&emsp;那么无缓冲区的输入/输出就没有用武之地了吗？并不是，例如在写控制台游戏时你是希望用户按下键盘时立即执行操作还是等待缓冲区刷新？为了加快游戏对用户输入的处理速度，我们当然会选择无缓冲的输入方式。<code>stdio.h</code>中的<code>stderr</code>同样使用的无缓冲输出，这样使得错误信息可以更快的打印到控制台，而不用等待缓冲刷新。</p>\n<p>&emsp;&emsp;缓冲区的大小取决于操作系统，常见的大小为512字节和4096字节。</p>\n<p>&emsp;&emsp;PS：我曾经用C++写过一个贪吃蛇，想试试的可以<a href=\"https://dwz.cn/yqe55Kal\">点击链接查看</a>，当时还不会用git所以就不要吐槽里面为什么都是压缩包了。还有一个<a href=\"https://www.bilibili.com/video/BV1Hb411g7i8/\">旧版的演示视频</a>。</p>\n<h2 id=\"缓冲区分类\"><a href=\"#缓冲区分类\" class=\"headerlink\" title=\"缓冲区分类\"></a>缓冲区分类</h2><p>&emsp;&emsp;缓冲区分为两类：完全缓冲I/O和行缓冲I/O。</p>\n<h3 id=\"完全缓冲\"><a href=\"#完全缓冲\" class=\"headerlink\" title=\"完全缓冲\"></a>完全缓冲</h3><p>&emsp;&emsp;完全缓冲是指只有当缓冲区被填满或手动触发缓冲区刷新时才会刷新缓冲区（即将数据内容发送至目的地），这种缓冲方式通常出现在文件I/O操作中。</p>\n<h3 id=\"行缓冲\"><a href=\"#行缓冲\" class=\"headerlink\" title=\"行缓冲\"></a>行缓冲</h3><p>&emsp;&emsp;行缓冲与完全缓冲不同的是其遇到换行符时便会刷新缓冲，键盘输入通常是行缓冲的方式，所以在摁下Enter键时程序才会开始处理数据。</p>\n<h2 id=\"缓冲区刷新方式\"><a href=\"#缓冲区刷新方式\" class=\"headerlink\" title=\"缓冲区刷新方式\"></a>缓冲区刷新方式</h2><p>&emsp;&emsp;除了上面提到的自动刷新缓冲区的方式，我们还可以使用代码强制刷新缓冲区，即<code>stdio.h</code>中的<code>int fflush(FILE *stream)</code>函数。该函数的参数是需要刷新缓冲区的流（标准输入流是：stdin，标准输出流是：stdout，标准错误输出流是：stderr）。C++中还能使用<code>endl</code>换行并刷新缓冲区。</p>\n<h1 id=\"有缓冲输入-输出\"><a href=\"#有缓冲输入-输出\" class=\"headerlink\" title=\"有缓冲输入/输出\"></a>有缓冲输入/输出</h1><p>&emsp;&emsp;平时我们使用的<code>scanf</code>和<code>printf</code>默认情况下都是有缓冲的。<code>scanf</code>和<code>printf</code>中都有一个字符串和变长参数作为参数，那么这个字符串的作用是什么呢？这个字符串是对要输入/输出的内容的描述，其中<code>%*</code>被称为“转换说明”，<code>%</code>与<code>*</code>之间的是转换说明修饰符。</p>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><h3 id=\"转换说明\"><a href=\"#转换说明\" class=\"headerlink\" title=\"转换说明\"></a>转换说明</h3><p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/zhuanhuan.jpg\" alt=\"转换说明\" style=\"zoom:67%;\"></p>\n<h3 id=\"printf修饰符\"><a href=\"#printf修饰符\" class=\"headerlink\" title=\"printf修饰符\"></a>printf修饰符</h3><p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/xiushi.jpg\" alt=\"修饰符\" style=\"zoom:67%;\"></p>\n<h3 id=\"printf标记\"><a href=\"#printf标记\" class=\"headerlink\" title=\"printf标记\"></a>printf标记</h3><p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/biaoji.jpg\" alt=\"标记\" style=\"zoom:67%;\"></p>\n<h3 id=\"scanf修饰符\"><a href=\"#scanf修饰符\" class=\"headerlink\" title=\"scanf修饰符\"></a>scanf修饰符</h3><p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/sxh.jpg\" alt=\"修饰符\" style=\"zoom:67%;\"></p>\n<h3 id=\"printf与scanf中的-修饰符\"><a href=\"#printf与scanf中的-修饰符\" class=\"headerlink\" title=\"printf与scanf中的*修饰符\"></a>printf与scanf中的<code>*</code>修饰符</h3><p>&emsp;&emsp;<code>printf</code>和<code>scanf</code>的修饰符中都可以使用<code>*</code>，但是他们的语义并不相同，我们写一段代码试一下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> temp, width;<br>    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%*d %d %*d %d&quot;</span>, &amp;temp, &amp;width);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;result:%0*d&quot;</span>, width, temp);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在来模拟一下程序运行（<code>|</code>不是实际内容，只是为了分割文字介绍与程序内容）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">控制台输入：\t\t| 654 12 5689 20<br>scanf读取：\t\t| 654 12 5689 20<br>赋值：\t\t\t| temp = 12, width = 20<br>printf解析字符串：\t| result:%020d<br>printf打印：\t\t| 00000000000000000012<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这里就能看出来规律了，<code>scanf</code>中使用<code>*</code>会让scanf跳过对该项的赋值，但是输入时仍需要输入该项。<code>printf</code>中使用<code>*</code>可以在运行时决定填入的数字为多少（示例中只替换了一个数，实际操作中任意数字型的修饰符都可以用<code>*</code>替换）。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>&emsp;&emsp;使用<code>scanf</code>与<code>printf</code>时一定要注意字符串内容要与参数列表相对应，否则轻则程序崩溃，重则带着错误信息继续运行（为什么说继续运行更严重呢，因为直接崩溃更容易定位错误位置）。为什么会这样呢？我们再回顾一下函数处理变长参数的方式：按照数据类型分割内存。</p>\n<p>&emsp;&emsp;但是这两个函数的变长参数列表传递进去的类型是任意的，所以无法直接判断应该从哪个地方分割内存。这时候字符串里面的信息就派上用场了，它可以告诉函数这个地方传递进去的值是什么类型。如果我们本应该输入<code>%d %d %d</code>但是却输入了<code>%d %lf %d</code>，那么从第二项开始，后面的所有项都会被错误的读取。</p>\n<h1 id=\"无缓冲输入\"><a href=\"#无缓冲输入\" class=\"headerlink\" title=\"无缓冲输入\"></a>无缓冲输入</h1><p>&emsp;&emsp;许多编译器都为无缓冲输入提供了特殊的函数，其原型都在<code>conio.h</code>中。在继续向下说之前我们再来说一下“回显”是什么。回显是当用户敲击键盘时在控制台显示用户输入的内容，无回显输入在使用时不会在控制台显示用户输入，这通常用来实现密码输入的功能。</p>\n<p>&emsp;&emsp;在<code>conio.h</code>提供的函数中，包括有回显无缓冲的<code>getchar()</code>、无回显无缓冲的<code>getch()</code>。在UNIX系统中使用另一种控制方式，UNXI系统使用<code>ioctil()</code>函数（该函数在UNIX库中但并不属于ANSI C）控制输入类型，然后使用<code>getchar()</code>进行操作。在ANSI C中则使用<code>setbuf()</code>和<code>setvbuf()</code>函数控制缓冲，但是受限于系统的内部设置，这些函数可能不起作用。总而言之就是ANSI C没有提供无缓冲输入的标准方式，能否进行无缓冲输入取决于操作系统。</p>\n<h1 id=\"putchar\"><a href=\"#putchar\" class=\"headerlink\" title=\"putchar\"></a>putchar</h1><p>&emsp;&emsp;<code>putchar</code>在标准中没有定义有无缓冲，所以在不同编译器（甚至是同一个编译器的不同版本）中都可能会有不同的结果。注意下面这段代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdlib.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-built_in\">putchar</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br>    system(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在<code>GCC 4.9.2</code>中该代码得到下面的结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">a请按任意键继续。。。<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;而在<code>GCC 8.1.0</code>中则得到下面的结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">请按任意键继续。。。<br><br>a<br></code></pre></td></tr></table></figure>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ol>\n<li>《C Primer Plus》相关章节</li>\n<li>菜鸟教程相关章节：<a href=\"https://www.runoob.com/cprogramming/c-function-printf.html\">1</a>、<a href=\"https://www.runoob.com/cprogramming/c-function-scanf.html\">2</a></li>\n<li><a href=\"https://blog.csdn.net/qq_36532097/article/details/70197061\">c语言里缓冲区的理解-CSDN博客</a></li>\n</ol>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"},{"name":"Akilar店长","link":"https://akilar.top","avatar":"https://akilar.top/img/siteicon/favicon.png","descr":"欢迎光临糖果屋","siteshot":"https://cdn.jsdelivr.net/gh/Akilarlxh/ScreenShot@gh-pages/akilar.top.jpg"}]}]}},"excerpt":"","more":"<h1 id=\"scanf的使用\"><a href=\"#scanf的使用\" class=\"headerlink\" title=\"scanf的使用\"></a>scanf的使用</h1><p>&emsp;&emsp;<code>scanf</code>声明在<code>stdio.h</code>头文件中，其声明为<code>int scanf(const char \\*format, ...)</code>。从声明可以看出，<code>scanf</code>接收如下参数：</p>\n<ol>\n    <li>字符串：用于确定输入数据的类型</li>\n    <li>变长参数：用于输入需要进行写入的变量的地址</li>\n</ol>\n\n<p>&emsp;&emsp;其返回值为int类型，值为成功匹配和赋值的个数，如果到达文件末尾或发生读错误，则返回<code>EOF</code>。</p>\n<p>&emsp;&emsp;对于<code>scanf</code>的变长参数，等后面指针专题再讨论这个问题，现在只需要知道传参时非数组、指针类型需要在变量名前面加上<code>&amp;</code>。</p>\n<h2 id=\"EOF\"><a href=\"#EOF\" class=\"headerlink\" title=\"EOF\"></a>EOF</h2><p>&emsp;&emsp;<code>EOF</code>是<code>End Of File</code>的缩写，通常在文本最后由该字符表示结束。该值一般为<code>-1</code>，但是在不同编译器中该值的定义可能不同，不过不用担心，C在<code>stdio.h</code>中已经通过宏的方式定义了该常量。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n;<br>    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;n);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"printf的使用\"><a href=\"#printf的使用\" class=\"headerlink\" title=\"printf的使用\"></a>printf的使用</h1><p>&emsp;&emsp;<code>printf</code>也声明在<code>stdio.h</code>头文件中，其声明为<code>int printf(const char *format, ...)</code>。从声明可以看出，<code>printf</code>接收如下参数：</p>\n<ol>\n    <li>字符串：用于确定输出数据的类型</li>\n    <li>变长参数：用于输入需要打印的数据</li>\n</ol>\n\n<p>&emsp;&emsp;其返回值为int类型，值为写入的字符总数，如果写入失败则返回一个负数。</p>\n<h2 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">double</span> PI = <span class=\"hljs-number\">3.1415</span>;<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%f&quot;</span>, PI);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"变长参数\"><a href=\"#变长参数\" class=\"headerlink\" title=\"变长参数\"></a>变长参数</h1><div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#66ccff\">注：该章节不考虑编译器优化对参数传递方式的影响</font></div>\n\n<p>&emsp;&emsp;变长参数的本质就是一段连续的内存，我们用一个图解释一下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/bianchang.jpg\" alt=\"变长参数\"></p>\n<p>&emsp;&emsp;我们先来了解调用函数时是如何传参的，图中第一个对应的是函数<code>void example(int arg0, double arg1, short arg2)</code>的模型，在调用该函数时需要传入三个值，在传递时编译器会将要传入的值复制并排列到一起，然后传递给被调用的函数。函数使用时取用相应位置的内存即可。图中第二个对应的是函数<code>void example(char arg0[])</code>，传递方式和上面相同。</p>\n<p>&emsp;&emsp;第三个便是我们要说的变长参数，变长参数与普通传参不同的地方就在于传递的参数的数量是任意的，所以大多接受变长参数的函数都需要手动输入一个值表示变长参数的数量。</p>\n<h1 id=\"缓冲区\"><a href=\"#缓冲区\" class=\"headerlink\" title=\"缓冲区\"></a>缓冲区</h1><p>&emsp;&emsp;缓冲区是程序建立的一个内存空间，用于临时存储数据。其工作原理如图所示：（无缓冲输出就是把输入反过来）</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/io.jpg\" alt=\"示意图\" style=\"zoom:80%;\"></p>\n<h2 id=\"缓冲区的意义\"><a href=\"#缓冲区的意义\" class=\"headerlink\" title=\"缓冲区的意义\"></a>缓冲区的意义</h2><p>&emsp;&emsp;为什么要有缓冲区？根据上图第一个无缓冲输入所示，程序从用户输入中逐个读取数据，在输入较多数据时这无疑是一种费时费力的方法，同时此时用户也无法修改自己输入的内容，因为当键盘敲下的时候数据就被读取了。有了缓冲区之后，不仅使用户可以修改自己输入的数据（按下回车之前的），同时也让程序可以成段的读取数据，减少了时间成本，输出同理。</p>\n<p>&emsp;&emsp;那么无缓冲区的输入/输出就没有用武之地了吗？并不是，例如在写控制台游戏时你是希望用户按下键盘时立即执行操作还是等待缓冲区刷新？为了加快游戏对用户输入的处理速度，我们当然会选择无缓冲的输入方式。<code>stdio.h</code>中的<code>stderr</code>同样使用的无缓冲输出，这样使得错误信息可以更快的打印到控制台，而不用等待缓冲刷新。</p>\n<p>&emsp;&emsp;缓冲区的大小取决于操作系统，常见的大小为512字节和4096字节。</p>\n<p>&emsp;&emsp;PS：我曾经用C++写过一个贪吃蛇，想试试的可以<a href=\"https://dwz.cn/yqe55Kal\">点击链接查看</a>，当时还不会用git所以就不要吐槽里面为什么都是压缩包了。还有一个<a href=\"https://www.bilibili.com/video/BV1Hb411g7i8/\">旧版的演示视频</a>。</p>\n<h2 id=\"缓冲区分类\"><a href=\"#缓冲区分类\" class=\"headerlink\" title=\"缓冲区分类\"></a>缓冲区分类</h2><p>&emsp;&emsp;缓冲区分为两类：完全缓冲I/O和行缓冲I/O。</p>\n<h3 id=\"完全缓冲\"><a href=\"#完全缓冲\" class=\"headerlink\" title=\"完全缓冲\"></a>完全缓冲</h3><p>&emsp;&emsp;完全缓冲是指只有当缓冲区被填满或手动触发缓冲区刷新时才会刷新缓冲区（即将数据内容发送至目的地），这种缓冲方式通常出现在文件I/O操作中。</p>\n<h3 id=\"行缓冲\"><a href=\"#行缓冲\" class=\"headerlink\" title=\"行缓冲\"></a>行缓冲</h3><p>&emsp;&emsp;行缓冲与完全缓冲不同的是其遇到换行符时便会刷新缓冲，键盘输入通常是行缓冲的方式，所以在摁下Enter键时程序才会开始处理数据。</p>\n<h2 id=\"缓冲区刷新方式\"><a href=\"#缓冲区刷新方式\" class=\"headerlink\" title=\"缓冲区刷新方式\"></a>缓冲区刷新方式</h2><p>&emsp;&emsp;除了上面提到的自动刷新缓冲区的方式，我们还可以使用代码强制刷新缓冲区，即<code>stdio.h</code>中的<code>int fflush(FILE *stream)</code>函数。该函数的参数是需要刷新缓冲区的流（标准输入流是：stdin，标准输出流是：stdout，标准错误输出流是：stderr）。C++中还能使用<code>endl</code>换行并刷新缓冲区。</p>\n<h1 id=\"有缓冲输入-输出\"><a href=\"#有缓冲输入-输出\" class=\"headerlink\" title=\"有缓冲输入/输出\"></a>有缓冲输入/输出</h1><p>&emsp;&emsp;平时我们使用的<code>scanf</code>和<code>printf</code>默认情况下都是有缓冲的。<code>scanf</code>和<code>printf</code>中都有一个字符串和变长参数作为参数，那么这个字符串的作用是什么呢？这个字符串是对要输入/输出的内容的描述，其中<code>%*</code>被称为“转换说明”，<code>%</code>与<code>*</code>之间的是转换说明修饰符。</p>\n<h2 id=\"参数说明\"><a href=\"#参数说明\" class=\"headerlink\" title=\"参数说明\"></a>参数说明</h2><h3 id=\"转换说明\"><a href=\"#转换说明\" class=\"headerlink\" title=\"转换说明\"></a>转换说明</h3><p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/zhuanhuan.jpg\" alt=\"转换说明\" style=\"zoom:67%;\"></p>\n<h3 id=\"printf修饰符\"><a href=\"#printf修饰符\" class=\"headerlink\" title=\"printf修饰符\"></a>printf修饰符</h3><p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/xiushi.jpg\" alt=\"修饰符\" style=\"zoom:67%;\"></p>\n<h3 id=\"printf标记\"><a href=\"#printf标记\" class=\"headerlink\" title=\"printf标记\"></a>printf标记</h3><p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/biaoji.jpg\" alt=\"标记\" style=\"zoom:67%;\"></p>\n<h3 id=\"scanf修饰符\"><a href=\"#scanf修饰符\" class=\"headerlink\" title=\"scanf修饰符\"></a>scanf修饰符</h3><p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/stdio/sxh.jpg\" alt=\"修饰符\" style=\"zoom:67%;\"></p>\n<h3 id=\"printf与scanf中的-修饰符\"><a href=\"#printf与scanf中的-修饰符\" class=\"headerlink\" title=\"printf与scanf中的*修饰符\"></a>printf与scanf中的<code>*</code>修饰符</h3><p>&emsp;&emsp;<code>printf</code>和<code>scanf</code>的修饰符中都可以使用<code>*</code>，但是他们的语义并不相同，我们写一段代码试一下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> temp, width;<br>    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%*d %d %*d %d&quot;</span>, &amp;temp, &amp;width);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;result:%0*d&quot;</span>, width, temp);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们现在来模拟一下程序运行（<code>|</code>不是实际内容，只是为了分割文字介绍与程序内容）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">控制台输入：\t\t| 654 12 5689 20<br>scanf读取：\t\t| 654 12 5689 20<br>赋值：\t\t\t| temp = 12, width = 20<br>printf解析字符串：\t| result:%020d<br>printf打印：\t\t| 00000000000000000012<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这里就能看出来规律了，<code>scanf</code>中使用<code>*</code>会让scanf跳过对该项的赋值，但是输入时仍需要输入该项。<code>printf</code>中使用<code>*</code>可以在运行时决定填入的数字为多少（示例中只替换了一个数，实际操作中任意数字型的修饰符都可以用<code>*</code>替换）。</p>\n<h2 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h2><p>&emsp;&emsp;使用<code>scanf</code>与<code>printf</code>时一定要注意字符串内容要与参数列表相对应，否则轻则程序崩溃，重则带着错误信息继续运行（为什么说继续运行更严重呢，因为直接崩溃更容易定位错误位置）。为什么会这样呢？我们再回顾一下函数处理变长参数的方式：按照数据类型分割内存。</p>\n<p>&emsp;&emsp;但是这两个函数的变长参数列表传递进去的类型是任意的，所以无法直接判断应该从哪个地方分割内存。这时候字符串里面的信息就派上用场了，它可以告诉函数这个地方传递进去的值是什么类型。如果我们本应该输入<code>%d %d %d</code>但是却输入了<code>%d %lf %d</code>，那么从第二项开始，后面的所有项都会被错误的读取。</p>\n<h1 id=\"无缓冲输入\"><a href=\"#无缓冲输入\" class=\"headerlink\" title=\"无缓冲输入\"></a>无缓冲输入</h1><p>&emsp;&emsp;许多编译器都为无缓冲输入提供了特殊的函数，其原型都在<code>conio.h</code>中。在继续向下说之前我们再来说一下“回显”是什么。回显是当用户敲击键盘时在控制台显示用户输入的内容，无回显输入在使用时不会在控制台显示用户输入，这通常用来实现密码输入的功能。</p>\n<p>&emsp;&emsp;在<code>conio.h</code>提供的函数中，包括有回显无缓冲的<code>getchar()</code>、无回显无缓冲的<code>getch()</code>。在UNIX系统中使用另一种控制方式，UNXI系统使用<code>ioctil()</code>函数（该函数在UNIX库中但并不属于ANSI C）控制输入类型，然后使用<code>getchar()</code>进行操作。在ANSI C中则使用<code>setbuf()</code>和<code>setvbuf()</code>函数控制缓冲，但是受限于系统的内部设置，这些函数可能不起作用。总而言之就是ANSI C没有提供无缓冲输入的标准方式，能否进行无缓冲输入取决于操作系统。</p>\n<h1 id=\"putchar\"><a href=\"#putchar\" class=\"headerlink\" title=\"putchar\"></a>putchar</h1><p>&emsp;&emsp;<code>putchar</code>在标准中没有定义有无缓冲，所以在不同编译器（甚至是同一个编译器的不同版本）中都可能会有不同的结果。注意下面这段代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdlib.h&gt;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-built_in\">putchar</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>);<br>    system(<span class=\"hljs-string\">&quot;pause&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;在<code>GCC 4.9.2</code>中该代码得到下面的结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">a请按任意键继续。。。<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;而在<code>GCC 8.1.0</code>中则得到下面的结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">请按任意键继续。。。<br><br>a<br></code></pre></td></tr></table></figure>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<ol>\n<li>《C Primer Plus》相关章节</li>\n<li>菜鸟教程相关章节：<a href=\"https://www.runoob.com/cprogramming/c-function-printf.html\">1</a>、<a href=\"https://www.runoob.com/cprogramming/c-function-scanf.html\">2</a></li>\n<li><a href=\"https://blog.csdn.net/qq_36532097/article/details/70197061\">c语言里缓冲区的理解-CSDN博客</a></li>\n</ol>\n</blockquote>\n"},{"title":"形象的简述电流","date":"2021-09-30T12:35:53.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b11.jpeg","description":"使用“小球模型”简述电流的本质","_content":"\n\n\n# 电流的本质\n\n&emsp;&emsp;电流是由带电粒子的定向运动形成，电流的大小指的是单位之间内通过横截面积的电荷量。\n\n## 金属导电的原理\n\n&emsp;&emsp;所有物质都由分子或原子组成，分子是由原子组成的，每个原子由原子核与核外电子组成，其中原子核带正电，核外电子带负电。金属导线导电的原理是金属中分布着自由电子，自由电子是不绕核运动的电子，在没有电流需要通过时，这些自由电子做不规则运动，而当有电流要通过时，这些电子在力的作用下定向移动从而形成电流。\n\n# 模型定义\n\n|  名称  |                   介绍                   |\n| :----: | :--------------------------------------: |\n|  管道  |            承载小球，代指导线            |\n|  小球  |                 代指电子                 |\n| 发动机 | 给经过的小球提供恒定的动力，代指理想电源 |\n|  阻力  |      小球运动时受到的阻力，代指电阻      |\n\n\n\n<div class=\"text\" style=\" text-align:center;\"><font color=\"#66ccff\">注：该模型不保证所有内容与本质完全相同，只是为了让小白大致了解电路中的一些结论！</font></div>\n\n# 模型描述\n\n&emsp;&emsp;首先，让我们搭建一条简单的线路（因为绘图的问题，所以有些小球看起来并不是紧贴在一起，当作是贴在一起毫无缝隙就行）：\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/current/jiandan.png\" alt=\"示例\" style=\"zoom:67%;\" />\n\n## 电流等大原则\n\n&emsp;&emsp;“**串联电路电流处处相等**”这句话该如何理解？其实很简单，所有小球都是贴在一起的，只要有一个小球速度变慢，那么所有的小球都会受到影响。在小球经过灯泡时受到的阻力增大，速度随之降低，从而使其它小球也受到影响。\n\n&emsp;&emsp;“**并联电路支路电流之和等于干路电流**”这句话同理，在小球运动到管道的分岔口时会被分割到各个支路中，那么各个之路的单位时间通过横截面的小球数量之和便等于分割前的数量。还记得电流的定义吗？**电流是单位时间内通过横截面的电荷数量**，小球数量减少了，电流自然也会减小，而所有支路单位时间内通过横截面小球数量加起来，正好等于干路上的数量。\n\n## 短路\n\n&emsp;&emsp;阻力越大，小球运动的速度越慢，当阻力非常小的时候（比如没有任何用电器），小球运动的速度就会非常快，这时候小球与管壁摩擦就会产生大量的热量（当然电流产热不是因为电荷与导线摩擦），发动机的工作效率也会不受限制的提高，产热也会随之增大，这个热量甚至可以烧坏发动机和管道。\n\n## 断路\n\n&emsp;&emsp;为什么断路的时候不会有电流？因为断路时，发动机只能发出小球而不能受到小球，没有小球时便无法继续推动其它小球运动，自然就没有电流了。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/current.md","raw":"---\ntitle: 形象的简述电流\ndate: 2021-09-30 20:35:53\ncategories:\n  - 物理\ntags:\n  - 电流\n  - 教程\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b11.jpeg\ndescription: 使用“小球模型”简述电流的本质\n---\n\n\n\n# 电流的本质\n\n&emsp;&emsp;电流是由带电粒子的定向运动形成，电流的大小指的是单位之间内通过横截面积的电荷量。\n\n## 金属导电的原理\n\n&emsp;&emsp;所有物质都由分子或原子组成，分子是由原子组成的，每个原子由原子核与核外电子组成，其中原子核带正电，核外电子带负电。金属导线导电的原理是金属中分布着自由电子，自由电子是不绕核运动的电子，在没有电流需要通过时，这些自由电子做不规则运动，而当有电流要通过时，这些电子在力的作用下定向移动从而形成电流。\n\n# 模型定义\n\n|  名称  |                   介绍                   |\n| :----: | :--------------------------------------: |\n|  管道  |            承载小球，代指导线            |\n|  小球  |                 代指电子                 |\n| 发动机 | 给经过的小球提供恒定的动力，代指理想电源 |\n|  阻力  |      小球运动时受到的阻力，代指电阻      |\n\n\n\n<div class=\"text\" style=\" text-align:center;\"><font color=\"#66ccff\">注：该模型不保证所有内容与本质完全相同，只是为了让小白大致了解电路中的一些结论！</font></div>\n\n# 模型描述\n\n&emsp;&emsp;首先，让我们搭建一条简单的线路（因为绘图的问题，所以有些小球看起来并不是紧贴在一起，当作是贴在一起毫无缝隙就行）：\n\n<img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/current/jiandan.png\" alt=\"示例\" style=\"zoom:67%;\" />\n\n## 电流等大原则\n\n&emsp;&emsp;“**串联电路电流处处相等**”这句话该如何理解？其实很简单，所有小球都是贴在一起的，只要有一个小球速度变慢，那么所有的小球都会受到影响。在小球经过灯泡时受到的阻力增大，速度随之降低，从而使其它小球也受到影响。\n\n&emsp;&emsp;“**并联电路支路电流之和等于干路电流**”这句话同理，在小球运动到管道的分岔口时会被分割到各个支路中，那么各个之路的单位时间通过横截面的小球数量之和便等于分割前的数量。还记得电流的定义吗？**电流是单位时间内通过横截面的电荷数量**，小球数量减少了，电流自然也会减小，而所有支路单位时间内通过横截面小球数量加起来，正好等于干路上的数量。\n\n## 短路\n\n&emsp;&emsp;阻力越大，小球运动的速度越慢，当阻力非常小的时候（比如没有任何用电器），小球运动的速度就会非常快，这时候小球与管壁摩擦就会产生大量的热量（当然电流产热不是因为电荷与导线摩擦），发动机的工作效率也会不受限制的提高，产热也会随之增大，这个热量甚至可以烧坏发动机和管道。\n\n## 断路\n\n&emsp;&emsp;为什么断路的时候不会有电流？因为断路时，发动机只能发出小球而不能受到小球，没有小球时便无法继续推动其它小球运动，自然就没有电流了。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"current","published":1,"updated":"2021-10-03T07:49:46.300Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckunqfwod0000cwwq9mgsfa9s","content":"<h1 id=\"电流的本质\"><a href=\"#电流的本质\" class=\"headerlink\" title=\"电流的本质\"></a>电流的本质</h1><p>&emsp;&emsp;电流是由带电粒子的定向运动形成，电流的大小指的是单位之间内通过横截面积的电荷量。</p>\n<h2 id=\"金属导电的原理\"><a href=\"#金属导电的原理\" class=\"headerlink\" title=\"金属导电的原理\"></a>金属导电的原理</h2><p>&emsp;&emsp;所有物质都由分子或原子组成，分子是由原子组成的，每个原子由原子核与核外电子组成，其中原子核带正电，核外电子带负电。金属导线导电的原理是金属中分布着自由电子，自由电子是不绕核运动的电子，在没有电流需要通过时，这些自由电子做不规则运动，而当有电流要通过时，这些电子在力的作用下定向移动从而形成电流。</p>\n<h1 id=\"模型定义\"><a href=\"#模型定义\" class=\"headerlink\" title=\"模型定义\"></a>模型定义</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">管道</td>\n<td style=\"text-align:center\">承载小球，代指导线</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">小球</td>\n<td style=\"text-align:center\">代指电子</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">发动机</td>\n<td style=\"text-align:center\">给经过的小球提供恒定的动力，代指理想电源</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阻力</td>\n<td style=\"text-align:center\">小球运动时受到的阻力，代指电阻</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"text\" style=\" text-align:center;\"><font color=\"#66ccff\">注：该模型不保证所有内容与本质完全相同，只是为了让小白大致了解电路中的一些结论！</font></div>\n\n<h1 id=\"模型描述\"><a href=\"#模型描述\" class=\"headerlink\" title=\"模型描述\"></a>模型描述</h1><p>&emsp;&emsp;首先，让我们搭建一条简单的线路（因为绘图的问题，所以有些小球看起来并不是紧贴在一起，当作是贴在一起毫无缝隙就行）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/current/jiandan.png\" alt=\"示例\" style=\"zoom:67%;\"></p>\n<h2 id=\"电流等大原则\"><a href=\"#电流等大原则\" class=\"headerlink\" title=\"电流等大原则\"></a>电流等大原则</h2><p>&emsp;&emsp;“<strong>串联电路电流处处相等</strong>”这句话该如何理解？其实很简单，所有小球都是贴在一起的，只要有一个小球速度变慢，那么所有的小球都会受到影响。在小球经过灯泡时受到的阻力增大，速度随之降低，从而使其它小球也受到影响。</p>\n<p>&emsp;&emsp;“<strong>并联电路支路电流之和等于干路电流</strong>”这句话同理，在小球运动到管道的分岔口时会被分割到各个支路中，那么各个之路的单位时间通过横截面的小球数量之和便等于分割前的数量。还记得电流的定义吗？<strong>电流是单位时间内通过横截面的电荷数量</strong>，小球数量减少了，电流自然也会减小，而所有支路单位时间内通过横截面小球数量加起来，正好等于干路上的数量。</p>\n<h2 id=\"短路\"><a href=\"#短路\" class=\"headerlink\" title=\"短路\"></a>短路</h2><p>&emsp;&emsp;阻力越大，小球运动的速度越慢，当阻力非常小的时候（比如没有任何用电器），小球运动的速度就会非常快，这时候小球与管壁摩擦就会产生大量的热量（当然电流产热不是因为电荷与导线摩擦），发动机的工作效率也会不受限制的提高，产热也会随之增大，这个热量甚至可以烧坏发动机和管道。</p>\n<h2 id=\"断路\"><a href=\"#断路\" class=\"headerlink\" title=\"断路\"></a>断路</h2><p>&emsp;&emsp;为什么断路的时候不会有电流？因为断路时，发动机只能发出小球而不能受到小球，没有小球时便无法继续推动其它小球运动，自然就没有电流了。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"}]}]}},"excerpt":"","more":"<h1 id=\"电流的本质\"><a href=\"#电流的本质\" class=\"headerlink\" title=\"电流的本质\"></a>电流的本质</h1><p>&emsp;&emsp;电流是由带电粒子的定向运动形成，电流的大小指的是单位之间内通过横截面积的电荷量。</p>\n<h2 id=\"金属导电的原理\"><a href=\"#金属导电的原理\" class=\"headerlink\" title=\"金属导电的原理\"></a>金属导电的原理</h2><p>&emsp;&emsp;所有物质都由分子或原子组成，分子是由原子组成的，每个原子由原子核与核外电子组成，其中原子核带正电，核外电子带负电。金属导线导电的原理是金属中分布着自由电子，自由电子是不绕核运动的电子，在没有电流需要通过时，这些自由电子做不规则运动，而当有电流要通过时，这些电子在力的作用下定向移动从而形成电流。</p>\n<h1 id=\"模型定义\"><a href=\"#模型定义\" class=\"headerlink\" title=\"模型定义\"></a>模型定义</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">管道</td>\n<td style=\"text-align:center\">承载小球，代指导线</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">小球</td>\n<td style=\"text-align:center\">代指电子</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">发动机</td>\n<td style=\"text-align:center\">给经过的小球提供恒定的动力，代指理想电源</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">阻力</td>\n<td style=\"text-align:center\">小球运动时受到的阻力，代指电阻</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"text\" style=\" text-align:center;\"><font color=\"#66ccff\">注：该模型不保证所有内容与本质完全相同，只是为了让小白大致了解电路中的一些结论！</font></div>\n\n<h1 id=\"模型描述\"><a href=\"#模型描述\" class=\"headerlink\" title=\"模型描述\"></a>模型描述</h1><p>&emsp;&emsp;首先，让我们搭建一条简单的线路（因为绘图的问题，所以有些小球看起来并不是紧贴在一起，当作是贴在一起毫无缝隙就行）：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/current/jiandan.png\" alt=\"示例\" style=\"zoom:67%;\"></p>\n<h2 id=\"电流等大原则\"><a href=\"#电流等大原则\" class=\"headerlink\" title=\"电流等大原则\"></a>电流等大原则</h2><p>&emsp;&emsp;“<strong>串联电路电流处处相等</strong>”这句话该如何理解？其实很简单，所有小球都是贴在一起的，只要有一个小球速度变慢，那么所有的小球都会受到影响。在小球经过灯泡时受到的阻力增大，速度随之降低，从而使其它小球也受到影响。</p>\n<p>&emsp;&emsp;“<strong>并联电路支路电流之和等于干路电流</strong>”这句话同理，在小球运动到管道的分岔口时会被分割到各个支路中，那么各个之路的单位时间通过横截面的小球数量之和便等于分割前的数量。还记得电流的定义吗？<strong>电流是单位时间内通过横截面的电荷数量</strong>，小球数量减少了，电流自然也会减小，而所有支路单位时间内通过横截面小球数量加起来，正好等于干路上的数量。</p>\n<h2 id=\"短路\"><a href=\"#短路\" class=\"headerlink\" title=\"短路\"></a>短路</h2><p>&emsp;&emsp;阻力越大，小球运动的速度越慢，当阻力非常小的时候（比如没有任何用电器），小球运动的速度就会非常快，这时候小球与管壁摩擦就会产生大量的热量（当然电流产热不是因为电荷与导线摩擦），发动机的工作效率也会不受限制的提高，产热也会随之增大，这个热量甚至可以烧坏发动机和管道。</p>\n<h2 id=\"断路\"><a href=\"#断路\" class=\"headerlink\" title=\"断路\"></a>断路</h2><p>&emsp;&emsp;为什么断路的时候不会有电流？因为断路时，发动机只能发出小球而不能受到小球，没有小球时便无法继续推动其它小球运动，自然就没有电流了。</p>\n"},{"title":"关于C语言编码的一些建议","date":"2021-10-12T12:14:05.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b12.jpeg","description":"简单总结一下我对一些代码的建议。","_content":"\n# 前言\n\n&emsp;&emsp;这篇文章可以看作对我之前写的“[浅读C语言代码规范](https://blog.emptydreams.xyz/c_standard)”的一些补充，但是本篇内容仅个人看法，具体是否采用还需读者自己评估。\n\n&emsp;&emsp;该文内容不定时补充，为了看过旧版内容的读者更方便，新的内容会放在前面。\n\n---\n\n# [2021-10-13]\n\n## goto语句的使用\n\n&emsp;&emsp;`goto`是`C/C++`中一个强大的功能，但是由于其功能过于强大，容易引发各种各样的问题，且会导致程序的控制流难以追踪，并不推荐使用。绝大多数情况下，任何能用其它语句代替的`goto`都不应当使用`goto`编写，除非是使用`goto`来跳出外部循环。\n\n## 善用快捷键\n\n&emsp;&emsp;善用系统和IDE的快捷键可以让我们的编码速度更快，也可以更便捷的进行调试等操作。如果是JBS平台的用户，可以安装`Key Promoter X`这个插件，在你用鼠标进行操作时会提醒你对应的快捷键是什么，如果你频繁进行某项操作但其没有快捷键，它也会提醒你可以自己设置一个快捷键。\n\n---\n\n# [2021-10-12]\n\n## 变量声明位置\n\n&emsp;&emsp;在`C99`（不了解C90、C99、C11是什么的话自行百度一下）之前，C语言要求函数内的变量必须在函数头声明。这一方面虽然可以通过函数头的变量说明函数的大致内容，但是也造成了一些麻烦：\n\n<ul>\n    <li>编码时经常需要从当前编辑的地方回到函数头补上需要用到的变量声明</li>\n    <li>容易忘记赋初值</li>\n    <li>某些变量只需用到一次，写在开头反而更乱</li>\n</ul>\n\n&emsp;&emsp;自`C99`开始，C语言取消了这一限制，变量的声明可以写在函数中的任意位置（前提是符合语法）。个人更倾向于就近原则，即使用时再声明。\n\n&emsp;&emsp;如果读者想要使用前一种方式的话，我也推荐将临时用到的变量声明（比如`for循环`中用到的控制变量）在使用的位置，这样子可以让代码更直观。\n\n## 布尔类型\n\n&emsp;&emsp;C语言中经常使用`int`来表示真假。比如下面的代码：\n\n```C\nint main() {\n    int k = 0;\n    if (k) {\n        printf(\"true\");\n    } else {\n        printf(\"false\");\n    }\n    return 0;\n}\n```\n\n&emsp;&emsp;上面的代码完全可以正常运行，但是这实际上是一种非常麻烦并且容易出错的写法。首先，编码的人和阅读的人都需要思考，到底`0`和`1`哪一个代表`true`。其次，在复杂一些的环境中，这种写法会令人难以快速排出错误。\n\n&emsp;&emsp;如何避免上述的问题？其实很简单，使用C语言的库中提供的`_Bool`即可，该类型只有`true`和`false`两个值，并且英文单词比单个数字更加直观易懂。如果嫌`_Bool`打起来麻烦的话，可以使用`stdbool.h`头文件中定义的`bool`。\n\n## 统一代码风格\n\n&emsp;&emsp;如果你的代码中使用了某一种代码风格，那么，请在程序中保持这个风格，不同风格的代码混杂在一起相当于没有规范的代码。\n\n## 读懂编译报错\n\n&emsp;&emsp;如果代码存在编译错误，编译器会给出错误信息，这些信息通常是英文，如果你看不懂的话不妨把信息复制到网络上搜索一下，很容易就能找到问题原因和解决方法。\n\n&emsp;&emsp;这里强调一点，编译错误是编码过程中最容易解决的错误（除了IDE判断错误导致报错位置或信息不对的情况），遇到编译错误一定要自己想办法解决。\n\n---\n\n# 提问的艺术\n\n&emsp;&emsp;这个问题其实不应该出现在这里，但是单独写一篇博客篇幅又太短，就一起说了。\n\n&emsp;&emsp;问问题之前请注意以下事项\n\n<ol>\n    <li>不要只问“我这个哪里错了？”之类的问题，明确自己的问题是什么</li>\n    <li>不要只问有没有人在</li>\n    <li>不要单独给出题号，贴出题目截图，因为不是所有人都能便捷的通过题号去看题目</li>\n    <li>贴代码请使用截图（除非别人要复制你的代码），文字消息中的代码可读性极差</li>\n    <li>给出预期结果和实际结果，信息越多越容易让别人定位错误位置</li>\n    <li>贴代码之前先规范自己的代码，不规范的代码看起来 非 常 难 受</li>\n    <li>别人没有为你解答问题的义务，注意礼貌用语</li>\n    <li>提问之前自己先好好思考以下，很多问题自己可以解决</li>\n</ol>\n\n&emsp;&emsp;最后，附上一张好图：\n\n![提问的艺术](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/issue.png)\n\n\n\n\n\n\n\n\n\n","source":"_posts/code_advice.md","raw":"---\ntitle: 关于C语言编码的一些建议\ndate: 2021-10-12 20:14:05\ncategories:\n  - C/C++\ntags:\n  - 规范\n  - 教程\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b12.jpeg\ndescription: 简单总结一下我对一些代码的建议。\n---\n\n# 前言\n\n&emsp;&emsp;这篇文章可以看作对我之前写的“[浅读C语言代码规范](https://blog.emptydreams.xyz/c_standard)”的一些补充，但是本篇内容仅个人看法，具体是否采用还需读者自己评估。\n\n&emsp;&emsp;该文内容不定时补充，为了看过旧版内容的读者更方便，新的内容会放在前面。\n\n---\n\n# [2021-10-13]\n\n## goto语句的使用\n\n&emsp;&emsp;`goto`是`C/C++`中一个强大的功能，但是由于其功能过于强大，容易引发各种各样的问题，且会导致程序的控制流难以追踪，并不推荐使用。绝大多数情况下，任何能用其它语句代替的`goto`都不应当使用`goto`编写，除非是使用`goto`来跳出外部循环。\n\n## 善用快捷键\n\n&emsp;&emsp;善用系统和IDE的快捷键可以让我们的编码速度更快，也可以更便捷的进行调试等操作。如果是JBS平台的用户，可以安装`Key Promoter X`这个插件，在你用鼠标进行操作时会提醒你对应的快捷键是什么，如果你频繁进行某项操作但其没有快捷键，它也会提醒你可以自己设置一个快捷键。\n\n---\n\n# [2021-10-12]\n\n## 变量声明位置\n\n&emsp;&emsp;在`C99`（不了解C90、C99、C11是什么的话自行百度一下）之前，C语言要求函数内的变量必须在函数头声明。这一方面虽然可以通过函数头的变量说明函数的大致内容，但是也造成了一些麻烦：\n\n<ul>\n    <li>编码时经常需要从当前编辑的地方回到函数头补上需要用到的变量声明</li>\n    <li>容易忘记赋初值</li>\n    <li>某些变量只需用到一次，写在开头反而更乱</li>\n</ul>\n\n&emsp;&emsp;自`C99`开始，C语言取消了这一限制，变量的声明可以写在函数中的任意位置（前提是符合语法）。个人更倾向于就近原则，即使用时再声明。\n\n&emsp;&emsp;如果读者想要使用前一种方式的话，我也推荐将临时用到的变量声明（比如`for循环`中用到的控制变量）在使用的位置，这样子可以让代码更直观。\n\n## 布尔类型\n\n&emsp;&emsp;C语言中经常使用`int`来表示真假。比如下面的代码：\n\n```C\nint main() {\n    int k = 0;\n    if (k) {\n        printf(\"true\");\n    } else {\n        printf(\"false\");\n    }\n    return 0;\n}\n```\n\n&emsp;&emsp;上面的代码完全可以正常运行，但是这实际上是一种非常麻烦并且容易出错的写法。首先，编码的人和阅读的人都需要思考，到底`0`和`1`哪一个代表`true`。其次，在复杂一些的环境中，这种写法会令人难以快速排出错误。\n\n&emsp;&emsp;如何避免上述的问题？其实很简单，使用C语言的库中提供的`_Bool`即可，该类型只有`true`和`false`两个值，并且英文单词比单个数字更加直观易懂。如果嫌`_Bool`打起来麻烦的话，可以使用`stdbool.h`头文件中定义的`bool`。\n\n## 统一代码风格\n\n&emsp;&emsp;如果你的代码中使用了某一种代码风格，那么，请在程序中保持这个风格，不同风格的代码混杂在一起相当于没有规范的代码。\n\n## 读懂编译报错\n\n&emsp;&emsp;如果代码存在编译错误，编译器会给出错误信息，这些信息通常是英文，如果你看不懂的话不妨把信息复制到网络上搜索一下，很容易就能找到问题原因和解决方法。\n\n&emsp;&emsp;这里强调一点，编译错误是编码过程中最容易解决的错误（除了IDE判断错误导致报错位置或信息不对的情况），遇到编译错误一定要自己想办法解决。\n\n---\n\n# 提问的艺术\n\n&emsp;&emsp;这个问题其实不应该出现在这里，但是单独写一篇博客篇幅又太短，就一起说了。\n\n&emsp;&emsp;问问题之前请注意以下事项\n\n<ol>\n    <li>不要只问“我这个哪里错了？”之类的问题，明确自己的问题是什么</li>\n    <li>不要只问有没有人在</li>\n    <li>不要单独给出题号，贴出题目截图，因为不是所有人都能便捷的通过题号去看题目</li>\n    <li>贴代码请使用截图（除非别人要复制你的代码），文字消息中的代码可读性极差</li>\n    <li>给出预期结果和实际结果，信息越多越容易让别人定位错误位置</li>\n    <li>贴代码之前先规范自己的代码，不规范的代码看起来 非 常 难 受</li>\n    <li>别人没有为你解答问题的义务，注意礼貌用语</li>\n    <li>提问之前自己先好好思考以下，很多问题自己可以解决</li>\n</ol>\n\n&emsp;&emsp;最后，附上一张好图：\n\n![提问的艺术](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/issue.png)\n\n\n\n\n\n\n\n\n\n","slug":"code_advice","published":1,"updated":"2021-10-13T06:23:46.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvdzwpgf0000h8wq99treu3s","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>&emsp;&emsp;这篇文章可以看作对我之前写的“<a href=\"https://blog.emptydreams.xyz/c_standard\">浅读C语言代码规范</a>”的一些补充，但是本篇内容仅个人看法，具体是否采用还需读者自己评估。</p>\n<p>&emsp;&emsp;该文内容不定时补充，为了看过旧版内容的读者更方便，新的内容会放在前面。</p>\n<hr>\n<h1 id=\"2021-10-13\"><a href=\"#2021-10-13\" class=\"headerlink\" title=\"[2021-10-13]\"></a>[2021-10-13]</h1><h2 id=\"goto语句的使用\"><a href=\"#goto语句的使用\" class=\"headerlink\" title=\"goto语句的使用\"></a>goto语句的使用</h2><p>&emsp;&emsp;<code>goto</code>是<code>C/C++</code>中一个强大的功能，但是由于其功能过于强大，容易引发各种各样的问题，且会导致程序的控制流难以追踪，并不推荐使用。绝大多数情况下，任何能用其它语句代替的<code>goto</code>都不应当使用<code>goto</code>编写，除非是使用<code>goto</code>来跳出外部循环。</p>\n<h2 id=\"善用快捷键\"><a href=\"#善用快捷键\" class=\"headerlink\" title=\"善用快捷键\"></a>善用快捷键</h2><p>&emsp;&emsp;善用系统和IDE的快捷键可以让我们的编码速度更快，也可以更便捷的进行调试等操作。如果是JBS平台的用户，可以安装<code>Key Promoter X</code>这个插件，在你用鼠标进行操作时会提醒你对应的快捷键是什么，如果你频繁进行某项操作但其没有快捷键，它也会提醒你可以自己设置一个快捷键。</p>\n<hr>\n<h1 id=\"2021-10-12\"><a href=\"#2021-10-12\" class=\"headerlink\" title=\"[2021-10-12]\"></a>[2021-10-12]</h1><h2 id=\"变量声明位置\"><a href=\"#变量声明位置\" class=\"headerlink\" title=\"变量声明位置\"></a>变量声明位置</h2><p>&emsp;&emsp;在<code>C99</code>（不了解C90、C99、C11是什么的话自行百度一下）之前，C语言要求函数内的变量必须在函数头声明。这一方面虽然可以通过函数头的变量说明函数的大致内容，但是也造成了一些麻烦：</p>\n<ul>\n    <li>编码时经常需要从当前编辑的地方回到函数头补上需要用到的变量声明</li>\n    <li>容易忘记赋初值</li>\n    <li>某些变量只需用到一次，写在开头反而更乱</li>\n</ul>\n\n<p>&emsp;&emsp;自<code>C99</code>开始，C语言取消了这一限制，变量的声明可以写在函数中的任意位置（前提是符合语法）。个人更倾向于就近原则，即使用时再声明。</p>\n<p>&emsp;&emsp;如果读者想要使用前一种方式的话，我也推荐将临时用到的变量声明（比如<code>for循环</code>中用到的控制变量）在使用的位置，这样子可以让代码更直观。</p>\n<h2 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h2><p>&emsp;&emsp;C语言中经常使用<code>int</code>来表示真假。比如下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">if</span> (k) &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;true&quot;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;false&quot;</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面的代码完全可以正常运行，但是这实际上是一种非常麻烦并且容易出错的写法。首先，编码的人和阅读的人都需要思考，到底<code>0</code>和<code>1</code>哪一个代表<code>true</code>。其次，在复杂一些的环境中，这种写法会令人难以快速排出错误。</p>\n<p>&emsp;&emsp;如何避免上述的问题？其实很简单，使用C语言的库中提供的<code>_Bool</code>即可，该类型只有<code>true</code>和<code>false</code>两个值，并且英文单词比单个数字更加直观易懂。如果嫌<code>_Bool</code>打起来麻烦的话，可以使用<code>stdbool.h</code>头文件中定义的<code>bool</code>。</p>\n<h2 id=\"统一代码风格\"><a href=\"#统一代码风格\" class=\"headerlink\" title=\"统一代码风格\"></a>统一代码风格</h2><p>&emsp;&emsp;如果你的代码中使用了某一种代码风格，那么，请在程序中保持这个风格，不同风格的代码混杂在一起相当于没有规范的代码。</p>\n<h2 id=\"读懂编译报错\"><a href=\"#读懂编译报错\" class=\"headerlink\" title=\"读懂编译报错\"></a>读懂编译报错</h2><p>&emsp;&emsp;如果代码存在编译错误，编译器会给出错误信息，这些信息通常是英文，如果你看不懂的话不妨把信息复制到网络上搜索一下，很容易就能找到问题原因和解决方法。</p>\n<p>&emsp;&emsp;这里强调一点，编译错误是编码过程中最容易解决的错误（除了IDE判断错误导致报错位置或信息不对的情况），遇到编译错误一定要自己想办法解决。</p>\n<hr>\n<h1 id=\"提问的艺术\"><a href=\"#提问的艺术\" class=\"headerlink\" title=\"提问的艺术\"></a>提问的艺术</h1><p>&emsp;&emsp;这个问题其实不应该出现在这里，但是单独写一篇博客篇幅又太短，就一起说了。</p>\n<p>&emsp;&emsp;问问题之前请注意以下事项</p>\n<ol>\n    <li>不要只问“我这个哪里错了？”之类的问题，明确自己的问题是什么</li>\n    <li>不要只问有没有人在</li>\n    <li>不要单独给出题号，贴出题目截图，因为不是所有人都能便捷的通过题号去看题目</li>\n    <li>贴代码请使用截图（除非别人要复制你的代码），文字消息中的代码可读性极差</li>\n    <li>给出预期结果和实际结果，信息越多越容易让别人定位错误位置</li>\n    <li>贴代码之前先规范自己的代码，不规范的代码看起来 非 常 难 受</li>\n    <li>别人没有为你解答问题的义务，注意礼貌用语</li>\n    <li>提问之前自己先好好思考以下，很多问题自己可以解决</li>\n</ol>\n\n<p>&emsp;&emsp;最后，附上一张好图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/issue.png\" alt=\"提问的艺术\"></p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"},{"name":"Akilar店长","link":"https://akilar.top","avatar":"https://akilar.top/img/siteicon/favicon.png","descr":"欢迎光临糖果屋","siteshot":"https://cdn.jsdelivr.net/gh/Akilarlxh/ScreenShot@gh-pages/akilar.top.jpg"}]}]}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>&emsp;&emsp;这篇文章可以看作对我之前写的“<a href=\"https://blog.emptydreams.xyz/c_standard\">浅读C语言代码规范</a>”的一些补充，但是本篇内容仅个人看法，具体是否采用还需读者自己评估。</p>\n<p>&emsp;&emsp;该文内容不定时补充，为了看过旧版内容的读者更方便，新的内容会放在前面。</p>\n<hr>\n<h1 id=\"2021-10-13\"><a href=\"#2021-10-13\" class=\"headerlink\" title=\"[2021-10-13]\"></a>[2021-10-13]</h1><h2 id=\"goto语句的使用\"><a href=\"#goto语句的使用\" class=\"headerlink\" title=\"goto语句的使用\"></a>goto语句的使用</h2><p>&emsp;&emsp;<code>goto</code>是<code>C/C++</code>中一个强大的功能，但是由于其功能过于强大，容易引发各种各样的问题，且会导致程序的控制流难以追踪，并不推荐使用。绝大多数情况下，任何能用其它语句代替的<code>goto</code>都不应当使用<code>goto</code>编写，除非是使用<code>goto</code>来跳出外部循环。</p>\n<h2 id=\"善用快捷键\"><a href=\"#善用快捷键\" class=\"headerlink\" title=\"善用快捷键\"></a>善用快捷键</h2><p>&emsp;&emsp;善用系统和IDE的快捷键可以让我们的编码速度更快，也可以更便捷的进行调试等操作。如果是JBS平台的用户，可以安装<code>Key Promoter X</code>这个插件，在你用鼠标进行操作时会提醒你对应的快捷键是什么，如果你频繁进行某项操作但其没有快捷键，它也会提醒你可以自己设置一个快捷键。</p>\n<hr>\n<h1 id=\"2021-10-12\"><a href=\"#2021-10-12\" class=\"headerlink\" title=\"[2021-10-12]\"></a>[2021-10-12]</h1><h2 id=\"变量声明位置\"><a href=\"#变量声明位置\" class=\"headerlink\" title=\"变量声明位置\"></a>变量声明位置</h2><p>&emsp;&emsp;在<code>C99</code>（不了解C90、C99、C11是什么的话自行百度一下）之前，C语言要求函数内的变量必须在函数头声明。这一方面虽然可以通过函数头的变量说明函数的大致内容，但是也造成了一些麻烦：</p>\n<ul>\n    <li>编码时经常需要从当前编辑的地方回到函数头补上需要用到的变量声明</li>\n    <li>容易忘记赋初值</li>\n    <li>某些变量只需用到一次，写在开头反而更乱</li>\n</ul>\n\n<p>&emsp;&emsp;自<code>C99</code>开始，C语言取消了这一限制，变量的声明可以写在函数中的任意位置（前提是符合语法）。个人更倾向于就近原则，即使用时再声明。</p>\n<p>&emsp;&emsp;如果读者想要使用前一种方式的话，我也推荐将临时用到的变量声明（比如<code>for循环</code>中用到的控制变量）在使用的位置，这样子可以让代码更直观。</p>\n<h2 id=\"布尔类型\"><a href=\"#布尔类型\" class=\"headerlink\" title=\"布尔类型\"></a>布尔类型</h2><p>&emsp;&emsp;C语言中经常使用<code>int</code>来表示真假。比如下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-keyword\">if</span> (k) &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;true&quot;</span>);<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;false&quot;</span>);<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;上面的代码完全可以正常运行，但是这实际上是一种非常麻烦并且容易出错的写法。首先，编码的人和阅读的人都需要思考，到底<code>0</code>和<code>1</code>哪一个代表<code>true</code>。其次，在复杂一些的环境中，这种写法会令人难以快速排出错误。</p>\n<p>&emsp;&emsp;如何避免上述的问题？其实很简单，使用C语言的库中提供的<code>_Bool</code>即可，该类型只有<code>true</code>和<code>false</code>两个值，并且英文单词比单个数字更加直观易懂。如果嫌<code>_Bool</code>打起来麻烦的话，可以使用<code>stdbool.h</code>头文件中定义的<code>bool</code>。</p>\n<h2 id=\"统一代码风格\"><a href=\"#统一代码风格\" class=\"headerlink\" title=\"统一代码风格\"></a>统一代码风格</h2><p>&emsp;&emsp;如果你的代码中使用了某一种代码风格，那么，请在程序中保持这个风格，不同风格的代码混杂在一起相当于没有规范的代码。</p>\n<h2 id=\"读懂编译报错\"><a href=\"#读懂编译报错\" class=\"headerlink\" title=\"读懂编译报错\"></a>读懂编译报错</h2><p>&emsp;&emsp;如果代码存在编译错误，编译器会给出错误信息，这些信息通常是英文，如果你看不懂的话不妨把信息复制到网络上搜索一下，很容易就能找到问题原因和解决方法。</p>\n<p>&emsp;&emsp;这里强调一点，编译错误是编码过程中最容易解决的错误（除了IDE判断错误导致报错位置或信息不对的情况），遇到编译错误一定要自己想办法解决。</p>\n<hr>\n<h1 id=\"提问的艺术\"><a href=\"#提问的艺术\" class=\"headerlink\" title=\"提问的艺术\"></a>提问的艺术</h1><p>&emsp;&emsp;这个问题其实不应该出现在这里，但是单独写一篇博客篇幅又太短，就一起说了。</p>\n<p>&emsp;&emsp;问问题之前请注意以下事项</p>\n<ol>\n    <li>不要只问“我这个哪里错了？”之类的问题，明确自己的问题是什么</li>\n    <li>不要只问有没有人在</li>\n    <li>不要单独给出题号，贴出题目截图，因为不是所有人都能便捷的通过题号去看题目</li>\n    <li>贴代码请使用截图（除非别人要复制你的代码），文字消息中的代码可读性极差</li>\n    <li>给出预期结果和实际结果，信息越多越容易让别人定位错误位置</li>\n    <li>贴代码之前先规范自己的代码，不规范的代码看起来 非 常 难 受</li>\n    <li>别人没有为你解答问题的义务，注意礼貌用语</li>\n    <li>提问之前自己先好好思考以下，很多问题自己可以解决</li>\n</ol>\n\n<p>&emsp;&emsp;最后，附上一张好图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/issue.png\" alt=\"提问的艺术\"></p>\n"},{"title":"从小白到如今的心理变化","date":"2021-10-25T13:25:21.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b14.jpeg","description":"谈一谈从编程小白到现在的心路历程","_content":"\n\n\n&emsp;&emsp;这篇文章是我写的第一篇不以编程为主题的文章，也是第一篇日记形式的文章，以前一直在写我个人对编程中某些事物的理解和教程。从今天开始，也会多写一些和这篇类似的文章。同类的文章统一分类到`随心记`中。\n\n---\n\n&emsp;&emsp;先说一说我的编程之旅是怎么开始的。在初一的某一天，我鼓起勇气询问我的父亲能不能给我买一本《Java从入门到精通》。他爽快的答应了我的要求，很快，一本崭新的图书便摆到了我的眼前。在刚刚拿到这本书的时候，我如获至宝，每天都抱着这本书看。但是没过多长时间，我就和大多数人一样，将这本书放到了书架上吃灰。直到初三的时候，我仍然只会写最简单的“Hello World”。\n\n&emsp;&emsp;事情的转机出现在初三的暑假，当时，我们家出去常住。临走时我随手带上了这本书，到了地方，因为谁也不认识，没有玩伴。在无聊之余便重新开始翻看这本书，可能是因为心性的成长，这不看不要紧，一看就深深的被书中的内容吸引住了。我当时用了一两个星期的时间看完了所有基础章节，回到家便迫不及待的实践起来。\n\n&emsp;&emsp;说是实践，其实也没有什么了不起的。我到现在仍然记得，我当时写了数十个各种各样的和“Hello World”难度差不多的程序。文件名从`A1`一直排到`C*`，到了后来想翻看前面的代码的时候才发现找不到在哪个文件里面写的了，也是从这时候开始，我意识到了规范命名的重要性，在研究命名的同时也顺便看了看代码规范，一个良好的编码习惯也在这是埋下了种子。\n\n&emsp;&emsp;现在再来说说我为什么会想要接触编程这个领域。我们家在我幼儿园的时候便有了电脑，刚开始还只会跟着哥哥看看动画片，到了小学，逐渐开始打起了游戏。刚开始我们一直在玩`4399`一类的网页游戏，接着，我们便不再满足于网页游戏提供的游戏体验，向本地游戏进军。随即便接触了“植物大战僵尸”之类的游戏，紧接着便是“CF”、“LOL”。到了六年级的一天，哥哥向我推荐了“MC”这款游戏。他没玩多长时间便失去了兴趣，但是我一个人坚持玩了下来。我没有满足于原版提供的游戏体验，偶然从网上了解到可以添加模组之后我便开始尝试添加模组，现在还能清晰的记得当时安装`JRE`和`Forge`就耗费了我很久很久的时间。随后又尝试了`IC2`、`BC`等工业类的模组，但是发现我想要的一些玩法模组中并没有提供，于是我便有了自己开发模组的想法。到了这时候，我已经具备了一定的网络资源搜索能力，很轻松的就在“MCBBS”上找到了`MCR`。简单的使用后我就发现它不能提供我需要的功能，随即在其讨论群中了解到了`Java`，在这里便埋下了编程的种子，也因为如此，才有了开头的一幕。\n\n&emsp;&emsp;正所谓站得越高看得越远，开始学习`Java`后我才发现我了解的知识是如此之少，并且当时距离我初一已经有了相当远的时间。把刚开始接触编程的目的忘得一干二净，并且开始尝试写各式各样的~~小程序~~（黑历史），当时还恬不知耻的发到了哔哩哔哩上面，后来相当一部分都被我删除了（想翻我黑历史的可以放弃了）。\n\n&emsp;&emsp;后来我也思考过我为什么可以坚持下来继续学习编程，我想很大一部分原因是我当时选择跳过一部分基础内容直接学习图形化开发。因为接触了图形化开发，我可以写出各式各样的能用肉眼看到效果并且可以获得周围人们称赞的程序。这种学习方法确时有显著的缺陷，当学习后面内容的时候很容易涉及到基础内容，遇到不懂的基础内容要么比葫芦画瓢应付过去，要么仔细研究一下再继续。不过我想，对于自学并且没有信心坚持下去的人，这不失为一种好方法。至于我们这些在校大学生，学习编程的大多都是学校要求，周围的人也是懂得，就算不写出来图形界面，他们也可以看出你的代码的亮点（不能看出来的话就更好炫耀了doge（雾）），这种时候这个学习方法的优势便不那么明显了。\n\n&emsp;&emsp;直到高二的时候我才突然想起来我的初衷，随即用了好几个星期的时间构建了开发环境，并且开始着手写下我的第一个MC作品。我没有像其他人那样先写一些简单的玩意，而是直接开始着手写我[最终想要的作品——现代工业-MI](https://afdian.net/@emptydreams)（一波猝不及防的广告doge）。这个骚操作不得不说给我造成了一些麻烦，因为我后面有很长时间都用来改掉原先写的死板、累赘的代码设计。\n\n&emsp;&emsp;学习开发模组的过程中也认识了许许多多的大佬，中间有一个人让我受益匪浅。我经常向他询问问题，到后面我们也会讨论一些问题，当我写出一个代码设计的时候也会让他帮忙“评分”。不得不说这几年我确时获益良多，不仅锻炼了编码能力、结构设计能力，也学习了许多关于JVM的知识。\n\n&emsp;&emsp;在我刚刚学完Java的基本内容的时候，我可以非常耐心的给任何人回答所有合理的问题。但是随着时间的推移，我渐渐的不再有耐心的千篇一律的回答那些非常基础的问题。所以有些人可能会很奇怪我有时候对不同的人态度不一样，甚至同一个人不同时候态度也会不一样，如果你发现我回答你的问题的时候态度不好，大多时候你应该反思一下是不是自己问的问题太基础了？是不是自己的问题随便百度一下就能搜到答案？基本上不会是因为我心情不好，因为当我心情不好的时候我大概率暂时不会理你（doge）。\n\n&emsp;&emsp;我是一个大部分时候乐于分享自己的知识但是经常无法很好的用语言表达我的意思的人，所以我经常用博客的形式发布内容，因为写作的过程中有充足的时间供我思考自己如何表述。从另一个方面来讲，我是一个临场发挥极差的人，如果没有事先的准备，你直接询问我一些有深度或者摄入点很奇怪的问题，短时间内我可能无法分析到问题的本质，而是需要静下来仔细思考。\n\n&emsp;&emsp;在了解了更多的知识后，我愈发的深陷其中，无法自拔。每当我写出一个良好的设计来取代老旧的代码，我都会感到无比的自豪与骄傲；在学习到新的知识的时候，我也会异常的兴奋；看到别人（团队）设计出的非常BUG的程序，在了解大致原理后，我也会情不自禁的默默喊出“牛逼”，遇到他人也会很乐意向他“炫耀”这个设计。\n\n&emsp;&emsp;总之“站得越高，看得越远”这句话绝对不是没有道理，学到新的知识就能看到更多需要学习的内容，当你沉浸到其中的时候便能体会到探索的乐趣。\n\n---\n\n&emsp;&emsp;写了这么多，一方面是简单记录一下我的过去，另一方面也是给大家提供一个范例。\n\n&emsp;&emsp;群里面的大佬绝不是一天练成的，所有大佬都有刚开始懵懵懂懂的时候，很多人会对大佬回避自己简单的问题甚至因此训斥自己而感到委屈和愤怒，但是这大多不是大佬傲慢不逊，而是为了点醒你。因为一味的回答你的问题并不一定是对你最好的。不同的人有不同的理念，但是有一个共同点就是培养独立能力。记住一句话：**一味的依赖别人只会毁掉自己的未来**。\n\n\n\n\n\n","source":"_posts/course.md","raw":"---\ntitle: 从小白到如今的心理变化\ndate: 2021-10-25 21:25:21\ncategories:\n  - 随心记\ntags:\n  - 日记\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b14.jpeg\ndescription: 谈一谈从编程小白到现在的心路历程\n---\n\n\n\n&emsp;&emsp;这篇文章是我写的第一篇不以编程为主题的文章，也是第一篇日记形式的文章，以前一直在写我个人对编程中某些事物的理解和教程。从今天开始，也会多写一些和这篇类似的文章。同类的文章统一分类到`随心记`中。\n\n---\n\n&emsp;&emsp;先说一说我的编程之旅是怎么开始的。在初一的某一天，我鼓起勇气询问我的父亲能不能给我买一本《Java从入门到精通》。他爽快的答应了我的要求，很快，一本崭新的图书便摆到了我的眼前。在刚刚拿到这本书的时候，我如获至宝，每天都抱着这本书看。但是没过多长时间，我就和大多数人一样，将这本书放到了书架上吃灰。直到初三的时候，我仍然只会写最简单的“Hello World”。\n\n&emsp;&emsp;事情的转机出现在初三的暑假，当时，我们家出去常住。临走时我随手带上了这本书，到了地方，因为谁也不认识，没有玩伴。在无聊之余便重新开始翻看这本书，可能是因为心性的成长，这不看不要紧，一看就深深的被书中的内容吸引住了。我当时用了一两个星期的时间看完了所有基础章节，回到家便迫不及待的实践起来。\n\n&emsp;&emsp;说是实践，其实也没有什么了不起的。我到现在仍然记得，我当时写了数十个各种各样的和“Hello World”难度差不多的程序。文件名从`A1`一直排到`C*`，到了后来想翻看前面的代码的时候才发现找不到在哪个文件里面写的了，也是从这时候开始，我意识到了规范命名的重要性，在研究命名的同时也顺便看了看代码规范，一个良好的编码习惯也在这是埋下了种子。\n\n&emsp;&emsp;现在再来说说我为什么会想要接触编程这个领域。我们家在我幼儿园的时候便有了电脑，刚开始还只会跟着哥哥看看动画片，到了小学，逐渐开始打起了游戏。刚开始我们一直在玩`4399`一类的网页游戏，接着，我们便不再满足于网页游戏提供的游戏体验，向本地游戏进军。随即便接触了“植物大战僵尸”之类的游戏，紧接着便是“CF”、“LOL”。到了六年级的一天，哥哥向我推荐了“MC”这款游戏。他没玩多长时间便失去了兴趣，但是我一个人坚持玩了下来。我没有满足于原版提供的游戏体验，偶然从网上了解到可以添加模组之后我便开始尝试添加模组，现在还能清晰的记得当时安装`JRE`和`Forge`就耗费了我很久很久的时间。随后又尝试了`IC2`、`BC`等工业类的模组，但是发现我想要的一些玩法模组中并没有提供，于是我便有了自己开发模组的想法。到了这时候，我已经具备了一定的网络资源搜索能力，很轻松的就在“MCBBS”上找到了`MCR`。简单的使用后我就发现它不能提供我需要的功能，随即在其讨论群中了解到了`Java`，在这里便埋下了编程的种子，也因为如此，才有了开头的一幕。\n\n&emsp;&emsp;正所谓站得越高看得越远，开始学习`Java`后我才发现我了解的知识是如此之少，并且当时距离我初一已经有了相当远的时间。把刚开始接触编程的目的忘得一干二净，并且开始尝试写各式各样的~~小程序~~（黑历史），当时还恬不知耻的发到了哔哩哔哩上面，后来相当一部分都被我删除了（想翻我黑历史的可以放弃了）。\n\n&emsp;&emsp;后来我也思考过我为什么可以坚持下来继续学习编程，我想很大一部分原因是我当时选择跳过一部分基础内容直接学习图形化开发。因为接触了图形化开发，我可以写出各式各样的能用肉眼看到效果并且可以获得周围人们称赞的程序。这种学习方法确时有显著的缺陷，当学习后面内容的时候很容易涉及到基础内容，遇到不懂的基础内容要么比葫芦画瓢应付过去，要么仔细研究一下再继续。不过我想，对于自学并且没有信心坚持下去的人，这不失为一种好方法。至于我们这些在校大学生，学习编程的大多都是学校要求，周围的人也是懂得，就算不写出来图形界面，他们也可以看出你的代码的亮点（不能看出来的话就更好炫耀了doge（雾）），这种时候这个学习方法的优势便不那么明显了。\n\n&emsp;&emsp;直到高二的时候我才突然想起来我的初衷，随即用了好几个星期的时间构建了开发环境，并且开始着手写下我的第一个MC作品。我没有像其他人那样先写一些简单的玩意，而是直接开始着手写我[最终想要的作品——现代工业-MI](https://afdian.net/@emptydreams)（一波猝不及防的广告doge）。这个骚操作不得不说给我造成了一些麻烦，因为我后面有很长时间都用来改掉原先写的死板、累赘的代码设计。\n\n&emsp;&emsp;学习开发模组的过程中也认识了许许多多的大佬，中间有一个人让我受益匪浅。我经常向他询问问题，到后面我们也会讨论一些问题，当我写出一个代码设计的时候也会让他帮忙“评分”。不得不说这几年我确时获益良多，不仅锻炼了编码能力、结构设计能力，也学习了许多关于JVM的知识。\n\n&emsp;&emsp;在我刚刚学完Java的基本内容的时候，我可以非常耐心的给任何人回答所有合理的问题。但是随着时间的推移，我渐渐的不再有耐心的千篇一律的回答那些非常基础的问题。所以有些人可能会很奇怪我有时候对不同的人态度不一样，甚至同一个人不同时候态度也会不一样，如果你发现我回答你的问题的时候态度不好，大多时候你应该反思一下是不是自己问的问题太基础了？是不是自己的问题随便百度一下就能搜到答案？基本上不会是因为我心情不好，因为当我心情不好的时候我大概率暂时不会理你（doge）。\n\n&emsp;&emsp;我是一个大部分时候乐于分享自己的知识但是经常无法很好的用语言表达我的意思的人，所以我经常用博客的形式发布内容，因为写作的过程中有充足的时间供我思考自己如何表述。从另一个方面来讲，我是一个临场发挥极差的人，如果没有事先的准备，你直接询问我一些有深度或者摄入点很奇怪的问题，短时间内我可能无法分析到问题的本质，而是需要静下来仔细思考。\n\n&emsp;&emsp;在了解了更多的知识后，我愈发的深陷其中，无法自拔。每当我写出一个良好的设计来取代老旧的代码，我都会感到无比的自豪与骄傲；在学习到新的知识的时候，我也会异常的兴奋；看到别人（团队）设计出的非常BUG的程序，在了解大致原理后，我也会情不自禁的默默喊出“牛逼”，遇到他人也会很乐意向他“炫耀”这个设计。\n\n&emsp;&emsp;总之“站得越高，看得越远”这句话绝对不是没有道理，学到新的知识就能看到更多需要学习的内容，当你沉浸到其中的时候便能体会到探索的乐趣。\n\n---\n\n&emsp;&emsp;写了这么多，一方面是简单记录一下我的过去，另一方面也是给大家提供一个范例。\n\n&emsp;&emsp;群里面的大佬绝不是一天练成的，所有大佬都有刚开始懵懵懂懂的时候，很多人会对大佬回避自己简单的问题甚至因此训斥自己而感到委屈和愤怒，但是这大多不是大佬傲慢不逊，而是为了点醒你。因为一味的回答你的问题并不一定是对你最好的。不同的人有不同的理念，但是有一个共同点就是培养独立能力。记住一句话：**一味的依赖别人只会毁掉自己的未来**。\n\n\n\n\n\n","slug":"course","published":1,"updated":"2021-10-29T14:33:08.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvdzwpgs0009h8wqc3ls937s","content":"<p>&emsp;&emsp;这篇文章是我写的第一篇不以编程为主题的文章，也是第一篇日记形式的文章，以前一直在写我个人对编程中某些事物的理解和教程。从今天开始，也会多写一些和这篇类似的文章。同类的文章统一分类到<code>随心记</code>中。</p>\n<hr>\n<p>&emsp;&emsp;先说一说我的编程之旅是怎么开始的。在初一的某一天，我鼓起勇气询问我的父亲能不能给我买一本《Java从入门到精通》。他爽快的答应了我的要求，很快，一本崭新的图书便摆到了我的眼前。在刚刚拿到这本书的时候，我如获至宝，每天都抱着这本书看。但是没过多长时间，我就和大多数人一样，将这本书放到了书架上吃灰。直到初三的时候，我仍然只会写最简单的“Hello World”。</p>\n<p>&emsp;&emsp;事情的转机出现在初三的暑假，当时，我们家出去常住。临走时我随手带上了这本书，到了地方，因为谁也不认识，没有玩伴。在无聊之余便重新开始翻看这本书，可能是因为心性的成长，这不看不要紧，一看就深深的被书中的内容吸引住了。我当时用了一两个星期的时间看完了所有基础章节，回到家便迫不及待的实践起来。</p>\n<p>&emsp;&emsp;说是实践，其实也没有什么了不起的。我到现在仍然记得，我当时写了数十个各种各样的和“Hello World”难度差不多的程序。文件名从<code>A1</code>一直排到<code>C*</code>，到了后来想翻看前面的代码的时候才发现找不到在哪个文件里面写的了，也是从这时候开始，我意识到了规范命名的重要性，在研究命名的同时也顺便看了看代码规范，一个良好的编码习惯也在这是埋下了种子。</p>\n<p>&emsp;&emsp;现在再来说说我为什么会想要接触编程这个领域。我们家在我幼儿园的时候便有了电脑，刚开始还只会跟着哥哥看看动画片，到了小学，逐渐开始打起了游戏。刚开始我们一直在玩<code>4399</code>一类的网页游戏，接着，我们便不再满足于网页游戏提供的游戏体验，向本地游戏进军。随即便接触了“植物大战僵尸”之类的游戏，紧接着便是“CF”、“LOL”。到了六年级的一天，哥哥向我推荐了“MC”这款游戏。他没玩多长时间便失去了兴趣，但是我一个人坚持玩了下来。我没有满足于原版提供的游戏体验，偶然从网上了解到可以添加模组之后我便开始尝试添加模组，现在还能清晰的记得当时安装<code>JRE</code>和<code>Forge</code>就耗费了我很久很久的时间。随后又尝试了<code>IC2</code>、<code>BC</code>等工业类的模组，但是发现我想要的一些玩法模组中并没有提供，于是我便有了自己开发模组的想法。到了这时候，我已经具备了一定的网络资源搜索能力，很轻松的就在“MCBBS”上找到了<code>MCR</code>。简单的使用后我就发现它不能提供我需要的功能，随即在其讨论群中了解到了<code>Java</code>，在这里便埋下了编程的种子，也因为如此，才有了开头的一幕。</p>\n<p>&emsp;&emsp;正所谓站得越高看得越远，开始学习<code>Java</code>后我才发现我了解的知识是如此之少，并且当时距离我初一已经有了相当远的时间。把刚开始接触编程的目的忘得一干二净，并且开始尝试写各式各样的<del>小程序</del>（黑历史），当时还恬不知耻的发到了哔哩哔哩上面，后来相当一部分都被我删除了（想翻我黑历史的可以放弃了）。</p>\n<p>&emsp;&emsp;后来我也思考过我为什么可以坚持下来继续学习编程，我想很大一部分原因是我当时选择跳过一部分基础内容直接学习图形化开发。因为接触了图形化开发，我可以写出各式各样的能用肉眼看到效果并且可以获得周围人们称赞的程序。这种学习方法确时有显著的缺陷，当学习后面内容的时候很容易涉及到基础内容，遇到不懂的基础内容要么比葫芦画瓢应付过去，要么仔细研究一下再继续。不过我想，对于自学并且没有信心坚持下去的人，这不失为一种好方法。至于我们这些在校大学生，学习编程的大多都是学校要求，周围的人也是懂得，就算不写出来图形界面，他们也可以看出你的代码的亮点（不能看出来的话就更好炫耀了doge（雾）），这种时候这个学习方法的优势便不那么明显了。</p>\n<p>&emsp;&emsp;直到高二的时候我才突然想起来我的初衷，随即用了好几个星期的时间构建了开发环境，并且开始着手写下我的第一个MC作品。我没有像其他人那样先写一些简单的玩意，而是直接开始着手写我<a href=\"https://afdian.net/@emptydreams\">最终想要的作品——现代工业-MI</a>（一波猝不及防的广告doge）。这个骚操作不得不说给我造成了一些麻烦，因为我后面有很长时间都用来改掉原先写的死板、累赘的代码设计。</p>\n<p>&emsp;&emsp;学习开发模组的过程中也认识了许许多多的大佬，中间有一个人让我受益匪浅。我经常向他询问问题，到后面我们也会讨论一些问题，当我写出一个代码设计的时候也会让他帮忙“评分”。不得不说这几年我确时获益良多，不仅锻炼了编码能力、结构设计能力，也学习了许多关于JVM的知识。</p>\n<p>&emsp;&emsp;在我刚刚学完Java的基本内容的时候，我可以非常耐心的给任何人回答所有合理的问题。但是随着时间的推移，我渐渐的不再有耐心的千篇一律的回答那些非常基础的问题。所以有些人可能会很奇怪我有时候对不同的人态度不一样，甚至同一个人不同时候态度也会不一样，如果你发现我回答你的问题的时候态度不好，大多时候你应该反思一下是不是自己问的问题太基础了？是不是自己的问题随便百度一下就能搜到答案？基本上不会是因为我心情不好，因为当我心情不好的时候我大概率暂时不会理你（doge）。</p>\n<p>&emsp;&emsp;我是一个大部分时候乐于分享自己的知识但是经常无法很好的用语言表达我的意思的人，所以我经常用博客的形式发布内容，因为写作的过程中有充足的时间供我思考自己如何表述。从另一个方面来讲，我是一个临场发挥极差的人，如果没有事先的准备，你直接询问我一些有深度或者摄入点很奇怪的问题，短时间内我可能无法分析到问题的本质，而是需要静下来仔细思考。</p>\n<p>&emsp;&emsp;在了解了更多的知识后，我愈发的深陷其中，无法自拔。每当我写出一个良好的设计来取代老旧的代码，我都会感到无比的自豪与骄傲；在学习到新的知识的时候，我也会异常的兴奋；看到别人（团队）设计出的非常BUG的程序，在了解大致原理后，我也会情不自禁的默默喊出“牛逼”，遇到他人也会很乐意向他“炫耀”这个设计。</p>\n<p>&emsp;&emsp;总之“站得越高，看得越远”这句话绝对不是没有道理，学到新的知识就能看到更多需要学习的内容，当你沉浸到其中的时候便能体会到探索的乐趣。</p>\n<hr>\n<p>&emsp;&emsp;写了这么多，一方面是简单记录一下我的过去，另一方面也是给大家提供一个范例。</p>\n<p>&emsp;&emsp;群里面的大佬绝不是一天练成的，所有大佬都有刚开始懵懵懂懂的时候，很多人会对大佬回避自己简单的问题甚至因此训斥自己而感到委屈和愤怒，但是这大多不是大佬傲慢不逊，而是为了点醒你。因为一味的回答你的问题并不一定是对你最好的。不同的人有不同的理念，但是有一个共同点就是培养独立能力。记住一句话：<strong>一味的依赖别人只会毁掉自己的未来</strong>。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"},{"name":"Akilar店长","link":"https://akilar.top","avatar":"https://akilar.top/img/siteicon/favicon.png","descr":"欢迎光临糖果屋","siteshot":"https://cdn.jsdelivr.net/gh/Akilarlxh/ScreenShot@gh-pages/akilar.top.jpg"}]}]}},"excerpt":"","more":"<p>&emsp;&emsp;这篇文章是我写的第一篇不以编程为主题的文章，也是第一篇日记形式的文章，以前一直在写我个人对编程中某些事物的理解和教程。从今天开始，也会多写一些和这篇类似的文章。同类的文章统一分类到<code>随心记</code>中。</p>\n<hr>\n<p>&emsp;&emsp;先说一说我的编程之旅是怎么开始的。在初一的某一天，我鼓起勇气询问我的父亲能不能给我买一本《Java从入门到精通》。他爽快的答应了我的要求，很快，一本崭新的图书便摆到了我的眼前。在刚刚拿到这本书的时候，我如获至宝，每天都抱着这本书看。但是没过多长时间，我就和大多数人一样，将这本书放到了书架上吃灰。直到初三的时候，我仍然只会写最简单的“Hello World”。</p>\n<p>&emsp;&emsp;事情的转机出现在初三的暑假，当时，我们家出去常住。临走时我随手带上了这本书，到了地方，因为谁也不认识，没有玩伴。在无聊之余便重新开始翻看这本书，可能是因为心性的成长，这不看不要紧，一看就深深的被书中的内容吸引住了。我当时用了一两个星期的时间看完了所有基础章节，回到家便迫不及待的实践起来。</p>\n<p>&emsp;&emsp;说是实践，其实也没有什么了不起的。我到现在仍然记得，我当时写了数十个各种各样的和“Hello World”难度差不多的程序。文件名从<code>A1</code>一直排到<code>C*</code>，到了后来想翻看前面的代码的时候才发现找不到在哪个文件里面写的了，也是从这时候开始，我意识到了规范命名的重要性，在研究命名的同时也顺便看了看代码规范，一个良好的编码习惯也在这是埋下了种子。</p>\n<p>&emsp;&emsp;现在再来说说我为什么会想要接触编程这个领域。我们家在我幼儿园的时候便有了电脑，刚开始还只会跟着哥哥看看动画片，到了小学，逐渐开始打起了游戏。刚开始我们一直在玩<code>4399</code>一类的网页游戏，接着，我们便不再满足于网页游戏提供的游戏体验，向本地游戏进军。随即便接触了“植物大战僵尸”之类的游戏，紧接着便是“CF”、“LOL”。到了六年级的一天，哥哥向我推荐了“MC”这款游戏。他没玩多长时间便失去了兴趣，但是我一个人坚持玩了下来。我没有满足于原版提供的游戏体验，偶然从网上了解到可以添加模组之后我便开始尝试添加模组，现在还能清晰的记得当时安装<code>JRE</code>和<code>Forge</code>就耗费了我很久很久的时间。随后又尝试了<code>IC2</code>、<code>BC</code>等工业类的模组，但是发现我想要的一些玩法模组中并没有提供，于是我便有了自己开发模组的想法。到了这时候，我已经具备了一定的网络资源搜索能力，很轻松的就在“MCBBS”上找到了<code>MCR</code>。简单的使用后我就发现它不能提供我需要的功能，随即在其讨论群中了解到了<code>Java</code>，在这里便埋下了编程的种子，也因为如此，才有了开头的一幕。</p>\n<p>&emsp;&emsp;正所谓站得越高看得越远，开始学习<code>Java</code>后我才发现我了解的知识是如此之少，并且当时距离我初一已经有了相当远的时间。把刚开始接触编程的目的忘得一干二净，并且开始尝试写各式各样的<del>小程序</del>（黑历史），当时还恬不知耻的发到了哔哩哔哩上面，后来相当一部分都被我删除了（想翻我黑历史的可以放弃了）。</p>\n<p>&emsp;&emsp;后来我也思考过我为什么可以坚持下来继续学习编程，我想很大一部分原因是我当时选择跳过一部分基础内容直接学习图形化开发。因为接触了图形化开发，我可以写出各式各样的能用肉眼看到效果并且可以获得周围人们称赞的程序。这种学习方法确时有显著的缺陷，当学习后面内容的时候很容易涉及到基础内容，遇到不懂的基础内容要么比葫芦画瓢应付过去，要么仔细研究一下再继续。不过我想，对于自学并且没有信心坚持下去的人，这不失为一种好方法。至于我们这些在校大学生，学习编程的大多都是学校要求，周围的人也是懂得，就算不写出来图形界面，他们也可以看出你的代码的亮点（不能看出来的话就更好炫耀了doge（雾）），这种时候这个学习方法的优势便不那么明显了。</p>\n<p>&emsp;&emsp;直到高二的时候我才突然想起来我的初衷，随即用了好几个星期的时间构建了开发环境，并且开始着手写下我的第一个MC作品。我没有像其他人那样先写一些简单的玩意，而是直接开始着手写我<a href=\"https://afdian.net/@emptydreams\">最终想要的作品——现代工业-MI</a>（一波猝不及防的广告doge）。这个骚操作不得不说给我造成了一些麻烦，因为我后面有很长时间都用来改掉原先写的死板、累赘的代码设计。</p>\n<p>&emsp;&emsp;学习开发模组的过程中也认识了许许多多的大佬，中间有一个人让我受益匪浅。我经常向他询问问题，到后面我们也会讨论一些问题，当我写出一个代码设计的时候也会让他帮忙“评分”。不得不说这几年我确时获益良多，不仅锻炼了编码能力、结构设计能力，也学习了许多关于JVM的知识。</p>\n<p>&emsp;&emsp;在我刚刚学完Java的基本内容的时候，我可以非常耐心的给任何人回答所有合理的问题。但是随着时间的推移，我渐渐的不再有耐心的千篇一律的回答那些非常基础的问题。所以有些人可能会很奇怪我有时候对不同的人态度不一样，甚至同一个人不同时候态度也会不一样，如果你发现我回答你的问题的时候态度不好，大多时候你应该反思一下是不是自己问的问题太基础了？是不是自己的问题随便百度一下就能搜到答案？基本上不会是因为我心情不好，因为当我心情不好的时候我大概率暂时不会理你（doge）。</p>\n<p>&emsp;&emsp;我是一个大部分时候乐于分享自己的知识但是经常无法很好的用语言表达我的意思的人，所以我经常用博客的形式发布内容，因为写作的过程中有充足的时间供我思考自己如何表述。从另一个方面来讲，我是一个临场发挥极差的人，如果没有事先的准备，你直接询问我一些有深度或者摄入点很奇怪的问题，短时间内我可能无法分析到问题的本质，而是需要静下来仔细思考。</p>\n<p>&emsp;&emsp;在了解了更多的知识后，我愈发的深陷其中，无法自拔。每当我写出一个良好的设计来取代老旧的代码，我都会感到无比的自豪与骄傲；在学习到新的知识的时候，我也会异常的兴奋；看到别人（团队）设计出的非常BUG的程序，在了解大致原理后，我也会情不自禁的默默喊出“牛逼”，遇到他人也会很乐意向他“炫耀”这个设计。</p>\n<p>&emsp;&emsp;总之“站得越高，看得越远”这句话绝对不是没有道理，学到新的知识就能看到更多需要学习的内容，当你沉浸到其中的时候便能体会到探索的乐趣。</p>\n<hr>\n<p>&emsp;&emsp;写了这么多，一方面是简单记录一下我的过去，另一方面也是给大家提供一个范例。</p>\n<p>&emsp;&emsp;群里面的大佬绝不是一天练成的，所有大佬都有刚开始懵懵懂懂的时候，很多人会对大佬回避自己简单的问题甚至因此训斥自己而感到委屈和愤怒，但是这大多不是大佬傲慢不逊，而是为了点醒你。因为一味的回答你的问题并不一定是对你最好的。不同的人有不同的理念，但是有一个共同点就是培养独立能力。记住一句话：<strong>一味的依赖别人只会毁掉自己的未来</strong>。</p>\n"},{"title":"浮点数的二进制表示","date":"2021-10-20T13:42:32.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b13.jpeg","description":"简单描述IEEE754标准的浮点数的二进制表示方式","_content":"\n\n\n**注意：阅读本文前请务必了解基本的二进制知识，详情可见：[二进制运算从入门到入坟](https://blog.emptydreams.xyz/binary/)。**\n\n**&emsp;&emsp;&emsp;如果没有明确指出，本文均使用`double`作为例子**\n\n# IEEE754\n\n&emsp;&emsp;`IEEE 754`是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。这个标准确定了以下内容：\n\n<ul>\n    <li>标准化正浮点数和负浮点数</li>\n    <li>如何表示正负非规范化浮点数</li>\n    <li>如何表示0</li>\n    <li>如何表示无穷数（Infiniti）</li>\n    <li>四种数值舍入规则</li>\n</ul>\n\n&emsp;&emsp;同时`IEEE 754`还定义了四种浮点数格式：\n\n<ul>\n    <li>32位单精度(float)</li>\n    <li>64位双精度(double)</li>\n    <li>(>= 43)位单扩展精度</li>\n    <li>(>= 79)位双扩展精度（一般用80位）</li>\n</ul>\n\n&emsp;&emsp;因为后两种格式并不常用，所以这里只说前两种`float`和`double`。\n\n# 小数的二进制表示\n\n&emsp;&emsp;我们先来了解小数的二进制表示。现在我们将一个十进制小数：`5.8125`转换为二进制：\n\n&emsp;&emsp;第一步：先将整数部分转换为二进制`101`\n\n&emsp;&emsp;第二步：将小数部分转换为二进制，方法为将小数部分乘以2取整，直至变为1\n\n```\n0.8125 * 2 = 1.6250 ------ 取 1\n0.6250 * 2 = 1.2500 ------ 取 1\n0.2500 * 2 = 0.5000 ------ 取 0\n0.5000 * 2 = 1.0000 ------ 取 1\n最终结果为：1101\n```\n\n&emsp;&emsp;第三步：得出答案`101.1101`\n\n# 二进制科学计数法\n\n&emsp;&emsp;我们在小学时期就接触过“科学计数法”，即1.x * 10^b。这种方式就是十进制的科学计数法，为了了解浮点数的二进制表示方法，我们必须先知道二进制的科学计数法。\n\n&emsp;&emsp;比如我们要用科学计数法表示`105`，十进制的表示方式为`1.05 * 10^2`。想用二进制表示的话需要先将`105`转换为二进制`1101001`，这时我们可以知道其科学计数法的表示为`1.101001 * 2^6`。（注：这里没有把指数换成二进制）\n\n# 浮点数内存分配\n\n|    总长度     | S-符号位(bit) | E-偏移指数位(bit) | M-尾数位(bit) |\n| :-----------: | :-----------: | :---------------: | :-----------: |\n| 32bit(folat)  |       1       |         8         |      23       |\n| 64bit(double) |       1       |        11         |      52       |\n\n&emsp;&emsp;存储形式见下图：\n\n![浮点数内存结构示意图](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/float/ieee754_1.jpg)\n\n## 符号位\n\n&emsp;&emsp;符号位很简单，`0`表示正数，`1`表示负数。\n\n## 指数位\n\n&emsp;&emsp;指数位并没有直接存储指数`e`，而是存储了偏移后的指数`E`。\n\n### 关系式\n\n&emsp;&emsp;我们假定`b`表示偏移量，则有如下关系式：`E = e + b`。\n\n### 偏移量表\n\n| 长度(bit)  | 偏移量b(十进制 - 二进制) |\n| :--------: | :----------------------: |\n| 32(float)  |      127 - 1111111       |\n| 64(double) |    1023 - 1111111111     |\n\n### 如何求得偏移量\n\n&emsp;&emsp;观察可以发现，偏移量的二进制表达式所有位均为`1`，位数为`指数位长度 - 1`，通过这个规律我们便可以求得偏移量的具体值。\n\n### 为什么存储偏移量\n\n&emsp;&emsp;我们很简单就能发现，如果使用补码表示指数，在比较浮点数大小的时候会变得很复杂，举个栗子：\n\n```\n假设数据共4bit\n比较 -8 和 7\n-8 的补码为 1000 | 7 的补码为 0111\n如果直接通过比较就会得到 1000 > 0111\n这显然是不合理的\n```\n\n&emsp;&emsp;所以这里把负数全部转换为正数进行存储，在运算的时候比较浮点数大小也变得更加简单。\n\n### 两个特殊值\n\n&emsp;&emsp;`double`的指数位有11位，可以表示`[0, 2047]`的数字，但是标准排除了最小值和最大值两个数字，所以指数表示的范围最终为`[1, 2046]`，被排除的两个数字用来表示特殊的数据，后面会详细描述。\n\n## 尾数位\n\n&emsp;&emsp;尾数位存储的内容是二进制科学计数法前方的数字，假如我们要存储`5.8125`，那么尾数就是`1.101001`。我们可以注意到，尾数的整数部分一定为`1`，所以整数部分不再存储，只存储小数部分即可，所以虽然`double`的尾数为只有52位，实际上却存储了53位的数据。\n\n&emsp;&emsp;如果尾数长度不足最大尾数，则在尾数后面补`0`。\n\n## 示例\n\n&emsp;&emsp;`5.8125`的`double`二进制表示为：`0_10000000_10100100000000000000000`。\n\n# 零的表示方法\n\n&emsp;&emsp;看了上面的内容，细心的读者可能会发现一个问题，这种表示方式如何表示`0`？因为尾数永远是`1.*`，所以常规表示方式永远也不可能表示出`0`这个数，最多尽量接近`0`。这时候上文提到的两个特殊值中的一个便派上了用场。当指数位和尾数位全部为`0`时表示该数为`0`，即`0`的二进制表达式为（float）`0_00000000_00000000000000000000000`（符号位可以为`1`）。\n\n# 非规约数\n\n&emsp;&emsp;如果浮点数的指数部分的编码值是`0`，分数部分非零，那么这个浮点数将被称为**非规约形式的浮点数**。一般是某个数字**相当**接近零时才会使用非规约型式来表示。 `IEEE 754`标准规定：**非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1**。例如，最小的规约形式的单精度浮点数的指数部分编码值为`1`，指数的实际值为`-126`；而非规约的单精度浮点数的指数域编码值为`0`，对应的指数实际值也是`-126`而不是`-127`。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近`0`。规约浮点数的尾数大于等于`1`且小于`2`，而非规约浮点数的尾数小于`1`且大于`0`。\n\n# 无穷大的表示方法\n\n&emsp;&emsp;现在还有一个特殊值没有用到，即指数为`2047`的情况。规范规定，当指数位全部为`1`并且尾数位全部为`0`时表示该数是一个无穷数，根据符号位的不同分为正无穷和负无穷。\n\n# NaN\n\n&emsp;&emsp;`NaN`的全拼是“Not a Number”，顾名思义，其表示这不是一个有效的数字。指数位全为`1`但尾数位不全为`0`的数字均为`NaN`，可以看出`NaN`有许多表达式。在一个`NaN`与其它数字（包括`NaN`）判断是否相等时一定返回`false`，同时因为`NaN`内部是有值的，只是其不能正确的表示数字，所以其并不是一个空值，也不能使用空值来判断其是否为`NaN`。\n\n&emsp;&emsp;为此，在`math.h`中定义了一个函数`isnan(x)`，该函数用于判断数字是否为NaN。还有一个于其对应的函数`isnormal(x)`，该函数用于判断数字是否为一个正常的数字，当数字为`0`、无穷数、NaN时会返回`false`，否则返回`true`。\n\n# 参考资料\n\n>[IEEE 754 - Standard binary floating point arithmetic](http://www.softelectro.ru/ieee754_en.html)\n>\n>[CSDN - 理解浮点数的二进制表示](https://blog.csdn.net/S_o_l_o_n/article/details/106438708)\n>\n>[百度百科]([IEEE 754_百度百科 (baidu.com)](https://baike.baidu.com/item/IEEE 754/3869922?fr=aladdin))\n","source":"_posts/float.md","raw":"---\ntitle: 浮点数的二进制表示\ndate: 2021-10-20 21:42:32\ncategories:\n  - 通用\ntags:\n  - 教程\n  - 进制\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b13.jpeg\ndescription: 简单描述IEEE754标准的浮点数的二进制表示方式\n---\n\n\n\n**注意：阅读本文前请务必了解基本的二进制知识，详情可见：[二进制运算从入门到入坟](https://blog.emptydreams.xyz/binary/)。**\n\n**&emsp;&emsp;&emsp;如果没有明确指出，本文均使用`double`作为例子**\n\n# IEEE754\n\n&emsp;&emsp;`IEEE 754`是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。这个标准确定了以下内容：\n\n<ul>\n    <li>标准化正浮点数和负浮点数</li>\n    <li>如何表示正负非规范化浮点数</li>\n    <li>如何表示0</li>\n    <li>如何表示无穷数（Infiniti）</li>\n    <li>四种数值舍入规则</li>\n</ul>\n\n&emsp;&emsp;同时`IEEE 754`还定义了四种浮点数格式：\n\n<ul>\n    <li>32位单精度(float)</li>\n    <li>64位双精度(double)</li>\n    <li>(>= 43)位单扩展精度</li>\n    <li>(>= 79)位双扩展精度（一般用80位）</li>\n</ul>\n\n&emsp;&emsp;因为后两种格式并不常用，所以这里只说前两种`float`和`double`。\n\n# 小数的二进制表示\n\n&emsp;&emsp;我们先来了解小数的二进制表示。现在我们将一个十进制小数：`5.8125`转换为二进制：\n\n&emsp;&emsp;第一步：先将整数部分转换为二进制`101`\n\n&emsp;&emsp;第二步：将小数部分转换为二进制，方法为将小数部分乘以2取整，直至变为1\n\n```\n0.8125 * 2 = 1.6250 ------ 取 1\n0.6250 * 2 = 1.2500 ------ 取 1\n0.2500 * 2 = 0.5000 ------ 取 0\n0.5000 * 2 = 1.0000 ------ 取 1\n最终结果为：1101\n```\n\n&emsp;&emsp;第三步：得出答案`101.1101`\n\n# 二进制科学计数法\n\n&emsp;&emsp;我们在小学时期就接触过“科学计数法”，即1.x * 10^b。这种方式就是十进制的科学计数法，为了了解浮点数的二进制表示方法，我们必须先知道二进制的科学计数法。\n\n&emsp;&emsp;比如我们要用科学计数法表示`105`，十进制的表示方式为`1.05 * 10^2`。想用二进制表示的话需要先将`105`转换为二进制`1101001`，这时我们可以知道其科学计数法的表示为`1.101001 * 2^6`。（注：这里没有把指数换成二进制）\n\n# 浮点数内存分配\n\n|    总长度     | S-符号位(bit) | E-偏移指数位(bit) | M-尾数位(bit) |\n| :-----------: | :-----------: | :---------------: | :-----------: |\n| 32bit(folat)  |       1       |         8         |      23       |\n| 64bit(double) |       1       |        11         |      52       |\n\n&emsp;&emsp;存储形式见下图：\n\n![浮点数内存结构示意图](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/float/ieee754_1.jpg)\n\n## 符号位\n\n&emsp;&emsp;符号位很简单，`0`表示正数，`1`表示负数。\n\n## 指数位\n\n&emsp;&emsp;指数位并没有直接存储指数`e`，而是存储了偏移后的指数`E`。\n\n### 关系式\n\n&emsp;&emsp;我们假定`b`表示偏移量，则有如下关系式：`E = e + b`。\n\n### 偏移量表\n\n| 长度(bit)  | 偏移量b(十进制 - 二进制) |\n| :--------: | :----------------------: |\n| 32(float)  |      127 - 1111111       |\n| 64(double) |    1023 - 1111111111     |\n\n### 如何求得偏移量\n\n&emsp;&emsp;观察可以发现，偏移量的二进制表达式所有位均为`1`，位数为`指数位长度 - 1`，通过这个规律我们便可以求得偏移量的具体值。\n\n### 为什么存储偏移量\n\n&emsp;&emsp;我们很简单就能发现，如果使用补码表示指数，在比较浮点数大小的时候会变得很复杂，举个栗子：\n\n```\n假设数据共4bit\n比较 -8 和 7\n-8 的补码为 1000 | 7 的补码为 0111\n如果直接通过比较就会得到 1000 > 0111\n这显然是不合理的\n```\n\n&emsp;&emsp;所以这里把负数全部转换为正数进行存储，在运算的时候比较浮点数大小也变得更加简单。\n\n### 两个特殊值\n\n&emsp;&emsp;`double`的指数位有11位，可以表示`[0, 2047]`的数字，但是标准排除了最小值和最大值两个数字，所以指数表示的范围最终为`[1, 2046]`，被排除的两个数字用来表示特殊的数据，后面会详细描述。\n\n## 尾数位\n\n&emsp;&emsp;尾数位存储的内容是二进制科学计数法前方的数字，假如我们要存储`5.8125`，那么尾数就是`1.101001`。我们可以注意到，尾数的整数部分一定为`1`，所以整数部分不再存储，只存储小数部分即可，所以虽然`double`的尾数为只有52位，实际上却存储了53位的数据。\n\n&emsp;&emsp;如果尾数长度不足最大尾数，则在尾数后面补`0`。\n\n## 示例\n\n&emsp;&emsp;`5.8125`的`double`二进制表示为：`0_10000000_10100100000000000000000`。\n\n# 零的表示方法\n\n&emsp;&emsp;看了上面的内容，细心的读者可能会发现一个问题，这种表示方式如何表示`0`？因为尾数永远是`1.*`，所以常规表示方式永远也不可能表示出`0`这个数，最多尽量接近`0`。这时候上文提到的两个特殊值中的一个便派上了用场。当指数位和尾数位全部为`0`时表示该数为`0`，即`0`的二进制表达式为（float）`0_00000000_00000000000000000000000`（符号位可以为`1`）。\n\n# 非规约数\n\n&emsp;&emsp;如果浮点数的指数部分的编码值是`0`，分数部分非零，那么这个浮点数将被称为**非规约形式的浮点数**。一般是某个数字**相当**接近零时才会使用非规约型式来表示。 `IEEE 754`标准规定：**非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1**。例如，最小的规约形式的单精度浮点数的指数部分编码值为`1`，指数的实际值为`-126`；而非规约的单精度浮点数的指数域编码值为`0`，对应的指数实际值也是`-126`而不是`-127`。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近`0`。规约浮点数的尾数大于等于`1`且小于`2`，而非规约浮点数的尾数小于`1`且大于`0`。\n\n# 无穷大的表示方法\n\n&emsp;&emsp;现在还有一个特殊值没有用到，即指数为`2047`的情况。规范规定，当指数位全部为`1`并且尾数位全部为`0`时表示该数是一个无穷数，根据符号位的不同分为正无穷和负无穷。\n\n# NaN\n\n&emsp;&emsp;`NaN`的全拼是“Not a Number”，顾名思义，其表示这不是一个有效的数字。指数位全为`1`但尾数位不全为`0`的数字均为`NaN`，可以看出`NaN`有许多表达式。在一个`NaN`与其它数字（包括`NaN`）判断是否相等时一定返回`false`，同时因为`NaN`内部是有值的，只是其不能正确的表示数字，所以其并不是一个空值，也不能使用空值来判断其是否为`NaN`。\n\n&emsp;&emsp;为此，在`math.h`中定义了一个函数`isnan(x)`，该函数用于判断数字是否为NaN。还有一个于其对应的函数`isnormal(x)`，该函数用于判断数字是否为一个正常的数字，当数字为`0`、无穷数、NaN时会返回`false`，否则返回`true`。\n\n# 参考资料\n\n>[IEEE 754 - Standard binary floating point arithmetic](http://www.softelectro.ru/ieee754_en.html)\n>\n>[CSDN - 理解浮点数的二进制表示](https://blog.csdn.net/S_o_l_o_n/article/details/106438708)\n>\n>[百度百科]([IEEE 754_百度百科 (baidu.com)](https://baike.baidu.com/item/IEEE 754/3869922?fr=aladdin))\n","slug":"float","published":1,"updated":"2021-10-21T09:48:20.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvdzwpgt000ah8wq5gik3hfs","content":"<p><strong>注意：阅读本文前请务必了解基本的二进制知识，详情可见：<a href=\"https://blog.emptydreams.xyz/binary/\">二进制运算从入门到入坟</a>。</strong></p>\n<p><strong>&emsp;&emsp;&emsp;如果没有明确指出，本文均使用<code>double</code>作为例子</strong></p>\n<h1 id=\"IEEE754\"><a href=\"#IEEE754\" class=\"headerlink\" title=\"IEEE754\"></a>IEEE754</h1><p>&emsp;&emsp;<code>IEEE 754</code>是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。这个标准确定了以下内容：</p>\n<ul>\n    <li>标准化正浮点数和负浮点数</li>\n    <li>如何表示正负非规范化浮点数</li>\n    <li>如何表示0</li>\n    <li>如何表示无穷数（Infiniti）</li>\n    <li>四种数值舍入规则</li>\n</ul>\n\n<p>&emsp;&emsp;同时<code>IEEE 754</code>还定义了四种浮点数格式：</p>\n<ul>\n    <li>32位单精度(float)</li>\n    <li>64位双精度(double)</li>\n    <li>(>= 43)位单扩展精度</li>\n    <li>(>= 79)位双扩展精度（一般用80位）</li>\n</ul>\n\n<p>&emsp;&emsp;因为后两种格式并不常用，所以这里只说前两种<code>float</code>和<code>double</code>。</p>\n<h1 id=\"小数的二进制表示\"><a href=\"#小数的二进制表示\" class=\"headerlink\" title=\"小数的二进制表示\"></a>小数的二进制表示</h1><p>&emsp;&emsp;我们先来了解小数的二进制表示。现在我们将一个十进制小数：<code>5.8125</code>转换为二进制：</p>\n<p>&emsp;&emsp;第一步：先将整数部分转换为二进制<code>101</code></p>\n<p>&emsp;&emsp;第二步：将小数部分转换为二进制，方法为将小数部分乘以2取整，直至变为1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">0.8125 * 2 = 1.6250 ------ 取 1<br>0.6250 * 2 = 1.2500 ------ 取 1<br>0.2500 * 2 = 0.5000 ------ 取 0<br>0.5000 * 2 = 1.0000 ------ 取 1<br>最终结果为：1101<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;第三步：得出答案<code>101.1101</code></p>\n<h1 id=\"二进制科学计数法\"><a href=\"#二进制科学计数法\" class=\"headerlink\" title=\"二进制科学计数法\"></a>二进制科学计数法</h1><p>&emsp;&emsp;我们在小学时期就接触过“科学计数法”，即1.x * 10^b。这种方式就是十进制的科学计数法，为了了解浮点数的二进制表示方法，我们必须先知道二进制的科学计数法。</p>\n<p>&emsp;&emsp;比如我们要用科学计数法表示<code>105</code>，十进制的表示方式为<code>1.05 * 10^2</code>。想用二进制表示的话需要先将<code>105</code>转换为二进制<code>1101001</code>，这时我们可以知道其科学计数法的表示为<code>1.101001 * 2^6</code>。（注：这里没有把指数换成二进制）</p>\n<h1 id=\"浮点数内存分配\"><a href=\"#浮点数内存分配\" class=\"headerlink\" title=\"浮点数内存分配\"></a>浮点数内存分配</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">总长度</th>\n<th style=\"text-align:center\">S-符号位(bit)</th>\n<th style=\"text-align:center\">E-偏移指数位(bit)</th>\n<th style=\"text-align:center\">M-尾数位(bit)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">32bit(folat)</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">23</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">64bit(double)</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">52</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>&emsp;&emsp;存储形式见下图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/float/ieee754_1.jpg\" alt=\"浮点数内存结构示意图\"></p>\n<h2 id=\"符号位\"><a href=\"#符号位\" class=\"headerlink\" title=\"符号位\"></a>符号位</h2><p>&emsp;&emsp;符号位很简单，<code>0</code>表示正数，<code>1</code>表示负数。</p>\n<h2 id=\"指数位\"><a href=\"#指数位\" class=\"headerlink\" title=\"指数位\"></a>指数位</h2><p>&emsp;&emsp;指数位并没有直接存储指数<code>e</code>，而是存储了偏移后的指数<code>E</code>。</p>\n<h3 id=\"关系式\"><a href=\"#关系式\" class=\"headerlink\" title=\"关系式\"></a>关系式</h3><p>&emsp;&emsp;我们假定<code>b</code>表示偏移量，则有如下关系式：<code>E = e + b</code>。</p>\n<h3 id=\"偏移量表\"><a href=\"#偏移量表\" class=\"headerlink\" title=\"偏移量表\"></a>偏移量表</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">长度(bit)</th>\n<th style=\"text-align:center\">偏移量b(十进制 - 二进制)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">32(float)</td>\n<td style=\"text-align:center\">127 - 1111111</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">64(double)</td>\n<td style=\"text-align:center\">1023 - 1111111111</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"如何求得偏移量\"><a href=\"#如何求得偏移量\" class=\"headerlink\" title=\"如何求得偏移量\"></a>如何求得偏移量</h3><p>&emsp;&emsp;观察可以发现，偏移量的二进制表达式所有位均为<code>1</code>，位数为<code>指数位长度 - 1</code>，通过这个规律我们便可以求得偏移量的具体值。</p>\n<h3 id=\"为什么存储偏移量\"><a href=\"#为什么存储偏移量\" class=\"headerlink\" title=\"为什么存储偏移量\"></a>为什么存储偏移量</h3><p>&emsp;&emsp;我们很简单就能发现，如果使用补码表示指数，在比较浮点数大小的时候会变得很复杂，举个栗子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">假设数据共4bit<br>比较 -8 和 7<br>-8 的补码为 1000 | 7 的补码为 0111<br>如果直接通过比较就会得到 1000 &gt; 0111<br>这显然是不合理的<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;所以这里把负数全部转换为正数进行存储，在运算的时候比较浮点数大小也变得更加简单。</p>\n<h3 id=\"两个特殊值\"><a href=\"#两个特殊值\" class=\"headerlink\" title=\"两个特殊值\"></a>两个特殊值</h3><p>&emsp;&emsp;<code>double</code>的指数位有11位，可以表示<code>[0, 2047]</code>的数字，但是标准排除了最小值和最大值两个数字，所以指数表示的范围最终为<code>[1, 2046]</code>，被排除的两个数字用来表示特殊的数据，后面会详细描述。</p>\n<h2 id=\"尾数位\"><a href=\"#尾数位\" class=\"headerlink\" title=\"尾数位\"></a>尾数位</h2><p>&emsp;&emsp;尾数位存储的内容是二进制科学计数法前方的数字，假如我们要存储<code>5.8125</code>，那么尾数就是<code>1.101001</code>。我们可以注意到，尾数的整数部分一定为<code>1</code>，所以整数部分不再存储，只存储小数部分即可，所以虽然<code>double</code>的尾数为只有52位，实际上却存储了53位的数据。</p>\n<p>&emsp;&emsp;如果尾数长度不足最大尾数，则在尾数后面补<code>0</code>。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>&emsp;&emsp;<code>5.8125</code>的<code>double</code>二进制表示为：<code>0_10000000_10100100000000000000000</code>。</p>\n<h1 id=\"零的表示方法\"><a href=\"#零的表示方法\" class=\"headerlink\" title=\"零的表示方法\"></a>零的表示方法</h1><p>&emsp;&emsp;看了上面的内容，细心的读者可能会发现一个问题，这种表示方式如何表示<code>0</code>？因为尾数永远是<code>1.*</code>，所以常规表示方式永远也不可能表示出<code>0</code>这个数，最多尽量接近<code>0</code>。这时候上文提到的两个特殊值中的一个便派上了用场。当指数位和尾数位全部为<code>0</code>时表示该数为<code>0</code>，即<code>0</code>的二进制表达式为（float）<code>0_00000000_00000000000000000000000</code>（符号位可以为<code>1</code>）。</p>\n<h1 id=\"非规约数\"><a href=\"#非规约数\" class=\"headerlink\" title=\"非规约数\"></a>非规约数</h1><p>&emsp;&emsp;如果浮点数的指数部分的编码值是<code>0</code>，分数部分非零，那么这个浮点数将被称为<strong>非规约形式的浮点数</strong>。一般是某个数字<strong>相当</strong>接近零时才会使用非规约型式来表示。 <code>IEEE 754</code>标准规定：<strong>非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1</strong>。例如，最小的规约形式的单精度浮点数的指数部分编码值为<code>1</code>，指数的实际值为<code>-126</code>；而非规约的单精度浮点数的指数域编码值为<code>0</code>，对应的指数实际值也是<code>-126</code>而不是<code>-127</code>。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近<code>0</code>。规约浮点数的尾数大于等于<code>1</code>且小于<code>2</code>，而非规约浮点数的尾数小于<code>1</code>且大于<code>0</code>。</p>\n<h1 id=\"无穷大的表示方法\"><a href=\"#无穷大的表示方法\" class=\"headerlink\" title=\"无穷大的表示方法\"></a>无穷大的表示方法</h1><p>&emsp;&emsp;现在还有一个特殊值没有用到，即指数为<code>2047</code>的情况。规范规定，当指数位全部为<code>1</code>并且尾数位全部为<code>0</code>时表示该数是一个无穷数，根据符号位的不同分为正无穷和负无穷。</p>\n<h1 id=\"NaN\"><a href=\"#NaN\" class=\"headerlink\" title=\"NaN\"></a>NaN</h1><p>&emsp;&emsp;<code>NaN</code>的全拼是“Not a Number”，顾名思义，其表示这不是一个有效的数字。指数位全为<code>1</code>但尾数位不全为<code>0</code>的数字均为<code>NaN</code>，可以看出<code>NaN</code>有许多表达式。在一个<code>NaN</code>与其它数字（包括<code>NaN</code>）判断是否相等时一定返回<code>false</code>，同时因为<code>NaN</code>内部是有值的，只是其不能正确的表示数字，所以其并不是一个空值，也不能使用空值来判断其是否为<code>NaN</code>。</p>\n<p>&emsp;&emsp;为此，在<code>math.h</code>中定义了一个函数<code>isnan(x)</code>，该函数用于判断数字是否为NaN。还有一个于其对应的函数<code>isnormal(x)</code>，该函数用于判断数字是否为一个正常的数字，当数字为<code>0</code>、无穷数、NaN时会返回<code>false</code>，否则返回<code>true</code>。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<p><a href=\"http://www.softelectro.ru/ieee754_en.html\">IEEE 754 - Standard binary floating point arithmetic</a></p>\n<p><a href=\"https://blog.csdn.net/S_o_l_o_n/article/details/106438708\">CSDN - 理解浮点数的二进制表示</a></p>\n<p><a href=\"[IEEE 754_百度百科 (baidu.com\">百度百科</a>](<a href=\"https://baike.baidu.com/item/IEEE\">https://baike.baidu.com/item/IEEE</a> 754/3869922?fr=aladdin))</p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"},{"name":"Akilar店长","link":"https://akilar.top","avatar":"https://akilar.top/img/siteicon/favicon.png","descr":"欢迎光临糖果屋","siteshot":"https://cdn.jsdelivr.net/gh/Akilarlxh/ScreenShot@gh-pages/akilar.top.jpg"}]}]}},"excerpt":"","more":"<p><strong>注意：阅读本文前请务必了解基本的二进制知识，详情可见：<a href=\"https://blog.emptydreams.xyz/binary/\">二进制运算从入门到入坟</a>。</strong></p>\n<p><strong>&emsp;&emsp;&emsp;如果没有明确指出，本文均使用<code>double</code>作为例子</strong></p>\n<h1 id=\"IEEE754\"><a href=\"#IEEE754\" class=\"headerlink\" title=\"IEEE754\"></a>IEEE754</h1><p>&emsp;&emsp;<code>IEEE 754</code>是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。这个标准确定了以下内容：</p>\n<ul>\n    <li>标准化正浮点数和负浮点数</li>\n    <li>如何表示正负非规范化浮点数</li>\n    <li>如何表示0</li>\n    <li>如何表示无穷数（Infiniti）</li>\n    <li>四种数值舍入规则</li>\n</ul>\n\n<p>&emsp;&emsp;同时<code>IEEE 754</code>还定义了四种浮点数格式：</p>\n<ul>\n    <li>32位单精度(float)</li>\n    <li>64位双精度(double)</li>\n    <li>(>= 43)位单扩展精度</li>\n    <li>(>= 79)位双扩展精度（一般用80位）</li>\n</ul>\n\n<p>&emsp;&emsp;因为后两种格式并不常用，所以这里只说前两种<code>float</code>和<code>double</code>。</p>\n<h1 id=\"小数的二进制表示\"><a href=\"#小数的二进制表示\" class=\"headerlink\" title=\"小数的二进制表示\"></a>小数的二进制表示</h1><p>&emsp;&emsp;我们先来了解小数的二进制表示。现在我们将一个十进制小数：<code>5.8125</code>转换为二进制：</p>\n<p>&emsp;&emsp;第一步：先将整数部分转换为二进制<code>101</code></p>\n<p>&emsp;&emsp;第二步：将小数部分转换为二进制，方法为将小数部分乘以2取整，直至变为1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">0.8125 * 2 = 1.6250 ------ 取 1<br>0.6250 * 2 = 1.2500 ------ 取 1<br>0.2500 * 2 = 0.5000 ------ 取 0<br>0.5000 * 2 = 1.0000 ------ 取 1<br>最终结果为：1101<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;第三步：得出答案<code>101.1101</code></p>\n<h1 id=\"二进制科学计数法\"><a href=\"#二进制科学计数法\" class=\"headerlink\" title=\"二进制科学计数法\"></a>二进制科学计数法</h1><p>&emsp;&emsp;我们在小学时期就接触过“科学计数法”，即1.x * 10^b。这种方式就是十进制的科学计数法，为了了解浮点数的二进制表示方法，我们必须先知道二进制的科学计数法。</p>\n<p>&emsp;&emsp;比如我们要用科学计数法表示<code>105</code>，十进制的表示方式为<code>1.05 * 10^2</code>。想用二进制表示的话需要先将<code>105</code>转换为二进制<code>1101001</code>，这时我们可以知道其科学计数法的表示为<code>1.101001 * 2^6</code>。（注：这里没有把指数换成二进制）</p>\n<h1 id=\"浮点数内存分配\"><a href=\"#浮点数内存分配\" class=\"headerlink\" title=\"浮点数内存分配\"></a>浮点数内存分配</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">总长度</th>\n<th style=\"text-align:center\">S-符号位(bit)</th>\n<th style=\"text-align:center\">E-偏移指数位(bit)</th>\n<th style=\"text-align:center\">M-尾数位(bit)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">32bit(folat)</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">23</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">64bit(double)</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">11</td>\n<td style=\"text-align:center\">52</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>&emsp;&emsp;存储形式见下图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/float/ieee754_1.jpg\" alt=\"浮点数内存结构示意图\"></p>\n<h2 id=\"符号位\"><a href=\"#符号位\" class=\"headerlink\" title=\"符号位\"></a>符号位</h2><p>&emsp;&emsp;符号位很简单，<code>0</code>表示正数，<code>1</code>表示负数。</p>\n<h2 id=\"指数位\"><a href=\"#指数位\" class=\"headerlink\" title=\"指数位\"></a>指数位</h2><p>&emsp;&emsp;指数位并没有直接存储指数<code>e</code>，而是存储了偏移后的指数<code>E</code>。</p>\n<h3 id=\"关系式\"><a href=\"#关系式\" class=\"headerlink\" title=\"关系式\"></a>关系式</h3><p>&emsp;&emsp;我们假定<code>b</code>表示偏移量，则有如下关系式：<code>E = e + b</code>。</p>\n<h3 id=\"偏移量表\"><a href=\"#偏移量表\" class=\"headerlink\" title=\"偏移量表\"></a>偏移量表</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">长度(bit)</th>\n<th style=\"text-align:center\">偏移量b(十进制 - 二进制)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">32(float)</td>\n<td style=\"text-align:center\">127 - 1111111</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">64(double)</td>\n<td style=\"text-align:center\">1023 - 1111111111</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"如何求得偏移量\"><a href=\"#如何求得偏移量\" class=\"headerlink\" title=\"如何求得偏移量\"></a>如何求得偏移量</h3><p>&emsp;&emsp;观察可以发现，偏移量的二进制表达式所有位均为<code>1</code>，位数为<code>指数位长度 - 1</code>，通过这个规律我们便可以求得偏移量的具体值。</p>\n<h3 id=\"为什么存储偏移量\"><a href=\"#为什么存储偏移量\" class=\"headerlink\" title=\"为什么存储偏移量\"></a>为什么存储偏移量</h3><p>&emsp;&emsp;我们很简单就能发现，如果使用补码表示指数，在比较浮点数大小的时候会变得很复杂，举个栗子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">假设数据共4bit<br>比较 -8 和 7<br>-8 的补码为 1000 | 7 的补码为 0111<br>如果直接通过比较就会得到 1000 &gt; 0111<br>这显然是不合理的<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;所以这里把负数全部转换为正数进行存储，在运算的时候比较浮点数大小也变得更加简单。</p>\n<h3 id=\"两个特殊值\"><a href=\"#两个特殊值\" class=\"headerlink\" title=\"两个特殊值\"></a>两个特殊值</h3><p>&emsp;&emsp;<code>double</code>的指数位有11位，可以表示<code>[0, 2047]</code>的数字，但是标准排除了最小值和最大值两个数字，所以指数表示的范围最终为<code>[1, 2046]</code>，被排除的两个数字用来表示特殊的数据，后面会详细描述。</p>\n<h2 id=\"尾数位\"><a href=\"#尾数位\" class=\"headerlink\" title=\"尾数位\"></a>尾数位</h2><p>&emsp;&emsp;尾数位存储的内容是二进制科学计数法前方的数字，假如我们要存储<code>5.8125</code>，那么尾数就是<code>1.101001</code>。我们可以注意到，尾数的整数部分一定为<code>1</code>，所以整数部分不再存储，只存储小数部分即可，所以虽然<code>double</code>的尾数为只有52位，实际上却存储了53位的数据。</p>\n<p>&emsp;&emsp;如果尾数长度不足最大尾数，则在尾数后面补<code>0</code>。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>&emsp;&emsp;<code>5.8125</code>的<code>double</code>二进制表示为：<code>0_10000000_10100100000000000000000</code>。</p>\n<h1 id=\"零的表示方法\"><a href=\"#零的表示方法\" class=\"headerlink\" title=\"零的表示方法\"></a>零的表示方法</h1><p>&emsp;&emsp;看了上面的内容，细心的读者可能会发现一个问题，这种表示方式如何表示<code>0</code>？因为尾数永远是<code>1.*</code>，所以常规表示方式永远也不可能表示出<code>0</code>这个数，最多尽量接近<code>0</code>。这时候上文提到的两个特殊值中的一个便派上了用场。当指数位和尾数位全部为<code>0</code>时表示该数为<code>0</code>，即<code>0</code>的二进制表达式为（float）<code>0_00000000_00000000000000000000000</code>（符号位可以为<code>1</code>）。</p>\n<h1 id=\"非规约数\"><a href=\"#非规约数\" class=\"headerlink\" title=\"非规约数\"></a>非规约数</h1><p>&emsp;&emsp;如果浮点数的指数部分的编码值是<code>0</code>，分数部分非零，那么这个浮点数将被称为<strong>非规约形式的浮点数</strong>。一般是某个数字<strong>相当</strong>接近零时才会使用非规约型式来表示。 <code>IEEE 754</code>标准规定：<strong>非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1</strong>。例如，最小的规约形式的单精度浮点数的指数部分编码值为<code>1</code>，指数的实际值为<code>-126</code>；而非规约的单精度浮点数的指数域编码值为<code>0</code>，对应的指数实际值也是<code>-126</code>而不是<code>-127</code>。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近<code>0</code>。规约浮点数的尾数大于等于<code>1</code>且小于<code>2</code>，而非规约浮点数的尾数小于<code>1</code>且大于<code>0</code>。</p>\n<h1 id=\"无穷大的表示方法\"><a href=\"#无穷大的表示方法\" class=\"headerlink\" title=\"无穷大的表示方法\"></a>无穷大的表示方法</h1><p>&emsp;&emsp;现在还有一个特殊值没有用到，即指数为<code>2047</code>的情况。规范规定，当指数位全部为<code>1</code>并且尾数位全部为<code>0</code>时表示该数是一个无穷数，根据符号位的不同分为正无穷和负无穷。</p>\n<h1 id=\"NaN\"><a href=\"#NaN\" class=\"headerlink\" title=\"NaN\"></a>NaN</h1><p>&emsp;&emsp;<code>NaN</code>的全拼是“Not a Number”，顾名思义，其表示这不是一个有效的数字。指数位全为<code>1</code>但尾数位不全为<code>0</code>的数字均为<code>NaN</code>，可以看出<code>NaN</code>有许多表达式。在一个<code>NaN</code>与其它数字（包括<code>NaN</code>）判断是否相等时一定返回<code>false</code>，同时因为<code>NaN</code>内部是有值的，只是其不能正确的表示数字，所以其并不是一个空值，也不能使用空值来判断其是否为<code>NaN</code>。</p>\n<p>&emsp;&emsp;为此，在<code>math.h</code>中定义了一个函数<code>isnan(x)</code>，该函数用于判断数字是否为NaN。还有一个于其对应的函数<code>isnormal(x)</code>，该函数用于判断数字是否为一个正常的数字，当数字为<code>0</code>、无穷数、NaN时会返回<code>false</code>，否则返回<code>true</code>。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<p><a href=\"http://www.softelectro.ru/ieee754_en.html\">IEEE 754 - Standard binary floating point arithmetic</a></p>\n<p><a href=\"https://blog.csdn.net/S_o_l_o_n/article/details/106438708\">CSDN - 理解浮点数的二进制表示</a></p>\n<p><a href=\"[IEEE 754_百度百科 (baidu.com\">百度百科</a>](<a href=\"https://baike.baidu.com/item/IEEE\">https://baike.baidu.com/item/IEEE</a> 754/3869922?fr=aladdin))</p>\n</blockquote>\n"},{"title":"什么是递归","date":"2021-10-29T14:33:33.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b15.jfif","description":"简要说明递归的用法和递归的思想。","_content":"\n\n\n# 函数的调用\n\n&emsp;&emsp;现在我们假定一个场景：老师在给学生讲课，不妨设老师是主函数，学生为其它函数。现在老师要点名提问一个问题，可能会说：“探姬，5的阶乘等于几？”，那么这个老师就是调用了一个名字为“探姬”的函数，并输入了对应的参数，而探姬的回答则是函数的返回值。\n\n# 递归\n\n## 思想\n\n&emsp;&emsp;递归是一种编程技巧，也是一种编程思想。递归其实就是函数的自调用，现在，探姬需要解决5的阶乘问题。探姬决定先计算4的阶乘，然后乘以5就是5的阶乘了。于是探姬开始询问自己的真心，4的阶乘是多少？同样，她选择先计算3的阶乘，一直往复，直到需要计算1（或2）的阶乘时不在继续往下，因为1（或2）的阶乘是它本身。这个自己询问自己（函数调用自身）的编码方式便称为递归。\n\n&emsp;&emsp;这个求阶乘的方法写成代码就是：\n\n```C\nint factorial(int n) {\n    if (n == 1 || n == 2) return n;\n    return factorial(n - 1) * n;\n}\n```\n\n## 独立性\n\n&emsp;&emsp;需要注意的是，函数调用自身之后，所有的变量（除了`static`变量）都不会与调用函数中的相影响，比如下面的代码：\n\n```C\nvoid task(int k);\n\nint main() {\n    task(10);\n    return 0;\n}\n\nvoid task(int k) {\n    int n = k * 2;\n    task(n);\n    printf(\"%d\\n\", n);\n}\n\n//结果：\n// 40\n// 20\n// \n```\n\n&emsp;&emsp;我们尚且不讨论无限递归的问题，在这个代码中`task(int)`调用了自身，但是被调用的`task(int)`中的`int n = k * 2`这个语句并不会影响上层`task(int)`中的变量`n`的值，同时两者的`k`值也是相互独立的。\n\n## 递归的优劣\n\n### 优势\n\n<ul>\n    <li>代码简洁易懂</li>\n    <li>逻辑简单，容易书写</li>\n</ul>\n\n### 劣势\n\n<ul>\n    <li>时间和空间的消耗比循环大</li>\n    <li>可能存在部分重复运算</li>\n    <li>有调用栈溢出的风险</li>\n</ul>\n\n\n## 无限递归\n\n&emsp;&emsp;上文我们提到了“无限递归”一词，这个词用于指明一个递归函数因某些原因导致递归没有尽头（另类的死循环），会永远执行下去。但是实际上并不会永远执行，为了解释这个问题，我们需要知道“函数的调用链”和“栈”的部分概念。\n\n### 函数调用链\n\n&emsp;&emsp;顾名思义，函数调用链就是函数调用过程中构建出来的一个链表（实际上可能不是，C/C++的内存我没有专门看过，如果有问题还望指正）。程序开始执行的时候，表头为`main()`，当`main`调用另一个函数的时候（比如说`task(int)`），就会在链表头添加一个元素`task(int)`（注意是添加而不是替换掉原本的表头）。如果`task`也调用了其它函数，则继续该操作。如果`task`执行完毕，则将`task`从表头移除，并返回到调用处继续执行剩下的代码。\n\n### 调用栈\n\n&emsp;&emsp;调用栈是用来存储调用链的栈，容量是有限的。\n\n### 调用栈溢出\n\n&emsp;&emsp;我们现在回过头来看上面的代码，假设栈最大存储的调用链长度为`5`，那么就是下面的情况：\n\n![调用演示](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/recursion/dy.png)\n\n&emsp;&emsp;很显然，在运行4次`task`后栈便没有更多的空间来存储下一个需要存入的`task`，这时候就会导致程序崩溃，我们称为“调用栈溢出”。可以看出，就算`task`不是无限运行，只要递归次数够多，也有可能导致溢出，所以在设计递归算法时必须要控制递归的深度，以防溢出。同样，就算不是递归，调用函数的时候也可能会导致溢出，不过索性的是栈可存储的调用链实际上很长，不涉及递归很难遇到因为调用链过长导致的溢出问题。\n\n\n\n\n\n\n\n","source":"_posts/recursion.md","raw":"---\ntitle: 什么是递归\ndate: 2021-10-29 22:33:33\ncategories:\n  - 通用\ntags:\n  - 递归\n  - 教程\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b15.jfif\ndescription: 简要说明递归的用法和递归的思想。\n---\n\n\n\n# 函数的调用\n\n&emsp;&emsp;现在我们假定一个场景：老师在给学生讲课，不妨设老师是主函数，学生为其它函数。现在老师要点名提问一个问题，可能会说：“探姬，5的阶乘等于几？”，那么这个老师就是调用了一个名字为“探姬”的函数，并输入了对应的参数，而探姬的回答则是函数的返回值。\n\n# 递归\n\n## 思想\n\n&emsp;&emsp;递归是一种编程技巧，也是一种编程思想。递归其实就是函数的自调用，现在，探姬需要解决5的阶乘问题。探姬决定先计算4的阶乘，然后乘以5就是5的阶乘了。于是探姬开始询问自己的真心，4的阶乘是多少？同样，她选择先计算3的阶乘，一直往复，直到需要计算1（或2）的阶乘时不在继续往下，因为1（或2）的阶乘是它本身。这个自己询问自己（函数调用自身）的编码方式便称为递归。\n\n&emsp;&emsp;这个求阶乘的方法写成代码就是：\n\n```C\nint factorial(int n) {\n    if (n == 1 || n == 2) return n;\n    return factorial(n - 1) * n;\n}\n```\n\n## 独立性\n\n&emsp;&emsp;需要注意的是，函数调用自身之后，所有的变量（除了`static`变量）都不会与调用函数中的相影响，比如下面的代码：\n\n```C\nvoid task(int k);\n\nint main() {\n    task(10);\n    return 0;\n}\n\nvoid task(int k) {\n    int n = k * 2;\n    task(n);\n    printf(\"%d\\n\", n);\n}\n\n//结果：\n// 40\n// 20\n// \n```\n\n&emsp;&emsp;我们尚且不讨论无限递归的问题，在这个代码中`task(int)`调用了自身，但是被调用的`task(int)`中的`int n = k * 2`这个语句并不会影响上层`task(int)`中的变量`n`的值，同时两者的`k`值也是相互独立的。\n\n## 递归的优劣\n\n### 优势\n\n<ul>\n    <li>代码简洁易懂</li>\n    <li>逻辑简单，容易书写</li>\n</ul>\n\n### 劣势\n\n<ul>\n    <li>时间和空间的消耗比循环大</li>\n    <li>可能存在部分重复运算</li>\n    <li>有调用栈溢出的风险</li>\n</ul>\n\n\n## 无限递归\n\n&emsp;&emsp;上文我们提到了“无限递归”一词，这个词用于指明一个递归函数因某些原因导致递归没有尽头（另类的死循环），会永远执行下去。但是实际上并不会永远执行，为了解释这个问题，我们需要知道“函数的调用链”和“栈”的部分概念。\n\n### 函数调用链\n\n&emsp;&emsp;顾名思义，函数调用链就是函数调用过程中构建出来的一个链表（实际上可能不是，C/C++的内存我没有专门看过，如果有问题还望指正）。程序开始执行的时候，表头为`main()`，当`main`调用另一个函数的时候（比如说`task(int)`），就会在链表头添加一个元素`task(int)`（注意是添加而不是替换掉原本的表头）。如果`task`也调用了其它函数，则继续该操作。如果`task`执行完毕，则将`task`从表头移除，并返回到调用处继续执行剩下的代码。\n\n### 调用栈\n\n&emsp;&emsp;调用栈是用来存储调用链的栈，容量是有限的。\n\n### 调用栈溢出\n\n&emsp;&emsp;我们现在回过头来看上面的代码，假设栈最大存储的调用链长度为`5`，那么就是下面的情况：\n\n![调用演示](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/recursion/dy.png)\n\n&emsp;&emsp;很显然，在运行4次`task`后栈便没有更多的空间来存储下一个需要存入的`task`，这时候就会导致程序崩溃，我们称为“调用栈溢出”。可以看出，就算`task`不是无限运行，只要递归次数够多，也有可能导致溢出，所以在设计递归算法时必须要控制递归的深度，以防溢出。同样，就算不是递归，调用函数的时候也可能会导致溢出，不过索性的是栈可存储的调用链实际上很长，不涉及递归很难遇到因为调用链过长导致的溢出问题。\n\n\n\n\n\n\n\n","slug":"recursion","published":1,"updated":"2021-10-30T13:35:13.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvdzwpgu000dh8wqge8xfn23","content":"<h1 id=\"函数的调用\"><a href=\"#函数的调用\" class=\"headerlink\" title=\"函数的调用\"></a>函数的调用</h1><p>&emsp;&emsp;现在我们假定一个场景：老师在给学生讲课，不妨设老师是主函数，学生为其它函数。现在老师要点名提问一个问题，可能会说：“探姬，5的阶乘等于几？”，那么这个老师就是调用了一个名字为“探姬”的函数，并输入了对应的参数，而探姬的回答则是函数的返回值。</p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>&emsp;&emsp;递归是一种编程技巧，也是一种编程思想。递归其实就是函数的自调用，现在，探姬需要解决5的阶乘问题。探姬决定先计算4的阶乘，然后乘以5就是5的阶乘了。于是探姬开始询问自己的真心，4的阶乘是多少？同样，她选择先计算3的阶乘，一直往复，直到需要计算1（或2）的阶乘时不在继续往下，因为1（或2）的阶乘是它本身。这个自己询问自己（函数调用自身）的编码方式便称为递归。</p>\n<p>&emsp;&emsp;这个求阶乘的方法写成代码就是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">factorial</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-number\">1</span> || n == <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">return</span> n;<br>    <span class=\"hljs-keyword\">return</span> factorial(n - <span class=\"hljs-number\">1</span>) * n;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"独立性\"><a href=\"#独立性\" class=\"headerlink\" title=\"独立性\"></a>独立性</h2><p>&emsp;&emsp;需要注意的是，函数调用自身之后，所有的变量（除了<code>static</code>变量）都不会与调用函数中的相影响，比如下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">task</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> k)</span></span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    task(<span class=\"hljs-number\">10</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">task</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n = k * <span class=\"hljs-number\">2</span>;<br>    task(n);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, n);<br>&#125;<br><br><span class=\"hljs-comment\">//结果：</span><br><span class=\"hljs-comment\">// 40</span><br><span class=\"hljs-comment\">// 20</span><br><span class=\"hljs-comment\">// </span><br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们尚且不讨论无限递归的问题，在这个代码中<code>task(int)</code>调用了自身，但是被调用的<code>task(int)</code>中的<code>int n = k * 2</code>这个语句并不会影响上层<code>task(int)</code>中的变量<code>n</code>的值，同时两者的<code>k</code>值也是相互独立的。</p>\n<h2 id=\"递归的优劣\"><a href=\"#递归的优劣\" class=\"headerlink\" title=\"递归的优劣\"></a>递归的优劣</h2><h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ul>\n    <li>代码简洁易懂</li>\n    <li>逻辑简单，容易书写</li>\n</ul>\n\n<h3 id=\"劣势\"><a href=\"#劣势\" class=\"headerlink\" title=\"劣势\"></a>劣势</h3><ul>\n    <li>时间和空间的消耗比循环大</li>\n    <li>可能存在部分重复运算</li>\n    <li>有调用栈溢出的风险</li>\n</ul>\n\n\n<h2 id=\"无限递归\"><a href=\"#无限递归\" class=\"headerlink\" title=\"无限递归\"></a>无限递归</h2><p>&emsp;&emsp;上文我们提到了“无限递归”一词，这个词用于指明一个递归函数因某些原因导致递归没有尽头（另类的死循环），会永远执行下去。但是实际上并不会永远执行，为了解释这个问题，我们需要知道“函数的调用链”和“栈”的部分概念。</p>\n<h3 id=\"函数调用链\"><a href=\"#函数调用链\" class=\"headerlink\" title=\"函数调用链\"></a>函数调用链</h3><p>&emsp;&emsp;顾名思义，函数调用链就是函数调用过程中构建出来的一个链表（实际上可能不是，C/C++的内存我没有专门看过，如果有问题还望指正）。程序开始执行的时候，表头为<code>main()</code>，当<code>main</code>调用另一个函数的时候（比如说<code>task(int)</code>），就会在链表头添加一个元素<code>task(int)</code>（注意是添加而不是替换掉原本的表头）。如果<code>task</code>也调用了其它函数，则继续该操作。如果<code>task</code>执行完毕，则将<code>task</code>从表头移除，并返回到调用处继续执行剩下的代码。</p>\n<h3 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a>调用栈</h3><p>&emsp;&emsp;调用栈是用来存储调用链的栈，容量是有限的。</p>\n<h3 id=\"调用栈溢出\"><a href=\"#调用栈溢出\" class=\"headerlink\" title=\"调用栈溢出\"></a>调用栈溢出</h3><p>&emsp;&emsp;我们现在回过头来看上面的代码，假设栈最大存储的调用链长度为<code>5</code>，那么就是下面的情况：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/recursion/dy.png\" alt=\"调用演示\"></p>\n<p>&emsp;&emsp;很显然，在运行4次<code>task</code>后栈便没有更多的空间来存储下一个需要存入的<code>task</code>，这时候就会导致程序崩溃，我们称为“调用栈溢出”。可以看出，就算<code>task</code>不是无限运行，只要递归次数够多，也有可能导致溢出，所以在设计递归算法时必须要控制递归的深度，以防溢出。同样，就算不是递归，调用函数的时候也可能会导致溢出，不过索性的是栈可存储的调用链实际上很长，不涉及递归很难遇到因为调用链过长导致的溢出问题。</p>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"},{"name":"Akilar店长","link":"https://akilar.top","avatar":"https://akilar.top/img/siteicon/favicon.png","descr":"欢迎光临糖果屋","siteshot":"https://cdn.jsdelivr.net/gh/Akilarlxh/ScreenShot@gh-pages/akilar.top.jpg"}]}]}},"excerpt":"","more":"<h1 id=\"函数的调用\"><a href=\"#函数的调用\" class=\"headerlink\" title=\"函数的调用\"></a>函数的调用</h1><p>&emsp;&emsp;现在我们假定一个场景：老师在给学生讲课，不妨设老师是主函数，学生为其它函数。现在老师要点名提问一个问题，可能会说：“探姬，5的阶乘等于几？”，那么这个老师就是调用了一个名字为“探姬”的函数，并输入了对应的参数，而探姬的回答则是函数的返回值。</p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><h2 id=\"思想\"><a href=\"#思想\" class=\"headerlink\" title=\"思想\"></a>思想</h2><p>&emsp;&emsp;递归是一种编程技巧，也是一种编程思想。递归其实就是函数的自调用，现在，探姬需要解决5的阶乘问题。探姬决定先计算4的阶乘，然后乘以5就是5的阶乘了。于是探姬开始询问自己的真心，4的阶乘是多少？同样，她选择先计算3的阶乘，一直往复，直到需要计算1（或2）的阶乘时不在继续往下，因为1（或2）的阶乘是它本身。这个自己询问自己（函数调用自身）的编码方式便称为递归。</p>\n<p>&emsp;&emsp;这个求阶乘的方法写成代码就是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">factorial</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> n)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-number\">1</span> || n == <span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">return</span> n;<br>    <span class=\"hljs-keyword\">return</span> factorial(n - <span class=\"hljs-number\">1</span>) * n;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"独立性\"><a href=\"#独立性\" class=\"headerlink\" title=\"独立性\"></a>独立性</h2><p>&emsp;&emsp;需要注意的是，函数调用自身之后，所有的变量（除了<code>static</code>变量）都不会与调用函数中的相影响，比如下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">task</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> k)</span></span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>&#123;<br>    task(<span class=\"hljs-number\">10</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">task</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> k)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">int</span> n = k * <span class=\"hljs-number\">2</span>;<br>    task(n);<br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\n&quot;</span>, n);<br>&#125;<br><br><span class=\"hljs-comment\">//结果：</span><br><span class=\"hljs-comment\">// 40</span><br><span class=\"hljs-comment\">// 20</span><br><span class=\"hljs-comment\">// </span><br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们尚且不讨论无限递归的问题，在这个代码中<code>task(int)</code>调用了自身，但是被调用的<code>task(int)</code>中的<code>int n = k * 2</code>这个语句并不会影响上层<code>task(int)</code>中的变量<code>n</code>的值，同时两者的<code>k</code>值也是相互独立的。</p>\n<h2 id=\"递归的优劣\"><a href=\"#递归的优劣\" class=\"headerlink\" title=\"递归的优劣\"></a>递归的优劣</h2><h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><ul>\n    <li>代码简洁易懂</li>\n    <li>逻辑简单，容易书写</li>\n</ul>\n\n<h3 id=\"劣势\"><a href=\"#劣势\" class=\"headerlink\" title=\"劣势\"></a>劣势</h3><ul>\n    <li>时间和空间的消耗比循环大</li>\n    <li>可能存在部分重复运算</li>\n    <li>有调用栈溢出的风险</li>\n</ul>\n\n\n<h2 id=\"无限递归\"><a href=\"#无限递归\" class=\"headerlink\" title=\"无限递归\"></a>无限递归</h2><p>&emsp;&emsp;上文我们提到了“无限递归”一词，这个词用于指明一个递归函数因某些原因导致递归没有尽头（另类的死循环），会永远执行下去。但是实际上并不会永远执行，为了解释这个问题，我们需要知道“函数的调用链”和“栈”的部分概念。</p>\n<h3 id=\"函数调用链\"><a href=\"#函数调用链\" class=\"headerlink\" title=\"函数调用链\"></a>函数调用链</h3><p>&emsp;&emsp;顾名思义，函数调用链就是函数调用过程中构建出来的一个链表（实际上可能不是，C/C++的内存我没有专门看过，如果有问题还望指正）。程序开始执行的时候，表头为<code>main()</code>，当<code>main</code>调用另一个函数的时候（比如说<code>task(int)</code>），就会在链表头添加一个元素<code>task(int)</code>（注意是添加而不是替换掉原本的表头）。如果<code>task</code>也调用了其它函数，则继续该操作。如果<code>task</code>执行完毕，则将<code>task</code>从表头移除，并返回到调用处继续执行剩下的代码。</p>\n<h3 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a>调用栈</h3><p>&emsp;&emsp;调用栈是用来存储调用链的栈，容量是有限的。</p>\n<h3 id=\"调用栈溢出\"><a href=\"#调用栈溢出\" class=\"headerlink\" title=\"调用栈溢出\"></a>调用栈溢出</h3><p>&emsp;&emsp;我们现在回过头来看上面的代码，假设栈最大存储的调用链长度为<code>5</code>，那么就是下面的情况：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/recursion/dy.png\" alt=\"调用演示\"></p>\n<p>&emsp;&emsp;很显然，在运行4次<code>task</code>后栈便没有更多的空间来存储下一个需要存入的<code>task</code>，这时候就会导致程序崩溃，我们称为“调用栈溢出”。可以看出，就算<code>task</code>不是无限运行，只要递归次数够多，也有可能导致溢出，所以在设计递归算法时必须要控制递归的深度，以防溢出。同样，就算不是递归，调用函数的时候也可能会导致溢出，不过索性的是栈可存储的调用链实际上很长，不涉及递归很难遇到因为调用链过长导致的溢出问题。</p>\n"},{"title":"指针&数组","date":"2021-11-01T02:27:06.000Z","cover":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b16.jpeg","description":"什么是指针？指针和数组的关系是什么？","_content":"\n\n{% tip warning faa-horizontal animated %}<div class=\"text\" style=\" text-align:center;\">本篇博客内容有待论证，如果不是前来查误的请勿阅读！</div>{% endtip %}\n\n{% tip info %}<p><div class=\"text\" style=\" text-align:center;\">本篇博客所指的所有内存均不区分高级缓存、内存、虚拟内存</div>\n\n<p><div class=\"text\" style=\" text-align:center;\"><font size=\"2px\">本篇博客也不会单独讲解数组，阅读之前请确保自己已经掌握了数组的基本内容</font></div>{% endtip %}\n\n# 内存\n\n{% tip info %}<div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#ffffff\">这里只是对内存简单并片面的进行了简单的介绍，更多内容还请自行搜索</font></div>{% endtip %}\n\n&emsp;&emsp;说到指针，肯定无法避免的和内存扯上关系。从硬件层面来说，内存是用来临时（断电丢失数据）存储程序运行时数据的高速存储设备。从软件层面来说，内存相当于一个容量巨大的一维数组，下标从`0`开始，依次向后排列，这个下标也就是我们经常说的“内存地址”。\n\n&emsp;&emsp;需要注意的是，实际开发中（仅限于win10平台，win从什么版本开始这个设计和其它平台的我不清楚）所有程序的内存地址都是从`0`开始的，这是因为操作系统为了安全性考虑没有将真实的内存地址暴露给程序，程序访问到的是其实是一个虚拟的内存地址，程序的内存地址表示的是该内存在操作系统给程序分配的内存空间中的位置。\n\n# 指针\n\n## 本质\n\n&emsp;&emsp;指针的声明方法如下（格式：[类型] *[变量名]）：\n\n```c\nint *i;\ndouble *d;\nvoid *v;\n```\n\n&emsp;&emsp;读者可能会好奇，为什么可以声明一个类型为`void`的变量？这就涉及到指针的本质了。指针（不论什么类型的指针）实际上是一个整形数据，其中存储的是它指向的量的内存地址。`void *v`表示指向一个数据类型未知的量的内存地址。\n\n## 空指针\n\n&emsp;&emsp;C/C++中提供了一个值：`NULL`，该值用于表示当前指针为空值，即没有指向任意有效的内存。一般情况下，当当前指针不可用时，推荐手动将其赋值为`NULL`，以防后面不小心再次使用。\n\n## 指针是数据类型吗\n\n&emsp;&emsp;很多人可能会疑惑下面两种写法哪一种正确：\n\n```C\nint *arg0;\nint* arg0;\n```\n\n&emsp;&emsp;这两种声明方式放在程序中都可以正常编译并运行，但是假如我们要声明三个指针，下面两种方法哪种正确呢？\n\n```C\nint *a0, *a1, *a2;\nint* b0, b1, b2;\n```\n\n&emsp;&emsp;现在情况发生了变化，其中一种写法会导致编译错误（指使用时报错，而非声明时报错）或运行错误（如果编译通过了的话），读者可以先自行尝试一下。\n\n&emsp;&emsp;这两种方法中第二种方法实际上声明了一个指针变量`b0`和两个`int`变量`b1`、`b2`。写出这样的代码明显是将指针当作了一种数据类型来处理，但是实际上指针并不是一种数据类型，`*`只是告诉编译器，这个变量存储的是一个地址，而不是告诉编译器这是一个指针类型。\n\n&emsp;&emsp;由此可见，我们应该使用`*`与变量名贴在一起的写法，同时还可以得知**指针不是数据类型**。\n\n## 指针加法\n\n&emsp;&emsp;指针的加法和数字的加法不同，我们知道，不同类型的数据的长度是不一样的，以`64位`电脑为例，`int`为`32位/4字节`，`char`为`8位/1字节`。指针的加法会根据类型的不同而变化，比如对于`int *a0`，`a0 + 1`返回的实际上是`a0`所指向的地址再加`4`的结果。简单说就是指针`+1`的结果是当前地址+数据类型长度的结果。\n\n&emsp;&emsp;由此我们可以得到如下公式：`point + k -> point + (k * sizeof(type))`，其中`point`是指针对象，`k`是要加的数字，`type`是数据类型。需要注意的是，这个转换编译器已经帮我们完成，我们使用的时候只需要用左边的写法就可以了。\n\n# 指针和数组\n\n## 一维（一级）\n\n### 数组\n\n&emsp;&emsp;我们写出如下代码：\n\n```C\nint array[10];\nint *arrayPoint = array;\n```\n\n&emsp;&emsp;可以知道，我们通过`arrayPoint`来访问数组是完全没有问题的，因为标准规定，数组名存储的是数组中第一个元素的内存地址。所以我们可以把数组看作一种**另类的指针**（注意是另类的指针而并不是指针）。调用函数并传递数组进去也不会把数组复制一遍，而是传递数组中第一个元素的地址。\n\n### 指针\n\n&emsp;&emsp;那么我们如何用指针来表示数组呢？如下面的代码：\n\n```C\nint *array = malloc(10 * sizeof(int));\n```\n\n&emsp;&emsp;`malloc`在堆分配了一个长度为`10 * sizeof(int)`的内存空间，并且返回这段内存的启示位置的地址。由此可知，我们将数组的地址存储到了`array`中，实际的内容分配到了堆中。结构如下：\n\n![指针](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/point/op.png)\n\n\n\n## 二维（二级）\n\n&emsp;&emsp;有了上面的结论，我们可以写下这样子的代码：\n\n```\nint array[10][10];\nint **arrayPoint = array;\n```\n\n&emsp;&emsp;经过测试可以发现，这段代码无法通过编译，为什么呢？因为数组名只是一种另类的指针，而非指针，它和指针其实完全不是一种东西。\n\n### 指针\n\n&emsp;&emsp;声明指针形式的二维数组的方法如下：\n\n```C\nint **arrayPoint = malloc(3 * sizeof(int*));\nfor (int i = 0; i < 3; ++i) {\n    arrayPoint[i] = malloc(3 * sizeof(int));\n}\n```\n\n&emsp;&emsp;其内存结构如下：\n\n![内存结构](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/point/tp.png)\n\n&emsp;&emsp;这里解释一下为什么会这样。首先，我们在栈中存储了数组的地址。然后为数组分配了一个内存空间，这里要注意，我们分配空间的时候先使用`malloc`分配了一个长度为`3 * sizeof(int*)`的空间，随后再遍历这个一维数组，继续分配二维空间。可以理解为我们创建了四个数组，其中一个用于存储剩余数组的起始内存地址。\n\n### 数组\n\n```C\nint arr1[9];\nint arr2[3][3];\n```\n\n&emsp;&emsp;我们来看一下数组的内存结构（数组声明在函数中且不是`static`就存在栈中，否则在堆中）：\n\n![二维数组内存结构](https://www.linuxidc.com/upload/2015_03/15031621526830.png)\n\n{% span center blue, 该图来自网络，侵删 %}\n\n### 小结\n\n&emsp;&emsp;对比内存结构我们发现，一维数组可以通过指针进行操作完全是因为两者的内存结构“凑巧”一样而已，而到了二维（或更高）层次后，两者内存结构的区别便凸显了出来，所以显然是不能够共用的。\n\n&emsp;&emsp;那么如果我非要用指针的形式表示二维数组应该怎么声明呢？\n\n```C\nint array[10][10];\n\nint *p1[10] = array;\t\t//1\nint (*p2)[10] = array;\t\t//2\n```\n\n---\n\n&emsp;&emsp;我们先来分析一下这两种写法的区别：\n\n#### *[] - 指针数组\n\n&emsp;&emsp;指针数组实际上是一个数组，其中存储了一些指针的值，内存结构如下：\n\n![指针数组](https://dwz.date/fhdr)\n\n{% span center blue, 该图来自网络，侵删 %}\n\n#### (*)[] - 数组指针\n\n&emsp;&emsp;数组指针实际上是一个指针，指针指向数组所在的内存地址，内存结构如下：\n\n![指针数组](https://dwz.date/fhdq)\n\n{% span center blue, 该图来自网络，侵删 %}\n\n---\n\n&emsp;&emsp;现在，已知上面两种写法其中一种是正确的，读者可以尝试根据这两种内存结构推理一下哪一种是可以通过编译的。\n\n&emsp;&emsp;答案是第二种，为什么呢？我们将二维数组带入进去可以发现，第二种写法只是存储了数组中第一个元素的地址，这和二维数组的内存结构是一致的，所以可以正确运行。而第一种写法其实其内存结构和二级指针构成的数组大差不差。\n\n# 参考资料\n\n>[C语言中的二级指针和二维数组问题](https://www.linuxidc.com/Linux/2015-03/115055.htm)\n>\n>[C语言中指针和数组](https://www.cnblogs.com/downey-blog/p/10469906.html)\n>\n>[数组指针和指针数组的区别](https://dwz.date/fhdp)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/point.md","raw":"---\ntitle: 指针&数组\ndate: 2021-11-01 10:27:06\ncategories:\n  - C/C++\ntags:\n  - 教程\n  - 数组\n  - 指针\ncover: https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bg/b16.jpeg\ndescription: 什么是指针？指针和数组的关系是什么？\n---\n\n\n{% tip warning faa-horizontal animated %}<div class=\"text\" style=\" text-align:center;\">本篇博客内容有待论证，如果不是前来查误的请勿阅读！</div>{% endtip %}\n\n{% tip info %}<p><div class=\"text\" style=\" text-align:center;\">本篇博客所指的所有内存均不区分高级缓存、内存、虚拟内存</div>\n\n<p><div class=\"text\" style=\" text-align:center;\"><font size=\"2px\">本篇博客也不会单独讲解数组，阅读之前请确保自己已经掌握了数组的基本内容</font></div>{% endtip %}\n\n# 内存\n\n{% tip info %}<div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#ffffff\">这里只是对内存简单并片面的进行了简单的介绍，更多内容还请自行搜索</font></div>{% endtip %}\n\n&emsp;&emsp;说到指针，肯定无法避免的和内存扯上关系。从硬件层面来说，内存是用来临时（断电丢失数据）存储程序运行时数据的高速存储设备。从软件层面来说，内存相当于一个容量巨大的一维数组，下标从`0`开始，依次向后排列，这个下标也就是我们经常说的“内存地址”。\n\n&emsp;&emsp;需要注意的是，实际开发中（仅限于win10平台，win从什么版本开始这个设计和其它平台的我不清楚）所有程序的内存地址都是从`0`开始的，这是因为操作系统为了安全性考虑没有将真实的内存地址暴露给程序，程序访问到的是其实是一个虚拟的内存地址，程序的内存地址表示的是该内存在操作系统给程序分配的内存空间中的位置。\n\n# 指针\n\n## 本质\n\n&emsp;&emsp;指针的声明方法如下（格式：[类型] *[变量名]）：\n\n```c\nint *i;\ndouble *d;\nvoid *v;\n```\n\n&emsp;&emsp;读者可能会好奇，为什么可以声明一个类型为`void`的变量？这就涉及到指针的本质了。指针（不论什么类型的指针）实际上是一个整形数据，其中存储的是它指向的量的内存地址。`void *v`表示指向一个数据类型未知的量的内存地址。\n\n## 空指针\n\n&emsp;&emsp;C/C++中提供了一个值：`NULL`，该值用于表示当前指针为空值，即没有指向任意有效的内存。一般情况下，当当前指针不可用时，推荐手动将其赋值为`NULL`，以防后面不小心再次使用。\n\n## 指针是数据类型吗\n\n&emsp;&emsp;很多人可能会疑惑下面两种写法哪一种正确：\n\n```C\nint *arg0;\nint* arg0;\n```\n\n&emsp;&emsp;这两种声明方式放在程序中都可以正常编译并运行，但是假如我们要声明三个指针，下面两种方法哪种正确呢？\n\n```C\nint *a0, *a1, *a2;\nint* b0, b1, b2;\n```\n\n&emsp;&emsp;现在情况发生了变化，其中一种写法会导致编译错误（指使用时报错，而非声明时报错）或运行错误（如果编译通过了的话），读者可以先自行尝试一下。\n\n&emsp;&emsp;这两种方法中第二种方法实际上声明了一个指针变量`b0`和两个`int`变量`b1`、`b2`。写出这样的代码明显是将指针当作了一种数据类型来处理，但是实际上指针并不是一种数据类型，`*`只是告诉编译器，这个变量存储的是一个地址，而不是告诉编译器这是一个指针类型。\n\n&emsp;&emsp;由此可见，我们应该使用`*`与变量名贴在一起的写法，同时还可以得知**指针不是数据类型**。\n\n## 指针加法\n\n&emsp;&emsp;指针的加法和数字的加法不同，我们知道，不同类型的数据的长度是不一样的，以`64位`电脑为例，`int`为`32位/4字节`，`char`为`8位/1字节`。指针的加法会根据类型的不同而变化，比如对于`int *a0`，`a0 + 1`返回的实际上是`a0`所指向的地址再加`4`的结果。简单说就是指针`+1`的结果是当前地址+数据类型长度的结果。\n\n&emsp;&emsp;由此我们可以得到如下公式：`point + k -> point + (k * sizeof(type))`，其中`point`是指针对象，`k`是要加的数字，`type`是数据类型。需要注意的是，这个转换编译器已经帮我们完成，我们使用的时候只需要用左边的写法就可以了。\n\n# 指针和数组\n\n## 一维（一级）\n\n### 数组\n\n&emsp;&emsp;我们写出如下代码：\n\n```C\nint array[10];\nint *arrayPoint = array;\n```\n\n&emsp;&emsp;可以知道，我们通过`arrayPoint`来访问数组是完全没有问题的，因为标准规定，数组名存储的是数组中第一个元素的内存地址。所以我们可以把数组看作一种**另类的指针**（注意是另类的指针而并不是指针）。调用函数并传递数组进去也不会把数组复制一遍，而是传递数组中第一个元素的地址。\n\n### 指针\n\n&emsp;&emsp;那么我们如何用指针来表示数组呢？如下面的代码：\n\n```C\nint *array = malloc(10 * sizeof(int));\n```\n\n&emsp;&emsp;`malloc`在堆分配了一个长度为`10 * sizeof(int)`的内存空间，并且返回这段内存的启示位置的地址。由此可知，我们将数组的地址存储到了`array`中，实际的内容分配到了堆中。结构如下：\n\n![指针](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/point/op.png)\n\n\n\n## 二维（二级）\n\n&emsp;&emsp;有了上面的结论，我们可以写下这样子的代码：\n\n```\nint array[10][10];\nint **arrayPoint = array;\n```\n\n&emsp;&emsp;经过测试可以发现，这段代码无法通过编译，为什么呢？因为数组名只是一种另类的指针，而非指针，它和指针其实完全不是一种东西。\n\n### 指针\n\n&emsp;&emsp;声明指针形式的二维数组的方法如下：\n\n```C\nint **arrayPoint = malloc(3 * sizeof(int*));\nfor (int i = 0; i < 3; ++i) {\n    arrayPoint[i] = malloc(3 * sizeof(int));\n}\n```\n\n&emsp;&emsp;其内存结构如下：\n\n![内存结构](https://cdn.jsdelivr.net/gh/EmptyDreams/resources/point/tp.png)\n\n&emsp;&emsp;这里解释一下为什么会这样。首先，我们在栈中存储了数组的地址。然后为数组分配了一个内存空间，这里要注意，我们分配空间的时候先使用`malloc`分配了一个长度为`3 * sizeof(int*)`的空间，随后再遍历这个一维数组，继续分配二维空间。可以理解为我们创建了四个数组，其中一个用于存储剩余数组的起始内存地址。\n\n### 数组\n\n```C\nint arr1[9];\nint arr2[3][3];\n```\n\n&emsp;&emsp;我们来看一下数组的内存结构（数组声明在函数中且不是`static`就存在栈中，否则在堆中）：\n\n![二维数组内存结构](https://www.linuxidc.com/upload/2015_03/15031621526830.png)\n\n{% span center blue, 该图来自网络，侵删 %}\n\n### 小结\n\n&emsp;&emsp;对比内存结构我们发现，一维数组可以通过指针进行操作完全是因为两者的内存结构“凑巧”一样而已，而到了二维（或更高）层次后，两者内存结构的区别便凸显了出来，所以显然是不能够共用的。\n\n&emsp;&emsp;那么如果我非要用指针的形式表示二维数组应该怎么声明呢？\n\n```C\nint array[10][10];\n\nint *p1[10] = array;\t\t//1\nint (*p2)[10] = array;\t\t//2\n```\n\n---\n\n&emsp;&emsp;我们先来分析一下这两种写法的区别：\n\n#### *[] - 指针数组\n\n&emsp;&emsp;指针数组实际上是一个数组，其中存储了一些指针的值，内存结构如下：\n\n![指针数组](https://dwz.date/fhdr)\n\n{% span center blue, 该图来自网络，侵删 %}\n\n#### (*)[] - 数组指针\n\n&emsp;&emsp;数组指针实际上是一个指针，指针指向数组所在的内存地址，内存结构如下：\n\n![指针数组](https://dwz.date/fhdq)\n\n{% span center blue, 该图来自网络，侵删 %}\n\n---\n\n&emsp;&emsp;现在，已知上面两种写法其中一种是正确的，读者可以尝试根据这两种内存结构推理一下哪一种是可以通过编译的。\n\n&emsp;&emsp;答案是第二种，为什么呢？我们将二维数组带入进去可以发现，第二种写法只是存储了数组中第一个元素的地址，这和二维数组的内存结构是一致的，所以可以正确运行。而第一种写法其实其内存结构和二级指针构成的数组大差不差。\n\n# 参考资料\n\n>[C语言中的二级指针和二维数组问题](https://www.linuxidc.com/Linux/2015-03/115055.htm)\n>\n>[C语言中指针和数组](https://www.cnblogs.com/downey-blog/p/10469906.html)\n>\n>[数组指针和指针数组的区别](https://dwz.date/fhdp)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"point","published":1,"updated":"2021-11-02T14:42:25.366Z","_id":"ckvg8lb050000u4wq30gdesj3","comments":1,"layout":"post","photos":[],"link":"","content":"<div class=\"tip warning faa-horizontal animated\"><div class=\"text\" style=\" text-align:center;\">本篇博客内容有待论证，如果不是前来查误的请勿阅读！</div></div>\n<div class=\"tip info\"><p></p><p><div class=\"text\" style=\" text-align:center;\">本篇博客所指的所有内存均不区分高级缓存、内存、虚拟内存</div></p>\n<p></p><p><div class=\"text\" style=\" text-align:center;\"><font size=\"2px\">本篇博客也不会单独讲解数组，阅读之前请确保自己已经掌握了数组的基本内容</font></div></p>\n</div>\n<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><div class=\"tip info\"><div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#ffffff\">这里只是对内存简单并片面的进行了简单的介绍，更多内容还请自行搜索</font></div></div>\n<p>&emsp;&emsp;说到指针，肯定无法避免的和内存扯上关系。从硬件层面来说，内存是用来临时（断电丢失数据）存储程序运行时数据的高速存储设备。从软件层面来说，内存相当于一个容量巨大的一维数组，下标从<code>0</code>开始，依次向后排列，这个下标也就是我们经常说的“内存地址”。</p>\n<p>&emsp;&emsp;需要注意的是，实际开发中（仅限于win10平台，win从什么版本开始这个设计和其它平台的我不清楚）所有程序的内存地址都是从<code>0</code>开始的，这是因为操作系统为了安全性考虑没有将真实的内存地址暴露给程序，程序访问到的是其实是一个虚拟的内存地址，程序的内存地址表示的是该内存在操作系统给程序分配的内存空间中的位置。</p>\n<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><h2 id=\"本质\"><a href=\"#本质\" class=\"headerlink\" title=\"本质\"></a>本质</h2><p>&emsp;&emsp;指针的声明方法如下（格式：[类型] *[变量名]）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">int</span> *i;<br><span class=\"hljs-keyword\">double</span> *d;<br><span class=\"hljs-keyword\">void</span> *v;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;读者可能会好奇，为什么可以声明一个类型为<code>void</code>的变量？这就涉及到指针的本质了。指针（不论什么类型的指针）实际上是一个整形数据，其中存储的是它指向的量的内存地址。<code>void *v</code>表示指向一个数据类型未知的量的内存地址。</p>\n<h2 id=\"空指针\"><a href=\"#空指针\" class=\"headerlink\" title=\"空指针\"></a>空指针</h2><p>&emsp;&emsp;C/C++中提供了一个值：<code>NULL</code>，该值用于表示当前指针为空值，即没有指向任意有效的内存。一般情况下，当当前指针不可用时，推荐手动将其赋值为<code>NULL</code>，以防后面不小心再次使用。</p>\n<h2 id=\"指针是数据类型吗\"><a href=\"#指针是数据类型吗\" class=\"headerlink\" title=\"指针是数据类型吗\"></a>指针是数据类型吗</h2><p>&emsp;&emsp;很多人可能会疑惑下面两种写法哪一种正确：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> *arg0;<br><span class=\"hljs-keyword\">int</span>* arg0;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这两种声明方式放在程序中都可以正常编译并运行，但是假如我们要声明三个指针，下面两种方法哪种正确呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> *a0, *a1, *a2;<br><span class=\"hljs-keyword\">int</span>* b0, b1, b2;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在情况发生了变化，其中一种写法会导致编译错误（指使用时报错，而非声明时报错）或运行错误（如果编译通过了的话），读者可以先自行尝试一下。</p>\n<p>&emsp;&emsp;这两种方法中第二种方法实际上声明了一个指针变量<code>b0</code>和两个<code>int</code>变量<code>b1</code>、<code>b2</code>。写出这样的代码明显是将指针当作了一种数据类型来处理，但是实际上指针并不是一种数据类型，<code>*</code>只是告诉编译器，这个变量存储的是一个地址，而不是告诉编译器这是一个指针类型。</p>\n<p>&emsp;&emsp;由此可见，我们应该使用<code>*</code>与变量名贴在一起的写法，同时还可以得知<strong>指针不是数据类型</strong>。</p>\n<h2 id=\"指针加法\"><a href=\"#指针加法\" class=\"headerlink\" title=\"指针加法\"></a>指针加法</h2><p>&emsp;&emsp;指针的加法和数字的加法不同，我们知道，不同类型的数据的长度是不一样的，以<code>64位</code>电脑为例，<code>int</code>为<code>32位/4字节</code>，<code>char</code>为<code>8位/1字节</code>。指针的加法会根据类型的不同而变化，比如对于<code>int *a0</code>，<code>a0 + 1</code>返回的实际上是<code>a0</code>所指向的地址再加<code>4</code>的结果。简单说就是指针<code>+1</code>的结果是当前地址+数据类型长度的结果。</p>\n<p>&emsp;&emsp;由此我们可以得到如下公式：<code>point + k -&gt; point + (k * sizeof(type))</code>，其中<code>point</code>是指针对象，<code>k</code>是要加的数字，<code>type</code>是数据类型。需要注意的是，这个转换编译器已经帮我们完成，我们使用的时候只需要用左边的写法就可以了。</p>\n<h1 id=\"指针和数组\"><a href=\"#指针和数组\" class=\"headerlink\" title=\"指针和数组\"></a>指针和数组</h1><h2 id=\"一维（一级）\"><a href=\"#一维（一级）\" class=\"headerlink\" title=\"一维（一级）\"></a>一维（一级）</h2><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>&emsp;&emsp;我们写出如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">array</span>[<span class=\"hljs-number\">10</span>];<br><span class=\"hljs-keyword\">int</span> *arrayPoint = <span class=\"hljs-built_in\">array</span>;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;可以知道，我们通过<code>arrayPoint</code>来访问数组是完全没有问题的，因为标准规定，数组名存储的是数组中第一个元素的内存地址。所以我们可以把数组看作一种<strong>另类的指针</strong>（注意是另类的指针而并不是指针）。调用函数并传递数组进去也不会把数组复制一遍，而是传递数组中第一个元素的地址。</p>\n<h3 id=\"指针-1\"><a href=\"#指针-1\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>&emsp;&emsp;那么我们如何用指针来表示数组呢？如下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> *<span class=\"hljs-built_in\">array</span> = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">10</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">int</span>));<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>malloc</code>在堆分配了一个长度为<code>10 * sizeof(int)</code>的内存空间，并且返回这段内存的启示位置的地址。由此可知，我们将数组的地址存储到了<code>array</code>中，实际的内容分配到了堆中。结构如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/point/op.png\" alt=\"指针\"></p>\n<h2 id=\"二维（二级）\"><a href=\"#二维（二级）\" class=\"headerlink\" title=\"二维（二级）\"></a>二维（二级）</h2><p>&emsp;&emsp;有了上面的结论，我们可以写下这样子的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">int array[10][10];<br>int **arrayPoint = array;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;经过测试可以发现，这段代码无法通过编译，为什么呢？因为数组名只是一种另类的指针，而非指针，它和指针其实完全不是一种东西。</p>\n<h3 id=\"指针-2\"><a href=\"#指针-2\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>&emsp;&emsp;声明指针形式的二维数组的方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> **arrayPoint = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">3</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">int</span>*));<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; ++i) &#123;<br>    arrayPoint[i] = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">3</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">int</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;其内存结构如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/point/tp.png\" alt=\"内存结构\"></p>\n<p>&emsp;&emsp;这里解释一下为什么会这样。首先，我们在栈中存储了数组的地址。然后为数组分配了一个内存空间，这里要注意，我们分配空间的时候先使用<code>malloc</code>分配了一个长度为<code>3 * sizeof(int*)</code>的空间，随后再遍历这个一维数组，继续分配二维空间。可以理解为我们创建了四个数组，其中一个用于存储剩余数组的起始内存地址。</p>\n<h3 id=\"数组-1\"><a href=\"#数组-1\" class=\"headerlink\" title=\"数组\"></a>数组</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> arr1[<span class=\"hljs-number\">9</span>];<br><span class=\"hljs-keyword\">int</span> arr2[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">3</span>];<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们来看一下数组的内存结构（数组声明在函数中且不是<code>static</code>就存在栈中，否则在堆中）：</p>\n<p><img src=\"https://www.linuxidc.com/upload/2015_03/15031621526830.png\" alt=\"二维数组内存结构\"></p>\n<span class=\"p center blue\">该图来自网络，侵删</span>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>&emsp;&emsp;对比内存结构我们发现，一维数组可以通过指针进行操作完全是因为两者的内存结构“凑巧”一样而已，而到了二维（或更高）层次后，两者内存结构的区别便凸显了出来，所以显然是不能够共用的。</p>\n<p>&emsp;&emsp;那么如果我非要用指针的形式表示二维数组应该怎么声明呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">array</span>[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">10</span>];<br><br><span class=\"hljs-keyword\">int</span> *p1[<span class=\"hljs-number\">10</span>] = <span class=\"hljs-built_in\">array</span>;\t\t<span class=\"hljs-comment\">//1</span><br><span class=\"hljs-keyword\">int</span> (*p2)[<span class=\"hljs-number\">10</span>] = <span class=\"hljs-built_in\">array</span>;\t\t<span class=\"hljs-comment\">//2</span><br></code></pre></td></tr></table></figure>\n<hr>\n<p>&emsp;&emsp;我们先来分析一下这两种写法的区别：</p>\n<h4 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"*[] - 指针数组\"></a>*[] - 指针数组</h4><p>&emsp;&emsp;指针数组实际上是一个数组，其中存储了一些指针的值，内存结构如下：</p>\n<p><img src=\"https://dwz.date/fhdr\" alt=\"指针数组\"></p>\n<span class=\"p center blue\">该图来自网络，侵删</span>\n<h4 id=\"数组指针\"><a href=\"#数组指针\" class=\"headerlink\" title=\"(*)[] - 数组指针\"></a>(*)[] - 数组指针</h4><p>&emsp;&emsp;数组指针实际上是一个指针，指针指向数组所在的内存地址，内存结构如下：</p>\n<p><img src=\"https://dwz.date/fhdq\" alt=\"指针数组\"></p>\n<span class=\"p center blue\">该图来自网络，侵删</span>\n<hr>\n<p>&emsp;&emsp;现在，已知上面两种写法其中一种是正确的，读者可以尝试根据这两种内存结构推理一下哪一种是可以通过编译的。</p>\n<p>&emsp;&emsp;答案是第二种，为什么呢？我们将二维数组带入进去可以发现，第二种写法只是存储了数组中第一个元素的地址，这和二维数组的内存结构是一致的，所以可以正确运行。而第一种写法其实其内存结构和二级指针构成的数组大差不差。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<p><a href=\"https://www.linuxidc.com/Linux/2015-03/115055.htm\">C语言中的二级指针和二维数组问题</a></p>\n<p><a href=\"https://www.cnblogs.com/downey-blog/p/10469906.html\">C语言中指针和数组</a></p>\n<p><a href=\"https://dwz.date/fhdp\">数组指针和指针数组的区别</a></p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情链接","class_desc":"另一个我","link_list":[{"name":"Bilibili","link":"https://space.bilibili.com/66951474","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibili.png","descr":"探索我的视频~","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/bilibiliSite.jpg"}]},{"class_name":"拓展","class_desc":"大佬专区","link_list":[{"name":"碳基的小天地","link":"https://www.yuque.com/probius","avatar":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tj.png","descr":"妄想全栈的fw碳基酱（","siteshot":"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/tjSite.png"},{"name":"There,hello大大","link":"https://www.therehello.top/","avatar":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/avatar.jpg","descr":"大一菜鸡，多多关注","siteshot":"https://cdn.jsdelivr.net/gh/therehello/therehello.github.io@master/images/home.jpg"},{"name":"Akilar店长","link":"https://akilar.top","avatar":"https://akilar.top/img/siteicon/favicon.png","descr":"欢迎光临糖果屋","siteshot":"https://cdn.jsdelivr.net/gh/Akilarlxh/ScreenShot@gh-pages/akilar.top.jpg"}]}]}},"excerpt":"","more":"<div class=\"tip warning faa-horizontal animated\"><div class=\"text\" style=\" text-align:center;\">本篇博客内容有待论证，如果不是前来查误的请勿阅读！</div></div>\n<div class=\"tip info\"><p></p><p><div class=\"text\" style=\" text-align:center;\">本篇博客所指的所有内存均不区分高级缓存、内存、虚拟内存</div></p>\n<p></p><p><div class=\"text\" style=\" text-align:center;\"><font size=\"2px\">本篇博客也不会单独讲解数组，阅读之前请确保自己已经掌握了数组的基本内容</font></div></p>\n</div>\n<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><div class=\"tip info\"><div class=\"text\" style=\" text-align:center;\"><font size=\"2px\" font color=\"#ffffff\">这里只是对内存简单并片面的进行了简单的介绍，更多内容还请自行搜索</font></div></div>\n<p>&emsp;&emsp;说到指针，肯定无法避免的和内存扯上关系。从硬件层面来说，内存是用来临时（断电丢失数据）存储程序运行时数据的高速存储设备。从软件层面来说，内存相当于一个容量巨大的一维数组，下标从<code>0</code>开始，依次向后排列，这个下标也就是我们经常说的“内存地址”。</p>\n<p>&emsp;&emsp;需要注意的是，实际开发中（仅限于win10平台，win从什么版本开始这个设计和其它平台的我不清楚）所有程序的内存地址都是从<code>0</code>开始的，这是因为操作系统为了安全性考虑没有将真实的内存地址暴露给程序，程序访问到的是其实是一个虚拟的内存地址，程序的内存地址表示的是该内存在操作系统给程序分配的内存空间中的位置。</p>\n<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><h2 id=\"本质\"><a href=\"#本质\" class=\"headerlink\" title=\"本质\"></a>本质</h2><p>&emsp;&emsp;指针的声明方法如下（格式：[类型] *[变量名]）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-keyword\">int</span> *i;<br><span class=\"hljs-keyword\">double</span> *d;<br><span class=\"hljs-keyword\">void</span> *v;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;读者可能会好奇，为什么可以声明一个类型为<code>void</code>的变量？这就涉及到指针的本质了。指针（不论什么类型的指针）实际上是一个整形数据，其中存储的是它指向的量的内存地址。<code>void *v</code>表示指向一个数据类型未知的量的内存地址。</p>\n<h2 id=\"空指针\"><a href=\"#空指针\" class=\"headerlink\" title=\"空指针\"></a>空指针</h2><p>&emsp;&emsp;C/C++中提供了一个值：<code>NULL</code>，该值用于表示当前指针为空值，即没有指向任意有效的内存。一般情况下，当当前指针不可用时，推荐手动将其赋值为<code>NULL</code>，以防后面不小心再次使用。</p>\n<h2 id=\"指针是数据类型吗\"><a href=\"#指针是数据类型吗\" class=\"headerlink\" title=\"指针是数据类型吗\"></a>指针是数据类型吗</h2><p>&emsp;&emsp;很多人可能会疑惑下面两种写法哪一种正确：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> *arg0;<br><span class=\"hljs-keyword\">int</span>* arg0;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;这两种声明方式放在程序中都可以正常编译并运行，但是假如我们要声明三个指针，下面两种方法哪种正确呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> *a0, *a1, *a2;<br><span class=\"hljs-keyword\">int</span>* b0, b1, b2;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;现在情况发生了变化，其中一种写法会导致编译错误（指使用时报错，而非声明时报错）或运行错误（如果编译通过了的话），读者可以先自行尝试一下。</p>\n<p>&emsp;&emsp;这两种方法中第二种方法实际上声明了一个指针变量<code>b0</code>和两个<code>int</code>变量<code>b1</code>、<code>b2</code>。写出这样的代码明显是将指针当作了一种数据类型来处理，但是实际上指针并不是一种数据类型，<code>*</code>只是告诉编译器，这个变量存储的是一个地址，而不是告诉编译器这是一个指针类型。</p>\n<p>&emsp;&emsp;由此可见，我们应该使用<code>*</code>与变量名贴在一起的写法，同时还可以得知<strong>指针不是数据类型</strong>。</p>\n<h2 id=\"指针加法\"><a href=\"#指针加法\" class=\"headerlink\" title=\"指针加法\"></a>指针加法</h2><p>&emsp;&emsp;指针的加法和数字的加法不同，我们知道，不同类型的数据的长度是不一样的，以<code>64位</code>电脑为例，<code>int</code>为<code>32位/4字节</code>，<code>char</code>为<code>8位/1字节</code>。指针的加法会根据类型的不同而变化，比如对于<code>int *a0</code>，<code>a0 + 1</code>返回的实际上是<code>a0</code>所指向的地址再加<code>4</code>的结果。简单说就是指针<code>+1</code>的结果是当前地址+数据类型长度的结果。</p>\n<p>&emsp;&emsp;由此我们可以得到如下公式：<code>point + k -&gt; point + (k * sizeof(type))</code>，其中<code>point</code>是指针对象，<code>k</code>是要加的数字，<code>type</code>是数据类型。需要注意的是，这个转换编译器已经帮我们完成，我们使用的时候只需要用左边的写法就可以了。</p>\n<h1 id=\"指针和数组\"><a href=\"#指针和数组\" class=\"headerlink\" title=\"指针和数组\"></a>指针和数组</h1><h2 id=\"一维（一级）\"><a href=\"#一维（一级）\" class=\"headerlink\" title=\"一维（一级）\"></a>一维（一级）</h2><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>&emsp;&emsp;我们写出如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">array</span>[<span class=\"hljs-number\">10</span>];<br><span class=\"hljs-keyword\">int</span> *arrayPoint = <span class=\"hljs-built_in\">array</span>;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;可以知道，我们通过<code>arrayPoint</code>来访问数组是完全没有问题的，因为标准规定，数组名存储的是数组中第一个元素的内存地址。所以我们可以把数组看作一种<strong>另类的指针</strong>（注意是另类的指针而并不是指针）。调用函数并传递数组进去也不会把数组复制一遍，而是传递数组中第一个元素的地址。</p>\n<h3 id=\"指针-1\"><a href=\"#指针-1\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>&emsp;&emsp;那么我们如何用指针来表示数组呢？如下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> *<span class=\"hljs-built_in\">array</span> = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">10</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">int</span>));<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;<code>malloc</code>在堆分配了一个长度为<code>10 * sizeof(int)</code>的内存空间，并且返回这段内存的启示位置的地址。由此可知，我们将数组的地址存储到了<code>array</code>中，实际的内容分配到了堆中。结构如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/point/op.png\" alt=\"指针\"></p>\n<h2 id=\"二维（二级）\"><a href=\"#二维（二级）\" class=\"headerlink\" title=\"二维（二级）\"></a>二维（二级）</h2><p>&emsp;&emsp;有了上面的结论，我们可以写下这样子的代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs plaintext\">int array[10][10];<br>int **arrayPoint = array;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;经过测试可以发现，这段代码无法通过编译，为什么呢？因为数组名只是一种另类的指针，而非指针，它和指针其实完全不是一种东西。</p>\n<h3 id=\"指针-2\"><a href=\"#指针-2\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>&emsp;&emsp;声明指针形式的二维数组的方法如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> **arrayPoint = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">3</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">int</span>*));<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; ++i) &#123;<br>    arrayPoint[i] = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-number\">3</span> * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">int</span>));<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;其内存结构如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/EmptyDreams/resources/point/tp.png\" alt=\"内存结构\"></p>\n<p>&emsp;&emsp;这里解释一下为什么会这样。首先，我们在栈中存储了数组的地址。然后为数组分配了一个内存空间，这里要注意，我们分配空间的时候先使用<code>malloc</code>分配了一个长度为<code>3 * sizeof(int*)</code>的空间，随后再遍历这个一维数组，继续分配二维空间。可以理解为我们创建了四个数组，其中一个用于存储剩余数组的起始内存地址。</p>\n<h3 id=\"数组-1\"><a href=\"#数组-1\" class=\"headerlink\" title=\"数组\"></a>数组</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> arr1[<span class=\"hljs-number\">9</span>];<br><span class=\"hljs-keyword\">int</span> arr2[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">3</span>];<br></code></pre></td></tr></table></figure>\n<p>&emsp;&emsp;我们来看一下数组的内存结构（数组声明在函数中且不是<code>static</code>就存在栈中，否则在堆中）：</p>\n<p><img src=\"https://www.linuxidc.com/upload/2015_03/15031621526830.png\" alt=\"二维数组内存结构\"></p>\n<span class=\"p center blue\">该图来自网络，侵删</span>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>&emsp;&emsp;对比内存结构我们发现，一维数组可以通过指针进行操作完全是因为两者的内存结构“凑巧”一样而已，而到了二维（或更高）层次后，两者内存结构的区别便凸显了出来，所以显然是不能够共用的。</p>\n<p>&emsp;&emsp;那么如果我非要用指针的形式表示二维数组应该怎么声明呢？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-built_in\">array</span>[<span class=\"hljs-number\">10</span>][<span class=\"hljs-number\">10</span>];<br><br><span class=\"hljs-keyword\">int</span> *p1[<span class=\"hljs-number\">10</span>] = <span class=\"hljs-built_in\">array</span>;\t\t<span class=\"hljs-comment\">//1</span><br><span class=\"hljs-keyword\">int</span> (*p2)[<span class=\"hljs-number\">10</span>] = <span class=\"hljs-built_in\">array</span>;\t\t<span class=\"hljs-comment\">//2</span><br></code></pre></td></tr></table></figure>\n<hr>\n<p>&emsp;&emsp;我们先来分析一下这两种写法的区别：</p>\n<h4 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"*[] - 指针数组\"></a>*[] - 指针数组</h4><p>&emsp;&emsp;指针数组实际上是一个数组，其中存储了一些指针的值，内存结构如下：</p>\n<p><img src=\"https://dwz.date/fhdr\" alt=\"指针数组\"></p>\n<span class=\"p center blue\">该图来自网络，侵删</span>\n<h4 id=\"数组指针\"><a href=\"#数组指针\" class=\"headerlink\" title=\"(*)[] - 数组指针\"></a>(*)[] - 数组指针</h4><p>&emsp;&emsp;数组指针实际上是一个指针，指针指向数组所在的内存地址，内存结构如下：</p>\n<p><img src=\"https://dwz.date/fhdq\" alt=\"指针数组\"></p>\n<span class=\"p center blue\">该图来自网络，侵删</span>\n<hr>\n<p>&emsp;&emsp;现在，已知上面两种写法其中一种是正确的，读者可以尝试根据这两种内存结构推理一下哪一种是可以通过编译的。</p>\n<p>&emsp;&emsp;答案是第二种，为什么呢？我们将二维数组带入进去可以发现，第二种写法只是存储了数组中第一个元素的地址，这和二维数组的内存结构是一致的，所以可以正确运行。而第一种写法其实其内存结构和二级指针构成的数组大差不差。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><blockquote>\n<p><a href=\"https://www.linuxidc.com/Linux/2015-03/115055.htm\">C语言中的二级指针和二维数组问题</a></p>\n<p><a href=\"https://www.cnblogs.com/downey-blog/p/10469906.html\">C语言中指针和数组</a></p>\n<p><a href=\"https://dwz.date/fhdp\">数组指针和指针数组的区别</a></p>\n</blockquote>\n"}],"PostAsset":[{"_id":"source/_posts/ReviewOfDevelopmentGuide/run.png","slug":"run.png","post":"cku22zp2s00037kwq5j6cczv4","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cku22zp2y00097kwqhf9r168u","category_id":"cku22zp2t00047kwq8bmehou1","_id":"cku22zp39000j7kwqat1xhw6z"},{"post_id":"cku22zp2p00017kwqei1o83bq","category_id":"cku22zp2t00047kwq8bmehou1","_id":"cku22zp3a000n7kwq3deh6pkn"},{"post_id":"cku22zp2s00037kwq5j6cczv4","category_id":"cku22zp35000c7kwq3hnr3za0","_id":"cku22zp3b000q7kwq24jh5m9a"},{"post_id":"cku22zp2v00077kwqgq5aeaai","category_id":"cku22zp39000k7kwq713mg3c8","_id":"cku22zp3c000w7kwq72vn8spx"},{"post_id":"cku22zp37000g7kwq22o52j7w","category_id":"cku22zp39000k7kwq713mg3c8","_id":"cku22zp3h00187kwq3w3sarxq"},{"post_id":"cku22zp38000i7kwq6ihffqmw","category_id":"cku22zp3g00117kwqbvypduqb","_id":"cku22zp3h001b7kwqcu8xbn90"},{"post_id":"cku22zp3l001f7kwq5f583j93","category_id":"cku22zp2t00047kwq8bmehou1","_id":"cku22zp3m001h7kwqejn80enb"},{"post_id":"cku3ervps0002s0wqf8m1bmhl","category_id":"cku3ervpo0000s0wq69rpacqe","_id":"cku3ervpt0004s0wq6bijhpk9"},{"post_id":"cku22zp34000b7kwq48tv5xps","category_id":"cku3ervpo0000s0wq69rpacqe","_id":"cku3ervpu0007s0wq2ba8ggpa"},{"post_id":"ckunqfwod0000cwwq9mgsfa9s","category_id":"ckunqfwoh0001cwwqfqwmhfyz","_id":"ckunqfwol0005cwwqcuofezu2"},{"post_id":"ckvdzwpgf0000h8wq99treu3s","category_id":"cku3ervpo0000s0wq69rpacqe","_id":"ckvdzwpgo0002h8wqh8ckg19z"},{"post_id":"ckvdzwpgt000ah8wq5gik3hfs","category_id":"cku22zp39000k7kwq713mg3c8","_id":"ckvdzwpgv000gh8wq6u4x19p0"},{"post_id":"ckvdzwpgu000dh8wqge8xfn23","category_id":"cku22zp39000k7kwq713mg3c8","_id":"ckvdzwpgw000jh8wq2h3c6kll"},{"post_id":"ckvdzwpgs0009h8wqc3ls937s","category_id":"ckvdzwpgt000bh8wqd4mu7i92","_id":"ckvdzwpgw000kh8wqchoz0ynz"},{"post_id":"ckvg8lb050000u4wq30gdesj3","category_id":"cku3ervpo0000s0wq69rpacqe","_id":"ckvg8lb080003u4wq35spc8dt"}],"PostTag":[{"post_id":"cku22zp2p00017kwqei1o83bq","tag_id":"cku22zp2u00057kwqeumj6qan","_id":"cku22zp36000e7kwqb7beeobf"},{"post_id":"cku22zp2s00037kwq5j6cczv4","tag_id":"cku22zp35000d7kwq6yyeefu4","_id":"cku22zp3a000o7kwq6w5o5uxg"},{"post_id":"cku22zp2v00077kwqgq5aeaai","tag_id":"cku22zp39000l7kwq6b8w1z9s","_id":"cku22zp3b000u7kwqb14045el"},{"post_id":"cku22zp2y00097kwqhf9r168u","tag_id":"cku22zp3b000s7kwqenu94xwp","_id":"cku22zp3g00157kwq446why8p"},{"post_id":"cku22zp2y00097kwqhf9r168u","tag_id":"cku22zp39000l7kwq6b8w1z9s","_id":"cku22zp3h00177kwq656zcf69"},{"post_id":"cku22zp37000g7kwq22o52j7w","tag_id":"cku22zp39000l7kwq6b8w1z9s","_id":"cku22zp3i001d7kwq0r2r0c6m"},{"post_id":"cku22zp38000i7kwq6ihffqmw","tag_id":"cku22zp39000l7kwq6b8w1z9s","_id":"cku22zp3i001e7kwq89ti86zt"},{"post_id":"cku22zp34000b7kwq48tv5xps","tag_id":"cku22zp39000l7kwq6b8w1z9s","_id":"cku3ervpr0001s0wqfja77jpw"},{"post_id":"cku22zp38000i7kwq6ihffqmw","tag_id":"cku3ervpt0003s0wq92hg8nvz","_id":"cku3ervpu0006s0wq58sphg8n"},{"post_id":"cku3ervps0002s0wqf8m1bmhl","tag_id":"cku3ervpt0005s0wq8zwg6frv","_id":"cku3ervpu0008s0wqcqvvbdld"},{"post_id":"cku3ervps0002s0wqf8m1bmhl","tag_id":"cku22zp39000l7kwq6b8w1z9s","_id":"cku3ervpu0009s0wqd8eh3poi"},{"post_id":"cku22zp3l001f7kwq5f583j93","tag_id":"cku3ervpy000as0wqbprcdjx9","_id":"cku3ervpz000cs0wqgubgf62z"},{"post_id":"cku22zp3l001f7kwq5f583j93","tag_id":"cku22zp3b000s7kwqenu94xwp","_id":"cku3ervpz000ds0wqcz7n5k95"},{"post_id":"cku22zp3l001f7kwq5f583j93","tag_id":"cku3ervpy000bs0wq4198haiv","_id":"cku3ervpz000es0wqax20d5he"},{"post_id":"ckunqfwod0000cwwq9mgsfa9s","tag_id":"ckunqfwoj0002cwwq2m70a1vp","_id":"ckunqfwok0003cwwqcjsy1moc"},{"post_id":"ckunqfwod0000cwwq9mgsfa9s","tag_id":"cku22zp39000l7kwq6b8w1z9s","_id":"ckunqfwol0004cwwqenqxfkab"},{"post_id":"ckvdzwpgf0000h8wq99treu3s","tag_id":"ckvdzwpgk0001h8wqdl9x6vjz","_id":"ckvdzwpgo0004h8wqbhppc395"},{"post_id":"ckvdzwpgf0000h8wq99treu3s","tag_id":"cku22zp39000l7kwq6b8w1z9s","_id":"ckvdzwpgp0005h8wqfcipa9y2"},{"post_id":"cku22zp2v00077kwqgq5aeaai","tag_id":"ckvdzwpgo0003h8wq3ixd01hu","_id":"ckvdzwpgq0007h8wq45bp8rjg"},{"post_id":"cku22zp34000b7kwq48tv5xps","tag_id":"ckvdzwpgk0001h8wqdl9x6vjz","_id":"ckvdzwpgq0008h8wqd8mz6rpn"},{"post_id":"ckvdzwpgt000ah8wq5gik3hfs","tag_id":"cku22zp39000l7kwq6b8w1z9s","_id":"ckvdzwpgu000eh8wq3v7y63v5"},{"post_id":"ckvdzwpgt000ah8wq5gik3hfs","tag_id":"ckvdzwpgo0003h8wq3ixd01hu","_id":"ckvdzwpgv000fh8wq89dq0g6d"},{"post_id":"ckvdzwpgs0009h8wqc3ls937s","tag_id":"ckvdzwpgt000ch8wqdr3eh20h","_id":"ckvdzwpgw000ih8wqbfi5el9y"},{"post_id":"ckvdzwpgu000dh8wqge8xfn23","tag_id":"ckvdzwpgv000hh8wqai9991ce","_id":"ckvdzwpgw000lh8wqckdsap2n"},{"post_id":"ckvdzwpgu000dh8wqge8xfn23","tag_id":"cku22zp39000l7kwq6b8w1z9s","_id":"ckvdzwpgw000mh8wq3rq8574l"},{"post_id":"ckvg8lb050000u4wq30gdesj3","tag_id":"cku22zp39000l7kwq6b8w1z9s","_id":"ckvg8lb080001u4wq1bn97hk8"},{"post_id":"ckvg8lb050000u4wq30gdesj3","tag_id":"ckvg4uwuc00013cwq2yei43b0","_id":"ckvg8lb080002u4wq2ohg9ida"},{"post_id":"ckvg8lb050000u4wq30gdesj3","tag_id":"ckvg4uwuh00033cwq27dj9pez","_id":"ckvg8lb090004u4wq8g0xbqhn"}],"Tag":[{"name":"类","_id":"cku22zp2u00057kwqeumj6qan"},{"name":"Java","_id":"cku22zp35000d7kwq6yyeefu4"},{"name":"教程","_id":"cku22zp39000l7kwq6b8w1z9s"},{"name":"MC","_id":"cku22zp3b000s7kwqenu94xwp"},{"name":"代码规范","_id":"cku22zp3g00137kwqhdu7akbf"},{"name":"现代工业 - MC","_id":"cku22zp3l001g7kwq216pfi57"},{"name":"环境","_id":"cku3ervpt0003s0wq92hg8nvz"},{"name":"函数","_id":"cku3ervpt0005s0wq8zwg6frv"},{"name":"现代工业","_id":"cku3ervpy000as0wqbprcdjx9"},{"name":"日志","_id":"cku3ervpy000bs0wq4198haiv"},{"name":"电流","_id":"ckunqfwoj0002cwwq2m70a1vp"},{"name":"规范","_id":"ckvdzwpgk0001h8wqdl9x6vjz"},{"name":"进制","_id":"ckvdzwpgo0003h8wq3ixd01hu"},{"name":"日记","_id":"ckvdzwpgt000ch8wqdr3eh20h"},{"name":"递归","_id":"ckvdzwpgv000hh8wqai9991ce"},{"name":"数组","_id":"ckvg4uwuc00013cwq2yei43b0"},{"name":"指针","_id":"ckvg4uwuh00033cwq27dj9pez"}]}}